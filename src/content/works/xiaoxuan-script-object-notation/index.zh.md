# XiaoXuan Script Object Notation

_XiaoXuan Script Object Notation_ (_ASON_) 是一种易于人类阅读和书写的数据格式。它跟 _JSON_ 相似，但在其基础之上作出了许多改进和增强。

_ASON_ 主要用于作为应用程序的配置文件，不过也可用于数据传输。

**特点**

- **兼容 _JSON_ 和 _JSON5_ 的大部分语法。** 如果你已熟悉 _JSON_，那么你不用重新学习一门新的数据格式。

- **语法简单，严谨，一致。** _ASON_ 的语法接近编程语言，比如数字可以指定数据类型，支持多种格式的注释和字符串，键名不需要双引号括起来，末尾逗号可省略等等。这些特性能帮助用户能准确地表达自己所需的数据，同时也有助于对 _ASON_ 文档的修改和维护。

**目录**

<!-- @import "[TOC]" {cmd="toc" depthFrom=2 depthTo=4 orderedList=false} -->

<!-- code_chunk_output -->

- [ASON 文档示例](#ason-文档示例)
- [与 JSON 的比较](#与-json-的比较)
- [文件扩展名](#文件扩展名)
- [共享库及 API](#共享库及-api)
  - [Rust 版的 ASON 共享库](#rust-版的-ason-共享库)
- [规范](#规范)
  - [数字](#数字)
    - [整型数字](#整型数字)
    - [十进制浮点数](#十进制浮点数)
    - [十六进制浮点数](#十六进制浮点数)
    - [数字的数据类型](#数字的数据类型)
    - [国际单位制词头（Metric prefix）](#国际单位制词头metric-prefix)
  - [布尔](#布尔)
  - [字符](#字符)
    - [Unicode 转义字符](#unicode-转义字符)
  - [字符串](#字符串)
    - [长字符串](#长字符串)
    - [多行字符串](#多行字符串)
    - [原样字符串](#原样字符串)
    - [自动前导空白截除字符串](#自动前导空白截除字符串)
  - [日期](#日期)
  - [字节数据](#字节数据)
  - [数组](#数组)
    - [末尾逗号](#末尾逗号)
    - [数组的类型](#数组的类型)
  - [元组](#元组)
  - [对象](#对象)
    - [嵌套](#嵌套)
  - [变体](#变体)
    - [使用变体代替 `null`](#使用变体代替-null)
    - [对象字段的缺省值](#对象字段的缺省值)
  - [注释](#注释)
    - [行注释](#行注释)
    - [块注释](#块注释)
    - [文档注释](#文档注释)
    - [混合注释](#混合注释)

<!-- /code_chunk_output -->


## ASON 文档示例

一个典型的 _ASON_ 文档只包含一个 _ASON_ 对象。下面是一个 _ASON_ 文档的示例：

```json
{
    string: "hello world"
    raw_string: r"[a-z]+"
    number: 123
    number_with_data_type: 123_456_789@long
    float: 3.14
    double: 6.626e-34@double
    bool: true
    date: d"2023-03-24 12:30:00+08:00"
    variant_with_value: Option::Some(123)
    variant_without_value: Option::None
    array: [1,2,3,]
    tuple: (1, "foo", true)
    object: {
        id: 123
        name: "leaf"
    }
}
```

值得一提的是，一个 _ASON_ 文档里不一定都是一个 _ASON_ 对象，也可以是其它 _ASON_ 值，比如一个数组（Array），一个元组（Tuple），甚至还可以是单独一个数字或者字符串，这些都是有效的 _ASON_ 值。

## 与 JSON 的比较

_ASON_ 格式跟 _JSON_ 很相似，不过有几个显著不一样的地方：

- 数字可以有显式的数据类型。
- 浮点数不支持 `Inf`, `-Inf`, `-0` 和 `NaN` 等值。
- 支持十六进制以及二进制格式的数字。
- `null` 值是不允许的，取而代之的是一种新的叫做 `变体` 的类型。
- 对象的键名不支持使用双引号括起来。
- 字符串不支持使用单引号括起来。
- 数组（`Array`）要求其中的所有元素的数据类型必须相同。
- 支持多种格式的字符串和注释。
- 添加了日期（`Date`）、元组（`Tuple`）以及变体（`Variant`）等数据类型。
- 行末的逗号可以省略。
- 在数组、元组以及对象的最后一个元素的末尾处，可以添加一个逗号。

## 文件扩展名

_ASON_ 文档的文件扩展名是 `*.ason`。文件名示例：

`sample.ason`, `package.ason`

## 共享库及 API

目前只提供了 Rust 实现的 _ASON_ 序列化及反序列化库。

### Rust 版的 ASON 共享库

在你的项目目录里运行命令 `cargo add ason` 以添加 _ASON_ 库到你的项目。

该库提供了两个函数：

- 函数 `fn parse(s: &str) -> Result<AsonNode, ParseError>` 用于反序列化；
- 函数 `fn format(n: &AsonNode) -> String` 用于序列化。

**反序列化**

假设你有如下 _ASON_ 文本，它可能来自某个文件，也可能来自互联网：

```json
{
    id: 123
    name: "foo"
}
```

下面的代码演示了将该文本解析为 _ASON_ 对象并检查每个成员的值：

```rust
let text = "..."; // the ASON text above

let node = parse(text).unwrap();

if let AsonNode::Object(obj) = node {
    assert_eq!(
        &obj[0],
        &NameValuePair {
            name: "id".to_string(),
            value: Box::new(AsonNode::Number(NumberLiteral::Int(123)))
        }
    );

    assert_eq!(
        &obj[1],
        &NameValuePair {
            name: "name".to_string(),
            value: Box::new(AsonNode::String_("foo".to_string()))
        }
    );
}
```

**序列化**

假设有一个对象有两个字段，其字段名和值如下：

- name: "foo"
- version: "0.1.0"

下面代码演示了把该对象转换为 _ASON_ 文本：

```rust
let node = AsonNode::Object(vec![
    NameValuePair {
        name: "name".to_string(),
        value: Box::new(AsonNode::String_("foo".to_string())),
    },
    NameValuePair {
        name: "version".to_string(),
        value: Box::new(AsonNode::String_("0.1.0".to_string())),
    },
]);

let text = format(&node);
println!("{}", text);
```

输出的文本应该是:

```json
{
    name: "foo"
    version: "0.1.0"
    dependencies: [{
        name: "random"
        version: Option::None
    },{
        name: "regex"
        version: Option::Some("1.0.1")
    }]
}
```

## 规范

一个 _ASON_ 文档只能有一个 _ASON_ 值。

_ASON_ 值既可以是简单的数据，比如一个数字，一个日期，或者一个字符串。也可以是由多个简单的 _ASON_ 值组成的复杂数据，比如一个对象（`Object`）、一个数组（`Array`）、一个元组（`Tuple`）或者一个变体（`Variant`）。

### 数字

_ASON_ 支持整型和浮点型两种数字。

每个 _ASON_ 数字都有确定的数据类型。默认情况下，一个数字首先会推断为整型数字，其数据类型是 `int`（即 `i32`）。如果这个数字中间包含有小数点，或者包含有表示幂的字母 “e”，那么这个数字会被推断为浮点数，其数据类型是 `float`（即 `f32`）。

> ASON 浮点数不支持 `-0.0`, `+inf`, `-inf`, `nan` 等值。

所有数字的前面都可以加一个减号 “-” 表示负数，但不允许添加加号 “+” 表示正数（因为默认就是正数）。所有数位之间都可以添加一个或多个下划线 “_” 符号表示分组，_ASON_ 解析器会自动忽略数位之间的下划线符号。

#### 整型数字

整型数字可以使用十进制、十六进制以及二进制三种格式来表示，以下都是有效的整型数字：

- 十进制：`211`, `223_211`, `-2027`
- 十六进制：`0x1113`, `0x1719_abcd`, `-0xaabb`
- 二进制：`0b1100`, `0b1010_0001`, `-0b1100`

> ASON 不支持八进制格式的整数，比如 `0o755` 是无效的数字，而 `0644` 则等同于 `644`。

#### 十进制浮点数

当一个数字中间包含一个点号 "." 时，该数字会被推断为浮点数。另外 _ASON_ 数字也支持科学记数法，也就是：使用字母 "e" 以及一个正整数或负整数表示 10 的幂，显然当一个数字中间包含字母 “e” 时，它也会被推断为浮点数。

以下是十进制浮点数的示例：

`3.14`, `-2.718`, `0.123`, `123.0`, `2.998e8`, `6.626e-34`, `-1.7588e+11`

注意一个浮点数不能以点号 "." 或者字母 "e" 开始，也不能以点号 "." 或者字母 "e" 结束，下面是无效的数字：

`.123`, `123.`, `e123`, `123e`

#### 十六进制浮点数

在计算机内部，十进制浮点数有时会由于舍入而导致精度损失（即你书写的数字会被取了一个近似值），当你需要精确表示一个浮点数时，可以使用十六进制来表示。

十六进制浮点数的格式是 `0xh.hhhp±d`，这跟 C/C++ 里的 [十六进制浮点数常量/字面量](https://en.cppreference.com/w/c/language/floating_constant) 的格式是一样的。比如，`0x1.23p4` 表示 `(1x16^0 + 2x16^-1 + 3x16^-2) x 2^4 = (1.13671875 x 16)`, 它的值是 `18.1875`.

以下是十六进制浮点数的示例：

`0x1.921fb6p1`, `0x1.5bf0a8b145769p+1`, `0x1.23p-4`, `-0x1.23p4`

注意，字母 "p" 及其后面的正整数或者负整数是不能省略的，比如 `0x3.14` 和 `0x3.14p` 都是无效的数字。

> ASON 不支持二进制的格式的浮点数，比如 `0b11.10` 是一个无效的数字。

#### 数字的数据类型

_ASON_ 支持下列数字的数据类型：

- 8 位整型：`byte`, `ubyte`, `i8`, `u8`。
- 16 位整型：`short`, `ushort`, `i16`, `u16`。
- 32 位整型：`int`, `uint`, `i32`, `u32`。
- 64 位整型：`long`, `ulong`, `i64`, `u64`。
- 32 位浮点型（即单精度小数）：`float`, `f32`。
- 64 位浮点型（即双精度小数）：`double`, `f64`。

注意数字的数据类型名称有两个风格：一个是 C 语言风格，比如 `short`, `int` 和 `float`；另一个是 Rust 语言风格，比如 `i16`, `i32` 和 `f32`。虽然名称不一样，但它们是等同的。

通过在数字尾部添加 "@" 符号以及数据类型的名称，可以显式地指定该数字的数据类型。比如 `11@long` 表示 `long` 类型的数字 `11`，而 `3.14@double` 表示 `double` 类型的数字 `3.14`。

如果一个数字没有显式地指定它的数据类型，则对于整数，其默认数据类型是 `int`（即 `i32`），对于浮点数则是 `float`（即 `f32`）。

#### 国际单位制词头（Metric prefix）

_ASON_ 支持在一个数字的尾部添加一个 [国际单位制词头（metric prefix）](https://en.wikipedia.org/wiki/Metric_prefix) 以表示单位（unit）的倍数或者分数。

##### 整数词头

对于整数，_ASON_ 支持以下词头：

| 词头 | 10^n |
|-----|------|
| E   | 10^18 |
| P   | 10^15 |
| T   | 10^12 |
| G   | 10^9  |
| M   | 10^6  |
| K   | 10^3  |

带词头的数字的示例：

`100K`, `20M`, `3G`

它们等同于 `100_000`, `20_000_000` 和 `3_000_000_000`。

当一个数字的尾部添加以上词头时，其数据类型被推断为 `int`。你可以在这些词头的尾部再加上具体的数据类型名称（仅限于 `int`, `uint`, `long`, `ulong` 这四种类型），以显式地指定它的数据类型，比如 `100K@uint`, `20M@long`。

需要注意的是，因为 "E", "P", "T" 这三个词头的倍数已超出 `int` 类型的范围，所以当使用这三个词头时，必须显式地指定 `long` 或者 `ulong` 数据类型，否则会抛出 “数字超出范围” 的错误。比如数字 `12T` 是无效的数字，你需要写成 `12T@long` 或者 `12T@ulong`。

##### 二进制词头

_ASON_ 也支持下列 [二进制词头](https://en.wikipedia.org/wiki/Binary_prefix)：

| 词头 | 2^n |
|-----|------|
| EB   | 2^60 |
| PB   | 2^50 |
| TB   | 2^40 |
| GB   | 2^30 |
| MB   | 2^20 |
| KB   | 2^10 |

其中字母 "B" 也可以写成小写字母 "i"，比如 "KB" 和 "Ki" 是相同的，"TB" 和 "Ti" 也是相同的。

带二进制词头的数字的示例：

`100KB`, `20MB`, `3GB`

它们的值等于 `100 x 1024`，`20 x 1024 x 1024` 和 `3 x 1024 x 1024 x 1024`。

> 十六进制和二进制整数不能添加词头，比如 `0x24K`, `0b1010M` 都是无效的数字。

##### 小数词头

对于小数，_ASON_ 支持以下词头：

| 词头 | 10^n |
|-----|------|
| m   | 10^-3 |
| u   | 10^-6 |
| n   | 10^-9 |
| p   | 10^-12 |
| f   | 10^-15 |
| a   | 10^-18 |

带小数词头的数字的示例：

`100m`, `20u`, `3n`

它们等同于 `100e-3`，`20e-6`, `3e-9`。

当一个数字的尾部添加以上词头时，其数据类型会被推断为 `float`。你可以在这些词头的尾部再加上数据类型名称（仅限于 `float` 和 `double` 这两种类型），以显式地指定它的数据类型，比如 `100m@double`, `20n@double`。

> 十六进制浮点数不能添加词头，比如 `0x2.9p8m` 是无效的数字。

### 布尔

布尔值只有两个：`true` 和 `false`。

### 字符

字符值由一对单引号和一个字符组成，比如 `'a'`，`'文'`。

对于一些特殊字符，_ASON_ 使用一个反斜杠符号 `\` 和一个字符表示。_ASON_ 支持如下的转义字符：

- `'\t'`: Horizontal tabulation
- `'\r'`: Carriage return (CR)
- `'\n'`: New line character (也叫做 line feed, 或者 LF)
- `'\0'`: Null character
- `'\"'`: Doube quote
- `'\''`: Single quote
- `'\\'`: Backslash itself

 _ASON_ 不支持下列转义字符：

- `'\v'`: Vertical tabulation
- `'\f'`: Page breaking control character

#### Unicode 转义字符

字符除了直接书写出来，也可以使用格式 `'\u{...}'` 表示，其中 "..." 是 Unicode 字符的码点（code point）。比如横线符号 `'-'` 可以写为 `'\u{2d}'`, 字符 `'文'` 可以写为 `'\u{6587}'`。

值得一提的是，JavaScript 支持格式 `\uFFFF` 表示 Unicode 字符，以及 `\xFF` 表示 ASCII 字符，这两种格式 _ASON_ 都是不支持的。

> 注意某些表情符号可能是由多个 Unicode 字符组合而成的，虽然在显示时看起来像是一个字符。比如表情符号 🤦‍♂️，实际上它由 U+1F926, U+200D, U+2642, U+FE0F 4个字符组成，如果用单引号把这个表情符号括起来，则是一个无效的字符。详细的表情符号对应的码点（code point）可以[查阅这里](https://unicode.org/emoji/charts/full-emoji-list.html)。

### 字符串

字符串由一对双引号和一系列的字符组成，比如 `"abc"`, `"文字"`, `"😊🍍"`。

任何有效的字符都可以组成字符串，包括上述的转义字符，比如 `"foo\nbar"`，`"\u{2d}\u{6587}\0"`。

#### 长字符串

_ASON_ 支持将长字符串分成多行来书写，只需在行的末尾添加一个反斜杠符号 `\` 和一个换行符即可，例如：

```json
"Hello, \
    World!"
```

上面的字符串等同于 `"Hello, World!"`。注意每一行的前导空白会自动被截除。

#### 多行字符串

如果字符串由多个段落（行）组成，你可以直接把它们按原有的段落写下来，字符串当中的换行符会被保留下来，例如：

```json
"Hello,
    World! I am
    ASON."
```

上面的字符串等同于：

```json
"Hello,\n    World! I am\n    ASON."
```

注意在这种情况下，每行前面的前导空白符不会被截除，也就是说，两个双引号之间的普通字符、换行符、空白符都会被保留下来。

#### 原样字符串

有时反斜杠符号 `\` 刚好是我们需要的字符，比如书写正则表达式时，如果把所有反斜杠符号都写成 `\\`，不仅会显得混乱还容易出错。_ASON_ 支持 "原样字符串"，格式是 `r"..."`。

在原样字符串里，反斜杠符号不再具有转义功能，所有转义符号都会失效。也就是说，字符串的所有字符都会原样地被保留下来（当然会结束字符串的双引号除外）。比如：

```json
r"^\d*(\.\d+)?$"
```

上面的字符串等同于 `"^\\d*(\\.\\d+)?$"`。可见在某些特殊场合，使用原样字符串要比普通字符串清晰明了得多。

除了反斜杠符号，如果双引号 `"` 也是我们需要的字符呢？这种情况可以使用原样字符串的变体，格式是 `r#"..."#`。在这种字符串里，除非遇到 `"#` 这个结束标记，否则所有字符都会原样地被保留下来，包括双引号。比如：

```json
r#"<a href="https://hemashushu.github.io/" title="Home">Home Page</a>"#
```

上面的字符串等同于：

```json
"<a href=\"https://hemashushu.github.io/\" title=\"Home\">Home Page</a>"
```

#### 自动前导空白截除字符串

当我们书写多个段落的长文本时，因为代码缩进的原因，文本可能会被引入很多前导空白。一般情况下，我们只能通过手动删除每行的前导空白符来确保文本内容的正确，但如此一来就会破坏整体的缩进。为了解决这个问题，_ASON_ 引入了 “自动前导空白截除（trim）字符串” 这种特殊格式。

该类型字符串以标记 `r|"` 开始，然后正文从新的一行开始，最后以新的一行开始的标记 `"|` 结束。

正文里每一行的前导空白字符将会根据正文第一行的前导空白字符的数量自动截除（trim），比如第一行的前导空白字符数量为 8，则正文的每一行都会被最多截除 8 个前导空白字符。

下面是 "自动前导空白截除字符串" 的示例：

```json
{
    id: 123
    dependencies: [
        {
            name: "foo"
            description: r|"
                A sample module
                Features:
                    1. Simple
                    2. Efficient
                Authored by Bar and licensed under the LGPL.
                "|
        }
    ]
}

```

在上面的示例中，字段 “description” 的值是一个 “自动前导空白截除字符串”。因为其正文的第一行前导空白字符数量为 16，所以正文每一行都会最多被截除 16 个前导空白字符，所以它的值等同于：

```json
"A sample module
Features:
    1. Simple
    2. Efficient
Authored by Bar and licensed under the LGPL."
```

使用 “自动前导空白截除字符串” 时需要注意：

- 开始标记 `r|"` 后面必须紧跟一个换行符。
- 结束标记 `"|` 必须以新的一行开始。
- 开始标记 `|"` 后面的换行符，以及正文末尾的换行符，它们都不属于正文，它们属于开始标记和结束标记的一部分。所以在上例中，正文的开始和结束都没有换行符。

### 日期

_ASON_ 支持日期类型的数据，其格式是：`d"YYYY-MM-DD HH:mm:ss"`。日期的格式跟普通字符串有点相似，但请注意首个双引号前面有一个字母 "d"。

以下是日期的示例：

- `d"2023-03-24 10:15:00"`
- `d"2035-06-23 13:50:30"`

跟 [RFC 3339](https://datatracker.ietf.org/doc/html/rfc3339) 标准一样，可以在日期和时间之间添加字母 't' 或者 'T'，比如：

- `d"2023-03-24t10:15:00"`
- `d"2035-06-23T13:50:30"`

还可以在末尾添加 [协调世界时 (UTC)](https://en.wikipedia.org/wiki/Coordinated_Universal_Time) 时区，比如：

- `d"2023-03-24 10:15:00+08:00"`
- `d"2035-06-23 13:50:30-01:00"`

也可以使用字母 'z' 或者 'Z' 表示 `+00:00` 时区，比如：

- `d"2023-03-24 10:15:00z"`
- `d"2035-06-23 13:50:30Z"`

注意时间部分不能省略，如果在某些场合确实不需要时间部分，可以使用 `00:00:00` 填充。比如 `d"2023-04-09T00:00:00"`。

### 字节数据

字节数据是内存或者存储介质内的一段二进制数据，_ASON_ 支持以格式 `h"..."` 表示字节数据。其中 "..." 是一系列两位的十六进制字节值，例如：

`h"0011aabb"`

需要注意的是，每个字节值必须确保是两位，不足两位的要填充上数字 0。

字母 'a' 到 'f' 的大小写是不区分的，因此上面的字节数据也可以写为：

`h"0011AABB"`

为了更清晰地表示每个字节的值，在数位中间可以插入任意数量的空白符、横线、冒号、制表符，以及回车符和换行符，即 `[ -:\t\r\n]`。因此上面的字节数据还可以写成：

- `h"00 11 aa bb"`
- `h"00-11-aa-bb"`
- `h"00:11:aa:bb"`

当数据很长时，分多行书写也是可以的，比如：

```json
h"48 65 6C 6C    6F 2C 20 57
  6F 72 6C 64    21 20 49 20
  61 6D 20 41    53 4F 4E 2E"
```

### 数组

数组（Array）是一系列相同类型的 _ASON_ 值的集合，比如：

- `[1,2,3]`
- `["foo", "bar"]`
- `[true, false, true]`

_ASON_ 的数组要求其所有元素必须是相同的数据类型，比如 `[1, "foo", false]` 是一个无效的数组。

数组的元素可以在一行内连续书写，只需用逗号分隔各个元素即可。也可以分行书写，即每一行一个元素，比如：

```json
[
    "foo"
    "bar"
    "baz"
]
```

#### 末尾逗号

跟 _JSON_ 不同的是，在 _ASON_ 文档里，当分行书写元素时，行尾的逗号是可以省略的，实际上 _ASON_ 建议省略行尾的逗号。当然如果在行尾添加了逗号也是有效的，比如：

```json
[
    "foo",
    "bar",
    "baz",
]
```

还有一个跟 _JSON_ 不同的地方，_ASON_ 数组的最后一个元素的末尾可以添加逗号，比如上例当中的 "baz" 后面添加了一个逗号。甚至在同一行内的最后一个元素的末尾也是可以添加逗号的，比如 `[1,2,3,]`。

> 行末逗号的规则同样适用于下面段落将会讲述的 _元组_、_对象_。

#### 数组的类型

数组的元素除了可以是简单类型的数据，也可以是复杂类型的数据，比如元组、对象，甚至还可以是数组，比如：

```json
[
    [11, 13, 15]
    [23, 29]
    [31, 37, 39, 41]
]
```

注意数组元素的数量不属于 “类型” 的一部分，也就是说，一个包含 3 个元素的 `int` 数组，与一个包含 2 个元素的 `int` 数组的类型被认为是相同的。在上面的示例当中，我们看到有三个元素数量不一样的子数组，但因为它们的元素数据类型都是 `int`，所以这三个子数组的类型是相同的，因此它们可以组成一个更大的数组。

### 元组

跟数组类似，元组（Tuple）也是一系列 _ASON_ 值的集合，不同的是，元组并不要求其中的元素的数据类型必须相同。例如：

`(1, "foo", true)`

另外，元组使用一对圆括号，即 `(...)` 将元素括起来，而数组使用的是一对中括号，即 `[...]`。

> 在作用上，_ASON_ 的元组跟 _JSON_ 的列表（List）相似。

### 对象

对象是由一个或多个 “名称-值” 对组成的集合。例如：

```json
{
    name: "regex"
    version: "1.10.4"
    size: 247
}
```

其中的名称由字符 `[0-9a-zA-Z_]`，`\u{a0}...\u{d7ff}`，以及 `\u{e000}...\u{10ffff}` 组成，名称不需要双引号括起来。而值可以是任意的 _ASON_ 值。

> "名称-值" 对有时也叫做 "字段（Field）"

#### 嵌套

"名称-值" 对的值可以是任意 _ASON_ 值，当然也包括诸如数组、元组、对象等值，所以对象的嵌套是很常见的，比如：

```json
{
    name: "ason"
    version: "0.1.7"
    dependencies: [
        {
            name: "chrono"
            version: "^0.4.35"
        }
        {
            name: "hexfloat2"
            version: "^0.1.3"
        }
    ]
    tags: ["parser", "serde"]
}
```

### 变体

变体（`Variant`）是一种将不同类型的数据包裹（wrap）起来的特殊数据类型，其作用跟 Rust 语言的 `enum` 相似。

变体的格式是 `name::category(value)`，其中：

- `name` 是由字符 `[0-9a-zA-Z_]` 组成，它是变体的名称。只要变体的名称相同，则 _ASON_ 会认为是相同的数据类型。
- `category` 也是由字符 `[0-9a-zA-Z_]` 组成，它表示该变体下面的各个分类。
- `(value)` 是一对被括号括起来的任意 _ASON_ 值，这部分是可以省略的。

下面是变体 `Shape` 的示例：

- `Shape::Circle(2)`
- `Shape::Square(4)`
- `Shape::Rectangle((6,8))`

注意上面的 `((6,8))` 不是书写错误，因为 `(6,8)` 是一个元组，而外面的一对括号是变体的固有格式。它表达的意思相当于 `Shape::Rectangle({width: 6, height: 8})`。

变体当中成员不一定都有 `(value)`，比如下面这个变体 `Color`：

- `Color::Red`
- `Color::Blue`
- `Color::RGB((128,0,250))`

其中 `Red` 和 `Blue` 它们没有额外的值，因为它们本身就是变体 `Color` 的一个分类。

#### 使用变体代替 `null`

在编程时，`null` 是一个既方便又让人烦恼的值，它会带来潜在的错误以及大量的防卫性判断语句。_ASON_ 直接不支持 `null`，取而代之的是变体 `Option`，比如需要表达一个可能不存在的整数时，可以这样写：

- `Option::None`
- `Option::Some(123)`

#### 对象字段的缺省值

在书写 ASON 文档时，如果对象的某个字段的值为变体 `Option::None`，则该字段可以不书写，比如：

```json
{
    name: "ason"
    version: Option::None
}
```

可以写为：

```json
{
    name: "ason"
}
```

### 注释

_ASON_ 支持 3 种格式的注释：行注释，块注释以及文档注释。

_ASON_ 文档里的注释仅供人类阅读，对于 _ASON_ 解析器来说，注释会完全被忽略。

#### 行注释

行注释由标记 `//` 开始，直至行的末尾，比如：

```json
{
    // this is a line comment
    id: 123   // this is a line comment also
}
```

#### 块注释

块注释由标记 `/*` 开始，直至标记 `*/` 为止，比如：

```json
{
    /* this is a block comment */
    id: 123

    /*
     this is a block comment also
     */
    name: /* block comment can be everywhere */ "ason"
}
```

块注释支持嵌套，比如：

```json
{
    /*
     level one /* level two */ level one again
     */
    id: 123
}
```

> 在嵌套的块注释里，开始标记和结束标记必须成对出现。

#### 文档注释

文档注释（_Document Comment_）用于书写长篇的文本。文档注释以独占一行的 `"""` 标记开始，再以独占一行的 `"""` 标记结束，比如：

```json
{
    """
    This is a document comment.
    It can be very long.
    You can even write Markdown formatted text here.
    Until there are three consecutive double quotes on a single line.
    """
    id: 123
}
```

> 注意虽然开始标记和结束标记必须独占一行，但标记的前导空白是允许的。

#### 混合注释

行注释、块注释、文档注释可以混合使用，但要注意在一个注释里的 **其它注释标记** 只会被当作普通的文本，而不会解析成另一个注释，比如：

```json
{
    // this is a line comment, /* this is still a line comment. */
    id: 123
}
```

```json
{
    /* this is a block comment, // this is still a block comment. */
    id: 123
}


```

```json
{
    """
    this is a document comment,
    // this is still a document comment.
    /* this is still a document comment. */
    """
    id: 123
}

```

在上面的 3 个示例中，都只有一个注释。
