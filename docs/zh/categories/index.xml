
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
 <channel>
   <title>Categories on 河马蜀黍真是的</title>
   <link>https://hemashushu.github.io/zh/categories/</link>
   <description>Recent content in Categories on 河马蜀黍真是的</description>
   <generator>Hugo -- gohugo.io</generator>
   <language>en-us</language>
   <copyright>Copyright &amp;copy; 2022 - Hippospark</copyright>
   <lastBuildDate>Sat, 05 Nov 2022 00:00:00 +0000</lastBuildDate>
   
       <atom:link href="https://hemashushu.github.io/zh/categories/index.xml" rel="self" type="application/rss+xml" />
   
   
     <item>
       <title>S01C01 什么是交叉编译？GCC 交叉编译及运行第一个程序</title>
       <link>https://hemashushu.github.io/zh/posts/2022-11-05-s01c01-cross-compile-and-run-the-first-program/</link>
       <pubDate>Sat, 05 Nov 2022 00:00:00 +0000</pubDate>
       
       <guid>https://hemashushu.github.io/zh/posts/2022-11-05-s01c01-cross-compile-and-run-the-first-program/</guid>
       <description>&lt;p&gt;这是 &lt;a href=&#34;../2022-10-31-building-a-modern-computer-system-from-scratch-step-by-step&#34;&gt;《从零开始使用自己的工具一步一步构建现代计算机系统》&lt;/a&gt; 系列的第一个系列 ———— 《一步一步深入了解 RISC-V 系统》。&lt;/p&gt;&lt;p&gt;这个系列的目标是实现一个 RISC-V 汇编器和链接器，以及一门有特色的汇编语言和链接脚本语言。有了汇编器和链接器，我们就有能力生成程序（二进制可执行文件）了，这是我们制作自己的工具的基础。&lt;/p&gt;&lt;p&gt;在实现这个目标之前我们有必要先了解一些现有的、被广泛使用的基本工具（主要是编译和调试工具），然后我们还要了解现有的系统的基本原理，比如程序是如何组成的、程序是如何运行的、软件和硬件之间是如何交互的，以及汇编语言是怎样被转换为指令的等，然后才开始设计和编写程序。编程语言主要使用 &lt;a href=&#34;https://www.rust-lang.org/&#34;&gt;Rust&lt;/a&gt;，它很适合底层程序的开发，能让我们避免很多低级错误，同时像很多现代语言一样拥有很多方便的工具；&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;很多跟编译器和内核开发相关的文章、教程和项目都选择 C 语言作为编程语言，这是因为在几年之前用 C 语言的确是最合适的。不过现在有了更好的选择，所以这个系列我会用 Rust 来写汇编器和脚本解析器，这并不是为了追赶时髦，而是为了让我们避免一些不必要的挫折。当然在前面讲述基本原理的章节里，还是会用到 C 语言，毕竟它非常直接明了，能够很好地跟汇编对应上。顺带一提，很多人认为 Rust 是 C++ 的替代品，实际上并不是，从应用场景来看，它更偏向 C 语言这一类。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;你可能会问：“第一个系列一点儿都不酷啊，我们能否先跳过，直接开始动手写一门语言，或者写一个操作系统，或者写一个 CPU？” 虽然我能理解这种急切的心情，不过答案是否定的。正如 &lt;a href=&#34;../2022-10-31-building-a-modern-computer-system-from-scratch-step-by-step&#34;&gt;上一篇&lt;/a&gt; 讲过的，计算机系统技术的知识面很广而且相互交叉，如果你从一个比较高的起点开始实践，肯定会&lt;strong&gt;同时遇到很多新的概念&lt;/strong&gt;，当你试图弄懂其中的一个概念时，又会引出更多的新概念。这就像你浏览维基百科的情景一样，往往在阅读某个词条的某个段落时，会发现某个你不懂的名词，在浏览器新标签页打开链接之后，结果又遇到新名词。用不了多久你就会在不知不觉中打开了几十个甚至上百个标签页，直到电脑的内存被耗光为止。&lt;/p&gt;&lt;p&gt;一个新手在实现一门语言或者一个操作系统或者处理器时，可能会遇到几十个或上百个新的 &lt;em&gt;知识点&lt;/em&gt;，由此形成上万条不同的探索路径，不过所有路径大概率最终都会来到当前这个位置（即本系列要讲述的内容）。所以我们不妨从简单的开始，这样能避免很多不必要的弯路。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;在 &lt;em&gt;John R. Levine&lt;/em&gt; 的《Linkers &amp;amp; Loaders》第一章里提到：“大概一个房间就能装得下世上所有编写链接器的人” （原文：&lt;em&gt;allthe linker writers in the world could probably fit in one room&lt;/em&gt;）。看来我们学完这个系列之后可以挤满这个小房间了。&lt;/p&gt;&lt;/blockquote&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&#34;#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91&#34;&gt;什么是交叉编译？&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#gcc-%E7%BC%96%E8%AF%91%E5%99%A8&#34;&gt;GCC 编译器&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F&#34;&gt;交叉编译第一个程序&lt;/a&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&#34;#%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91&#34;&gt;交叉编译&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6&#34;&gt;二进制可执行文件&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#%E8%BF%90%E8%A1%8C&#34;&gt;运行&lt;/a&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&#34;#%E5%AE%89%E8%A3%85-qemu&#34;&gt;安装 QEMU&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#%E5%B0%9D%E8%AF%95%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F&#34;&gt;尝试运行程序&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#%E6%8C%87%E5%AE%9A-_qemu-%E7%94%A8%E6%88%B7%E6%A8%A1%E5%BC%8F_-%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%99%A8&#34;&gt;指定 &lt;em&gt;QEMU 用户模式&lt;/em&gt; 的程序动态链接器&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#%E7%BC%96%E8%AF%91%E4%B8%BA%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%A8%8B%E5%BA%8F&#34;&gt;编译为静态链接类型的程序&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#%E6%8C%87%E5%AE%9A%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%99%A8&#34;&gt;指定程序的动态链接器&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#%E5%88%86%E9%98%B6%E6%AE%B5%E7%BC%96%E8%AF%91&#34;&gt;分阶段编译&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#%E5%B8%B8%E7%94%A8%E7%9A%84%E7%BC%96%E8%AF%91%E5%8F%82%E6%95%B0&#34;&gt;常用的编译参数&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#%E6%80%BB%E7%BB%93&#34;&gt;总结&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;!-- raw HTML omitted --&gt;&lt;h2 id=&#34;什么是交叉编译&#34;&gt;什么是交叉编译？&lt;/h2&gt;&lt;p&gt;在一台电脑里编译生成在手机应用程序，这种编译是 &lt;em&gt;交叉编译&lt;/em&gt;；在 Linux 系统里编译生成同架构版本的 Windows 应用程序，这种编译也是交叉编译；当然，在 &lt;em&gt;x86_64&lt;/em&gt; 架构版本 Linux 系统里编译生成 &lt;em&gt;RISC-V&lt;/em&gt; 架构版本 Linux 应用程序这种也是交叉编译。&lt;/p&gt;&lt;p&gt;简单来说，只要是编译生成 &lt;em&gt;运行的环境&lt;/em&gt; 跟 &lt;em&gt;当前编译器所运行的环境&lt;/em&gt; 不一样的程序的编译过程就叫做 &lt;em&gt;交叉编译&lt;/em&gt;。目标运行环境包括 &lt;em&gt;目标架构&lt;/em&gt; 和 &lt;em&gt;目标平台&lt;/em&gt; 两个元素：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;em&gt;目标架构&lt;/em&gt; 是指目标机器的 CPU 指令集架构（ISA，有时简称为 &lt;em&gt;指令集&lt;/em&gt;），比如常用的 Intel 和 AMD CPU 的指令集是 &lt;em&gt;x86_64&lt;/em&gt;，现在流行的手机用的 ARM CPU 指令集是 &lt;em&gt;aarch64&lt;/em&gt;。&lt;/li&gt;&lt;li&gt;&lt;em&gt;目标平台&lt;/em&gt; 是指目标机器运行的操作系统类型，比如 &lt;em&gt;linux&lt;/em&gt;, &lt;em&gt;windows&lt;/em&gt; 以及 &lt;em&gt;darwin&lt;/em&gt; 等。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;在开发程序时，可能还得考虑目标环境更细致的一些信息，比如当你在开发 Linux 应用程序时，还得考虑不同发行版之间的细微差别。但对于编译器来说，它只需确定目标架构和目标平台即可。另外还有一些不需要操作系统而能够自己独立运行的程序，这种程序叫做 &lt;em&gt;freestanding 程序&lt;/em&gt; 或者 &lt;em&gt;裸机（bare metal）程序&lt;/em&gt;，比如在微控制器（MCU）里运行的程序（通常也叫固件）和内核程序，在编译这种程序则只需指定 &lt;em&gt;目标架构&lt;/em&gt; 即可。&lt;/p&gt;&lt;p&gt;交叉编译主要有两个用途：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;一是为了方便生成不同目标环境的程序文件（二进制可执行文件），假如我们开发了一个可以在多个平台上运行的应用程序，通过交叉编译，每次更新时只需在开发机器上跑几次编译过程就可以生成所需的程序文件，如果没有交叉编译，则需要将源代码复制到每一个目标环境然后再编译；&lt;/li&gt;&lt;li&gt;其次，也是最重要的原因，有些目标环境根本无法运行编译器，比如在微控制器里，往往只有几十 KB 的 RAM 和几百 KB 的 FLASH（相当于固态硬盘），只能运行一些很小的程序，这种情况下只能借助交叉编译来生成程序。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;顺便一提，我们将要实现的编译器的目标架构是 &lt;em&gt;riscv64gc&lt;/em&gt;，也是一个交叉编译器。下面先学习一下目前主流的交叉编译器。&lt;/p&gt;&lt;h2 id=&#34;gcc-编译器&#34;&gt;GCC 编译器&lt;/h2&gt;&lt;p&gt;主流的编译器一般都有交叉编译功能，比如 GCC 和 LLVM。因为在后面讲述软硬件交互原理的章节里需要用到微控制器（MCU），而在微控制器领域里 GCC 更常用一些，所以为了简单起见，下面只讲 GCC 编译器。&lt;/p&gt;&lt;p&gt;在开发程序时，除了编译器还会经常用到二进制工具 &lt;em&gt;Binutils&lt;/em&gt;、调试工具 &lt;em&gt;GDB&lt;/em&gt; 以及标准库和内核头文件等，这一套被称为 &lt;em&gt;GNU Toolchain&lt;/em&gt;。在大部分 Linux 发行版里都可以通过包管理器轻松安装 GNU Toolchain。根据编译目标的不同，工具链的软件包的名字也会不同，比如 &lt;a href=&#34;https://github.com/riscv-collab/riscv-gnu-toolchain&#34;&gt;RISC-V GNU Toolchain&lt;/a&gt;，它们的包名（在 &lt;em&gt;Arch Linux&lt;/em&gt; 里）分别是：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;riscv64-linux-gnu-binutils&lt;/li&gt;&lt;li&gt;riscv64-linux-gnu-gcc&lt;/li&gt;&lt;li&gt;riscv64-linux-gnu-gdb&lt;/li&gt;&lt;li&gt;riscv64-linux-gnu-glibc&lt;/li&gt;&lt;li&gt;riscv64-linux-gnu-linux-api-headers&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;另外编译目标为 RISC-V 裸机程序的包有：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;riscv64-elf-binutils&lt;/li&gt;&lt;li&gt;riscv64-elf-gcc&lt;/li&gt;&lt;li&gt;riscv64-elf-gdb&lt;/li&gt;&lt;li&gt;riscv64-elf-newlib&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;在不同的 Linux 发行版里包的名字会有所不同，比如在 &lt;em&gt;Ubuntu&lt;/em&gt; 里包名分别是 &lt;code&gt;binutils-riscv64-linux-gnu&lt;/code&gt;，&lt;code&gt;gcc-riscv64-linux-gnu&lt;/code&gt;，&lt;code&gt;binutils-riscv64-unknown-elf&lt;/code&gt;，&lt;code&gt;gcc-riscv64-unknown-elf&lt;/code&gt;，&lt;code&gt;gdb-multiarch&lt;/code&gt;。如果你系统的包仓库里没有 RISC-V GNU Toolchain，则可以 &lt;a href=&#34;https://github.com/riscv-collab/riscv-gnu-toolchain&#34;&gt;下载源代码&lt;/a&gt; 然后通过源代码的方式安装。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;如果没有另外的说明，整个系列文章的操作都是在 Linux 系统环境里完成的，当然你也可以在自己平常使用的系统上操作，不过如果你决心要深入学习系统技术的话，建议还是使用 Linux 系统环境，除了比较方便之外，更重要的是 Linux 系统（特别是内核）就像一个开放的图书馆，里面充满了宝藏，放着宝藏不要那实在太浪费了。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&#34;交叉编译第一个程序&#34;&gt;交叉编译第一个程序&lt;/h2&gt;&lt;p&gt;&amp;ldquo;Hello World!&amp;rdquo; 程序就像编程世界里的史莱姆一般的存在，作为交叉编译的第一个实践对象当然不会放过它。&lt;/p&gt;&lt;p&gt;在任意位置新建一个名为 &lt;code&gt;hello-world&lt;/code&gt; 的目录，然后创建名为 &lt;code&gt;app.c&lt;/code&gt; 的文件，内容如下：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Hello World!&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;程序的功能非常简单：向屏幕打印一行文字 &amp;ldquo;Hello World!&amp;quot;，然后结束程序，程序的返回值为 &lt;code&gt;0&lt;/code&gt;。所谓 &lt;em&gt;返回值&lt;/em&gt; 即 &lt;em&gt;exit code&lt;/em&gt;，是一个 &lt;code&gt;uint32&lt;/code&gt; 数字，需注意的是在 POSIX 环境里 &lt;em&gt;返回值&lt;/em&gt; 只有其二进制的最小 8 位是有效的，因此有效值的范围是从 0 到 255。可以通过命令 &lt;code&gt;$ echo $?&lt;/code&gt; 显示上一个结束的程序的返回值。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;每篇文章里面的源代码我都会存放一份在文章目录里面一个名为 &lt;code&gt;resources&lt;/code&gt; 的文件夹里，有需要的可以到 &lt;a href=&#34;https://github.com/hemashushu/hemashushu.github.io/tree/main/src/content/posts&#34;&gt;文章的 Github 源代码仓库&lt;/a&gt; 下载。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 id=&#34;交叉编译&#34;&gt;交叉编译&lt;/h3&gt;&lt;p&gt;普通编译（即 &lt;em&gt;本地编译&lt;/em&gt;）的编译、汇编、链接的命令分别是 &lt;code&gt;gcc&lt;/code&gt;，&lt;code&gt;as&lt;/code&gt; 和 &lt;code&gt;ld&lt;/code&gt;，而在交叉编译时对应的命令的名称会多一个前缀。在当前的例子里，前缀是 &lt;code&gt;riscv64-linux-gnu-&lt;/code&gt;，所以交叉编译的命令如下：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ riscv64-linux-gnu-gcc -g -Wall -o app.out app.c&lt;/code&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;参数 &lt;code&gt;-g&lt;/code&gt; 用于生成供 GDB 使用的调试信息，调试信息包括源代码当中的局部变量名称，指令对应的源代码的行数等。虽然暂时用不上调试信息，不过在平时编译时都加上可以培养良好的习惯；&lt;/li&gt;&lt;li&gt;参数 &lt;code&gt;-Wall&lt;/code&gt; 用于报告编译过程中的所有警告和错误信息，比如声明了局部变量却没使用，或者某个变量只赋值却从未被读取等，这些警告信息有助于书写良好的代码；&lt;/li&gt;&lt;li&gt;参数 &lt;code&gt;-o app.out&lt;/code&gt; 用于指定输出的文件的名称，如果缺省这个参数，默认的输出文件名为 &lt;code&gt;a.out&lt;/code&gt;。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;编译完成后得到文件 &lt;code&gt;app.out&lt;/code&gt;。&lt;/p&gt;&lt;h3 id=&#34;二进制可执行文件&#34;&gt;二进制可执行文件&lt;/h3&gt;&lt;p&gt;使用 &lt;code&gt;file&lt;/code&gt; 命令可以查看输出文件 &lt;code&gt;app.out&lt;/code&gt; 的格式信息，例如：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ file app.out&lt;/code&gt;&lt;/p&gt;&lt;p&gt;输出结果如下：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;app.out: ELF 64-bit LSB pie executable, UCB RISC-V, RVC, double-float ABI, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux-riscv64-lp64d.so.1, BuildID[sha1]=afe0994d7df77dc817058ae17e814d8f0a4163ed, for GNU/Linux 4.15.0, with debug_info, not stripped&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上面的一段文本包含的信息有：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;ELF&lt;/code&gt; 和 &lt;code&gt;executable&lt;/code&gt;，表明当前文件是一个 &lt;em&gt;ELF 文件格式&lt;/em&gt; 当中的 &lt;em&gt;可执行文件&lt;/em&gt;。ELF 格式有 3 种类型：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;code&gt;executable&lt;/code&gt; 是 &lt;em&gt;可执行文件&lt;/em&gt;，这是最常见的一种类型。Linux 系统里的可执行文件除了脚本就是这种二进制的可执行文件；&lt;/li&gt;&lt;li&gt;&lt;code&gt;shared object&lt;/code&gt; 是 &lt;em&gt;共享对象文件&lt;/em&gt;，也就是共享库，用于在运行时动态地链接到程序。目录 &lt;code&gt;/usr/lib&lt;/code&gt; 里面那一堆 &amp;ldquo;*.so&amp;rdquo; 文件就是这种类型。&lt;/li&gt;&lt;li&gt;&lt;code&gt;relocatable&lt;/code&gt; 是 &lt;em&gt;可重定位文件&lt;/em&gt;，即编译任务中途产生的文件。上面的编译命令在背后大致做了两件事：将 C 源代码转换为一系列机器指令并保存在 &lt;em&gt;可重定位文件&lt;/em&gt; 里，这个过程称为 &lt;em&gt;编译&lt;/em&gt;；另一件事是把一个或多个 &lt;em&gt;可重定位文件&lt;/em&gt; 连接成为一个可执行文件或者共享库，这个过程称为 &lt;em&gt;链接&lt;/em&gt;。&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;dynamically linked&lt;/code&gt;, &lt;code&gt;interpreter ...&lt;/code&gt;，表明当前可执行文件是 &lt;em&gt;动态链接&lt;/em&gt; 类型，也就是说它在运行时，要需要其它共享库的帮忙才能完成工作。而这些库的加载和初始化任务则由 &lt;code&gt;interpreter&lt;/code&gt; 指定的程序来完成，这个程序也叫 &lt;em&gt;运行时动态链接器&lt;/em&gt;，这个程序通常是 &lt;code&gt;/usr/bin/ld.so&lt;/code&gt;（虽然扩展名是 &lt;code&gt;so&lt;/code&gt;，不过它是可执行的）。可执行文件还可以是 &lt;em&gt;静态链接（statically linked）&lt;/em&gt; 类型，表示它在运行时不需要其它共享库帮忙，它自己就能完成所有工作。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;pie&lt;/code&gt;，表明当前的可执行文件是 &lt;code&gt;位置无关的可执行文件&lt;/code&gt;（&lt;code&gt;Position Independent Executables&lt;/code&gt;），这部分内容将会在后面的章节里讲解。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;64-bit&lt;/code&gt;, &lt;code&gt;RISC-V&lt;/code&gt;, &lt;code&gt;double-float ABI&lt;/code&gt;，&lt;code&gt;GNU/Linux 4.15.0&lt;/code&gt;，这些信息表明当前可执行文件的目标架构、目标平台以及目标平台的一些细致信息，这些内容也会在后面的章节里讲解。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;LSB&lt;/code&gt;，表明当前文件里的数据是 &amp;ldquo;低端字节优先&amp;rdquo;（&amp;ldquo;least-significant byte first&amp;rdquo;）的，也就是平常说的 &amp;ldquo;低端序&amp;rdquo;（&amp;ldquo;little-endian&amp;rdquo;）。跟 &lt;code&gt;LSB&lt;/code&gt; 相反的是 &lt;code&gt;MSB&lt;/code&gt;，即 &amp;ldquo;高端字节优先&amp;rdquo;（&amp;ldquo;most-significant byte&amp;rdquo;），也就是平常说的 &amp;ldquo;高端序&amp;rdquo;（&amp;ldquo;big-endian&amp;rdquo;）。字节顺序决定了一个整数在内存或者磁盘中如何储存，比如数字 &lt;code&gt;0x11223344&lt;/code&gt;，在内存中如果使用 &lt;code&gt;LSB&lt;/code&gt; 则被储存为 &amp;ldquo;(这端是低位地址) 44 33 22 11 （这端是高位地址）&amp;quot;，如果使用 &lt;code&gt;MSB&lt;/code&gt;，则会被储存为 &amp;ldquo;(这端是低位地址) 11 22 33 44（这端是高位地址）&amp;quot;。用十六进制查看器查看 &lt;code&gt;LSB&lt;/code&gt; 类型的可执行文件的内容时，如果看的内容是数字，那么需要在脑海里把数字反过来再组合才是它的真实值，而如果看的内容是字符串，则可以按顺序地阅读。简单来说，看数字需要反转一次，而文本内容（仅限 ASCII 文本）则可以直接阅读，而 &lt;code&gt;MSB&lt;/code&gt; 则刚好相反。不过这都是人类才有的烦恼，对于计算机来说都是一样的。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;with debug_info&lt;/code&gt;, &lt;code&gt;not stripped&lt;/code&gt;，表明当前可执行文件里包含调试信息。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;code&gt;file&lt;/code&gt; 命令只能非常粗略地查看文件的格式和基本信息，如果想查看可执行文件的详细内容，需要 GNU Toolchain 里面一组叫做 &lt;a href=&#34;https://www.gnu.org/software/binutils/&#34;&gt;GNU Binutils&lt;/a&gt; 的工具，后面的章节会详细讲解。&lt;/p&gt;&lt;h2 id=&#34;运行&#34;&gt;运行&lt;/h2&gt;&lt;p&gt;如果你尝试运行上面编译得到的 &lt;code&gt;app.out&lt;/code&gt; 会发现没法正确运行，这是因为该可执行文件是设计在 RISC-V 架构版本的 Linux 系统环境里运行的，可惜目前 RISC-V 架构的计算机还非常少，而且价格也贵，所以比较实际的方案是使用虚拟机来运行。&lt;/p&gt;&lt;p&gt;一般大家熟知的虚拟机软件，比如 VirtualBox、VMWare 等只能虚拟一台架构跟主机（host machine）一样的机器，如果需要模拟其它架构类型的机器，推荐使用 &lt;a href=&#34;https://www.qemu.org/&#34;&gt;QEMU&lt;/a&gt; 模拟器。&lt;/p&gt;&lt;h3 id=&#34;安装-qemu&#34;&gt;安装 QEMU&lt;/h3&gt;&lt;p&gt;QEMU 也是一款开源免费的软件，在大部分 Linux 发行版里的包仓库里都包含有 QEMU，所以只需使用系统的包管理器就可以安装 QEMU，通常需要安装下面这些包（针对 &lt;em&gt;Arch Linux&lt;/em&gt; 发行版）：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;qemu-system-riscv&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;qemu-user&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;qemu-user-static&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;在不同的发行版里，包的名字会有些许不同，比如在 &lt;em&gt;Ubuntu&lt;/em&gt; 里，包名分别为 &lt;code&gt;qemu-system&lt;/code&gt;，&lt;code&gt;qemu-user&lt;/code&gt; 和 &lt;code&gt;qemu-user-static&lt;/code&gt;）。对于包仓库里没有 QEMU 的发行版，可以下载 QEMU 的源代码，然后根据&lt;a href=&#34;https://wiki.qemu.org/Documentation/Platforms/RISCV&#34;&gt;这篇指引&lt;/a&gt;编译安装。&lt;/p&gt;&lt;p&gt;QEMU 可以模拟一整套完整的硬件，包括 CPU、内存、磁盘、网络接口、USB 接口等组件，除此之外，QEMU 还可以模拟一个 Linux 系统。也就是说，QEMU 有两种工作模式，前者称为 &lt;em&gt;全系统模式&lt;/em&gt;，在这种模式下可以执行所有 CPU 指令，可以运行裸机程序。后者称为 &lt;em&gt;用户模式&lt;/em&gt;，可以直接运行编译目标架构不同的 Linux 应用程序。&lt;/p&gt;&lt;p&gt;全系统模式使用程序 &lt;code&gt;qemu-system-riscv64&lt;/code&gt; 来启动，可以通过参数指定机器类型、CPU 核心的数量、内存的容量、虚拟磁盘等。用户模式使用程序 &lt;code&gt;qemu-riscv64&lt;/code&gt; 来启动，把我们写的应用程序（可执行文件）的文件路径作为参数传给 &lt;code&gt;qemu-riscv64&lt;/code&gt; 即可，在这种模式下，QEMU 会把应用程序当中的指令转换为主机架构的指令，同时会转换程序当中的系统调用。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;QEMU 出自一位颇具传奇色彩的程序员 &lt;a href=&#34;https://bellard.org/&#34;&gt;Fabrice Bellard&lt;/a&gt; 之手，他写的 &lt;a href=&#34;http://ffmpeg.org/&#34;&gt;FFmpeg&lt;/a&gt; 几乎存在每一台计算机里（尽管可能很多人都不知道，但却是真的），大部分媒体播放器软件及视频编辑软件都依赖它，另外还写了 TCC、QuickJS 等程序。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 id=&#34;尝试运行程序&#34;&gt;尝试运行程序&lt;/h3&gt;&lt;p&gt;如果使用全系统模式运行我们的程序，还需要给虚拟机配置系统引导器、一个包含有 RISC-V 架构版本的 Linux 系统的虚拟磁盘，另外还需要把应用程序传送进去等。所以为了快速把上面写的 &amp;ldquo;Hello World!&amp;rdquo; 程序跑起来，下面使用用户模式来运行：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ qemu-riscv64 app.out&lt;/code&gt;&lt;/p&gt;&lt;p&gt;运行的结果是：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;qemu-riscv64: Could not open &amp;#39;/lib/ld-linux-riscv64-lp64d.so.1&amp;#39;: No such file or directory&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;显然程序并没有正确地运行。GCC 默认产生动态链接类型的程序，这种程序在运行时需要一个 &lt;em&gt;运行时动态链接器&lt;/em&gt; 加载程序所需的共享库，以及进行一系列的初始化工作（动态链接器即 &lt;code&gt;ld.so&lt;/code&gt;，在当前的例子里，它是错误信息里显示的那个 &lt;code&gt;/lib/ld-linux-riscv64-lp64d.so.1&lt;/code&gt;）。然而 GCC 默认产生的程序是假定在 &amp;ldquo;普通 Linux 环境&amp;rdquo; 里运行，而不是 &lt;em&gt;QEMU 用户模式&lt;/em&gt; 这种特殊的环境。当前主机系统存在动态链接器 &lt;code&gt;/lib/ld-linux-x86-64.so.2&lt;/code&gt;，但不存在 &lt;code&gt;/lib/ld-linux-riscv64-lp64d.so.1&lt;/code&gt;，所以就出错了。&lt;/p&gt;&lt;h3 id=&#34;指定-_qemu-用户模式_-的程序动态链接器&#34;&gt;指定 &lt;em&gt;QEMU 用户模式&lt;/em&gt; 的程序动态链接器&lt;/h3&gt;&lt;p&gt;如果你的系统是 &lt;em&gt;Arch Linux&lt;/em&gt;，会发现文件 &lt;code&gt;ld-linux-riscv64-lp64d.so.1&lt;/code&gt; 的真正路径是 &lt;code&gt;/usr/riscv64-linux-gnu/lib/ld-linux-riscv64-lp64d.so.1&lt;/code&gt;，按照 &lt;code&gt;qemu-riscv64&lt;/code&gt; 的说明，通过参数 &lt;code&gt;-L&lt;/code&gt; 或者环境变量 &lt;code&gt;QEMU_LD_PREFIX&lt;/code&gt; 传入一个路径，QEMU 就会把这个路径作为前缀添加到 ELF 的 &lt;code&gt;interpreter&lt;/code&gt; 指定的程序的前面。例如：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;$ qemu-riscv64 -L /usr/riscv64-linux-gnu/ app.out&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;$ QEMU_LD_PREFIX=/usr/riscv64-linux-gnu/ qemu-riscv64 app.out&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;如无意外，上面两个命令都能正确运行，能看到程序输出的 &amp;ldquo;Hello World!&amp;rdquo; 文本。&lt;/p&gt;&lt;h3 id=&#34;编译为静态链接类型的程序&#34;&gt;编译为静态链接类型的程序&lt;/h3&gt;&lt;p&gt;除了通过指定 &lt;em&gt;QEMU 用户模式&lt;/em&gt; 的程序动态链接器来正确运行程序之外，还有另外一个方法，就是让 GCC 生成静态链接类型的可执行文件。&lt;/p&gt;&lt;p&gt;所谓静态链接程序，就是把外部函数的二进制代码（即指令序列）在编译时复制到目标可执行文件里，这样程序在运行时就不再需要动态链接其它共享库了，当然也就不再需要动态链接器 &lt;code&gt;ld.so&lt;/code&gt; 了。在 GCC 编译命令里添加 &lt;code&gt;-static&lt;/code&gt; 参数可指示 GCC 生成静态链接的程序，修改后的编译命令如下：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ riscv64-linux-gnu-gcc -static -o app-static.out app.c&lt;/code&gt;&lt;/p&gt;&lt;p&gt;先看看文件格式：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ file app-static.out&lt;/code&gt;&lt;/p&gt;&lt;p&gt;输出的部分结果如下：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;app-static.out: ... statically linked ...&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可见原先的 &amp;ldquo;dynamically linked&amp;rdquo; 已经变为 &amp;ldquo;statically linked&amp;rdquo;。&lt;/p&gt;&lt;p&gt;然后用 &lt;code&gt;qemu-riscv64&lt;/code&gt; 运行这个静态链接的可执行文件：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ qemu-riscv64 app-static.out&lt;/code&gt;&lt;/p&gt;&lt;p&gt;同样可以得到了预期的结果：程序输出一行 &amp;ldquo;Hello World!&amp;rdquo; 文本。&lt;/p&gt;&lt;p&gt;然后看看同一个程序的动态链接类型和静态链接类型的文件大小：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ ls -lh&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;total 668K&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-rw-r--r-- 1 yang yang   78 Nov 26 04:00 app.c&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-rwxr-xr-x 1 yang yang 9.8K Nov 27 13:38 app.out&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-rwxr-xr-x 1 yang yang 645K Nov 27 21:40 app-static.out&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;结果显示动态类型的程序大小是 &lt;code&gt;9.8K&lt;/code&gt;，而静态类型的程序是 &lt;code&gt;645K&lt;/code&gt;，后者比前者大了许多，那是因为编译器把 &lt;code&gt;printf&lt;/code&gt; 函数所需要的函数的代码（即二进制指令）都复制到目标可执行文件里头了。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;em&gt;动态链接&lt;/em&gt; 对系统来说是个不错的机制，因为可以减小程序的容量、节约存储空间、提高传输速度，再加上内存映射技术，同一个共享库在内存里可以重用，因此在运行时也节约了物理内存空间。但动态链接带来的问题也相当令人头痛。在日常使用 Linux 经验里，很少有程序能下载即能运行，大部分情况都会出现共享库找不到或者版本不匹配等错误。如果要安装一个在包仓库里不存在的程序，则只能通过编译源代码的方式来安装了，这种方式对于普通用户（非专业用户）来说无疑难如登天。虽然可以通过诸如 &lt;a href=&#34;https://aur.archlinux.org/&#34;&gt;AUR&lt;/a&gt; 和 &lt;a href=&#34;https://launchpad.net/ubuntu/+ppas&#34;&gt;PPA&lt;/a&gt; 等个人库来缓解问题，却不总是有效的。&lt;/p&gt;&lt;p&gt;河马蜀黍认为上面的问题是因为过度使用共享库引起的，把每一个库都放进系统全局库里并不是一个好主意。因此在我们要实现的操作系统里，将完全禁止用户向系统添加全局的共享库，全局共享库仅限非常通用且有必要的库，而且跟内核和驱动一样，全局共享库应该由内核仓库维护。而且应用程序也应该相互隔离，即一个程序自带的共享库只能由程序自己或者子程序使用，而不能提供给其它程序使用。以此机制从根本上解决共享库带来的问题，减少应用程序的发行和安装的负担。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 id=&#34;指定程序的动态链接器&#34;&gt;指定程序的动态链接器&lt;/h3&gt;&lt;p&gt;除了上面的两种方法，还能通过修改程序的动态链接器来让程序运行起来。具体来说就是在编译时传入链接参数 &lt;code&gt;--dynamic-linker&lt;/code&gt; 以更改程序的 &lt;code&gt;interpreter&lt;/code&gt; 值，命令如下：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ riscv64-linux-gnu-gcc -g -Wall -Wl,--dynamic-linker,/usr/riscv64-linux-gnu/lib/ld-linux-riscv64-lp64d.so.1 -o app-mod.out app.c -L /usr/riscv64-linux-gnu/lib -lc&lt;/code&gt;&lt;/p&gt;&lt;p&gt;命令当中的参数 &lt;code&gt;-Wl,--dynamic-linker,...&lt;/code&gt; 的作用是向链接器传递参数；参数 &lt;code&gt;-L ...&lt;/code&gt; 用于指定链接器搜索共享库的路径；参数 &lt;code&gt;-lc&lt;/code&gt; 用于指定链接共享库 &lt;code&gt;libc.so&lt;/code&gt;。这些参数在后面的章节还会详细讲解。&lt;/p&gt;&lt;p&gt;编译完毕之后，可以使用 &lt;code&gt;file&lt;/code&gt; 命令检查程序：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ file app-mod.out&lt;/code&gt;&lt;/p&gt;&lt;p&gt;输出的部分结果如下：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;app-mod.out: ... interpreter /usr/riscv64-linux-gnu/lib/ld-linux-riscv64-lp64d.so.1 ...&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可见程序的 &lt;code&gt;interpreter&lt;/code&gt; 已经更改为指定的路径了。然而运行这程序时又有新的错误提示：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ qemu-riscv64 app-mod.out&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;app-mod.out: error while loading shared libraries: libc.so.6: cannot open shared object file: No such file or directory&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;看来 RISC-V 版的 &lt;code&gt;ld.so&lt;/code&gt; 已经起作用了，但这个动态链接器找不到 RISC-V 版的共享库 &lt;code&gt;libc.so.6&lt;/code&gt;。这个问题比较好解决，只要通过环境变量 &lt;code&gt;LD_LIBRARY_PATH&lt;/code&gt; 就可以指定程序所依赖的共享库的路径，例如：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ LD_LIBRARY_PATH=/usr/riscv64-linux-gnu/lib qemu-riscv64 app-mod.out&lt;/code&gt;&lt;/p&gt;&lt;p&gt;程序同样能正确运行。不过这种方法并没有太大用处，因为比前面两种方法复杂太多，而且生成的程序只适合在当前机器上 &lt;em&gt;QEMU 用户模式&lt;/em&gt; 里运行，没法在标准的 RISC-V Linux 环境里运行。所以这里主要是为了演示如何修改程序的 &lt;code&gt;interpreter&lt;/code&gt;。&lt;/p&gt;&lt;h2 id=&#34;分阶段编译&#34;&gt;分阶段编译&lt;/h2&gt;&lt;p&gt;当执行命令 &lt;code&gt;riscv64-linux-gnu-gcc&lt;/code&gt; 将一个 C 源代码编译为一个可执行文件时，实际上 GCC 是分 4 个阶段（或者说步骤）来完成的：&lt;/p&gt;&lt;p&gt;&lt;img src=&#34;images/gcc-compile-stage.png&#34; alt=&#34;GCC compile stages&#34;&gt;&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;p&gt;预处理&lt;/p&gt;&lt;p&gt;将源代码里 &lt;code&gt;#include ...&lt;/code&gt; 指定的文件复制进来，解析其中的条件编译指令（&lt;code&gt;#ifdef&lt;/code&gt;），展开宏（&lt;code&gt;macro&lt;/code&gt;）等。相当于命令：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ riscv64-linux-gnu-cpp app.c &amp;gt; app.i&lt;/code&gt;&lt;/p&gt;&lt;p&gt;或者&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ riscv64-linux-gnu-gcc -E app.c &amp;gt; app.i&lt;/code&gt;&lt;/p&gt;&lt;p&gt;经过预处理的 C 语言源代码文件的扩展名为 &lt;code&gt;*.i&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;注意程序 &lt;code&gt;riscv64-linux-gnu-cpp&lt;/code&gt; 当中的 &amp;ldquo;cpp&amp;rdquo; 是指 &amp;ldquo;C Preprocessor&amp;rdquo;，而不是 &amp;ldquo;C++&amp;rdquo; 的意思。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;编译&lt;/p&gt;&lt;p&gt;将 C 源代码编译为汇编源代码，相当于命令：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ riscv64-linux-gnu-gcc -S app.i&lt;/code&gt;&lt;/p&gt;&lt;p&gt;第 1 到第 2 步也可以一步完成：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ riscv64-linux-gnu-gcc -S app.c&lt;/code&gt;&lt;/p&gt;&lt;p&gt;生成的汇编源代码文件的扩展名为 &lt;code&gt;*.s&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;注意我们手写汇编源代码的文件扩展名一般是 &lt;code&gt;*.S&lt;/code&gt;（大写 &lt;code&gt;S&lt;/code&gt;），&lt;code&gt;*.S&lt;/code&gt; 文件在汇编时会进行预处理（比如处理 &lt;code&gt;.include&lt;/code&gt; 指令），而扩展名为 &lt;code&gt;*.s&lt;/code&gt;（小写 &lt;code&gt;s&lt;/code&gt;）则不会进行预处理。具体的扩展名和 GCC 参数可以参考&lt;a href=&#34;https://gcc.gnu.org/onlinedocs/gcc/Overall-Options.html&#34;&gt;GCC Options Controlling the Kind of Output&lt;/a&gt;。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;汇编&lt;/p&gt;&lt;p&gt;将汇编源代码转换为机器指令序列，生成 &lt;em&gt;可重定位文件&lt;/em&gt;，相当于命令：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ riscv64-linux-gnu-as -o app.o app.s&lt;/code&gt;&lt;/p&gt;&lt;p&gt;第 1 到第 3 步也可以一步完成：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ riscv64-linux-gnu-gcc -c -o app.o app.c&lt;/code&gt;&lt;/p&gt;&lt;p&gt;参数 &lt;code&gt;-c&lt;/code&gt; 表示只编译但不链接。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;链接&lt;/p&gt;&lt;p&gt;将一个或多个 &lt;em&gt;可重定位文件&lt;/em&gt; 连接起来，并重新定位其中的全局变量、静态变量和函数的地址，最后生成 ELF 格式的可执行文件，相当于命令：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ riscv64-linux-gnu-ld -o app.out startup.o app.o&lt;/code&gt;&lt;/p&gt;&lt;p&gt;上面的命令会将 &lt;code&gt;startup.o&lt;/code&gt; 和 &lt;code&gt;app.o&lt;/code&gt; 两个文件链接起来生成可执行文件 &lt;code&gt;app.out&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;注意上面的 &lt;code&gt;startup.o&lt;/code&gt; 是一个假象的应用程序启动器（提供应用的入口 &lt;code&gt;_start&lt;/code&gt; 过程以及做一些初始化和清理工作），在当前示例的源代码目录里并不存在。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;上面就是命令 &lt;code&gt;$ riscv64-linux-gnu-gcc -o app.out app.c&lt;/code&gt; 在背后进行的一系列操作，如果想知道 GCC 在编译过程中的每个步骤以及细节，可以传入 &lt;code&gt;-v&lt;/code&gt; 参数，比如 &lt;code&gt;$ riscv64-linux-gnu-gcc -v -o app.out app.c&lt;/code&gt;。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;在平常的编译程序任务中，我们并不需要分成 4 步，顶多也只会分成 &lt;em&gt;编译&lt;/em&gt; 和 &lt;em&gt;链接&lt;/em&gt; 2 步，而且一般都是借助诸如 &lt;code&gt;make&lt;/code&gt; 等构建工具来完成。但我们仍然需要清楚知道编译过程背后有哪些阶段及其作用，理解这些概念有助于解决在编译过程遇到的各种问题。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&#34;常用的编译参数&#34;&gt;常用的编译参数&lt;/h2&gt;&lt;p&gt;GCC 还有一些其它常用的参数：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;-I&lt;/code&gt; 用于指定编译时的头文件的路径&lt;/p&gt;&lt;p&gt;有时头文件（&lt;code&gt;*.h&lt;/code&gt;）分布在多个目录，这时可以用参数 &lt;code&gt;-I&lt;/code&gt; 把额外的头文件的路径包含进来，比如当前的路径为 &lt;code&gt;/home/yang/hello-world/app.c&lt;/code&gt;，假如有额外的头文件位于 &lt;code&gt;/home/yang/hello-world/include/&lt;/code&gt;，则可以这样传入参数：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ riscv64-linux-gnu-gcc -I /home/yang/hello-world/include app.c&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;-L&lt;/code&gt; 和 &lt;code&gt;-l&lt;/code&gt; 分别用于指定链接时额外库的路径和名称&lt;/p&gt;&lt;p&gt;接着上一个例子，如果应用程序需要使用到共享库 &lt;code&gt;/usr/lib/hello-world/libmymath.so&lt;/code&gt;，则可以这样传入参数：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ riscv64-linux-gnu-gcc app.c -L /usr/lib/hello-world/ -lmymath&lt;/code&gt;&lt;/p&gt;&lt;p&gt;参数 &lt;code&gt;-lmymath&lt;/code&gt; 的写法有点奇怪，其实它是 &lt;code&gt;-l mymath&lt;/code&gt; 的简写，即 &lt;code&gt;-l&lt;/code&gt; 是参数名称，&lt;code&gt;mymath&lt;/code&gt; 是参数值。这个参数表示链接过程会使用到共享库 &lt;code&gt;libmymath.so&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;注意参数 &lt;code&gt;-l&lt;/code&gt; 的值是库的 &amp;ldquo;soname&amp;rdquo;，比如上面例子中共享库文件的真实名称是 &lt;code&gt;libmymath.so&lt;/code&gt;，去除了前缀 &lt;code&gt;lib&lt;/code&gt; 和后缀 &lt;code&gt;.so&lt;/code&gt; 之后就是 &amp;ldquo;soname&amp;rdquo; 了。如此类推，&lt;code&gt;-lm&lt;/code&gt; 表示共享库 &lt;code&gt;libm.so&lt;/code&gt;，&lt;code&gt;-lpthread&lt;/code&gt; 表示共享库 &lt;code&gt;libpthread.so&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote&gt;&lt;p&gt;&lt;strong&gt;note&lt;/strong&gt; 一般习惯把参数 &lt;code&gt;-L ... -l ...&lt;/code&gt; 放在命令的末尾，也就是遵循 &amp;ldquo;被依赖的放在后面&amp;rdquo; 的顺序。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;如果将编译任务分为 &lt;em&gt;编译&lt;/em&gt; 和 &lt;em&gt;链接&lt;/em&gt; 两步，则在编译阶段只需指定 &lt;code&gt;-I&lt;/code&gt; 参数，而链接阶段只需指定 &lt;code&gt;-L&lt;/code&gt; 和 &lt;code&gt;-l&lt;/code&gt; 参数，因为头文件仅供预处理使用的，对链接无意义，而库文件则仅供链接使用，对编译无意义。&lt;/p&gt;&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;&lt;p&gt;这章主要讲解什么是交叉编译，交叉编译的作用，以及尝试交叉编译一个 &amp;ldquo;Hello World!&amp;rdquo; 程序，然后使用 QEMU 模拟一个不同架构的 Linux 环境来运行交叉编译得到的可执行文件。&lt;/p&gt;&lt;p&gt;这章是我们漫长的几个系列文章当中的第一个系列的第一章，如果你觉得这章的内容太难了，可能只是因为对 C 语言和 Linux 环境不是很熟悉，你可以适当停下来，然后随便找一些相关的文章或者教程看看。请记住计算机的每门科目都不需要一下子从头到尾看完，每次看一两章就可以停下来，然后去做点别的事情，让你的大脑在背后慢慢地消化，回来再看一下这系列文章，说不定一下子就全都看得懂了。&lt;/p&gt;&lt;p&gt;好了，如果觉得没问题那就点击下一章吧。下一章将会构建一个简单的无需操作系统就可以独自运行的程序。&lt;/p&gt;</description>
     </item>
   
     <item>
       <title>从零开始使用自己的工具一步一步构建现代计算机系统 - 简介</title>
       <link>https://hemashushu.github.io/zh/posts/2022-10-31-building-a-modern-computer-system-from-scratch-step-by-step/</link>
       <pubDate>Mon, 31 Oct 2022 14:34:52 +0800</pubDate>
       
       <guid>https://hemashushu.github.io/zh/posts/2022-10-31-building-a-modern-computer-system-from-scratch-step-by-step/</guid>
       <description>&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&lt;p&gt;RISC-V 是最近几年热门的计算机指令集，相信已经有不少朋友已经尝试过编译 RISC-V 版的 Linux 内核，或者跟着教程编写玩具操作系统、制作玩具编程语言，甚至还有用 HDL（硬件描述语言）编写自己的玩具 CPU。&lt;/p&gt;&lt;p&gt;无论是哪种，刚开始时你肯定既激动又兴奋，就像要在一个异世界开始一段新冒险的勇者那样。不过翻到教程的第二章，可能你就开始眉头紧锁，然后咬着牙又翻了几章，经过一番挣扎最后只能放弃。这时候你可能很疑惑：“明明写了几年的程序，各种算法题早已不放在眼里，为什么还是看不懂这些教程呢？！&amp;quot;&lt;/p&gt;&lt;p&gt;显然这是因为缺少对 &lt;em&gt;完整的系统技术&lt;/em&gt; 的了解（也就是 &lt;em&gt;计算机基础技术&lt;/em&gt;，有时也叫 &lt;em&gt;底层技术&lt;/em&gt; 或者 &lt;em&gt;核心技术&lt;/em&gt;，下面统一简称为 &lt;em&gt;系统技术&lt;/em&gt;），你可能会反驳：”系统技术嘛，在计算机基础课程里我早就学过了，考试也通过了！“。是的，在计算机专业的课程里都设置有诸如 &lt;em&gt;组成原理&lt;/em&gt;、&lt;em&gt;编译原理&lt;/em&gt;、&lt;em&gt;操作系统&lt;/em&gt; 等课程，还因为担心你吸收不了而一门一门地分好几个学期教学。不过&lt;strong&gt;把这些科目分开学习是错误的&lt;/strong&gt;，因为计算机的系统技术是相互交叉的。&lt;/p&gt;&lt;p&gt;&lt;img src=&#34;images/path.zh.png&#34; alt=&#34;path&#34;&gt;&lt;em&gt;螺旋式的学习路径&lt;/em&gt;&lt;/p&gt;&lt;p&gt;计算机系统包括了 &lt;em&gt;语言&lt;/em&gt;、&lt;em&gt;处理器&lt;/em&gt; 和 &lt;em&gt;操作系统&lt;/em&gt; 三个基本组成部分。如果从远距离来看，处理器和操作系统会是同一回事，它们共同构建了一种人类文明当中最复杂的机器 ———— 计算机。处理器负责实现不变的逻辑运算，操作系统是处理器的自然延伸，负责实现需要变化的部分。而语言则用于表达、封装和抽象机器的功能，使得机器和人类之间的交流成为可能。可见它们是 &lt;strong&gt;同一个目的 ———— 让机器解决问题&lt;/strong&gt; 的不同侧面，分开学习自然无法理解其中的联系和缘由。不妨把每一个领域想象成一根根立起来的柱子，正确的学习路径是围绕着这些柱子&lt;strong&gt;螺旋式地逐渐地往上爬&lt;/strong&gt;，而不是一口气爬完一根柱子，然后滑下来再爬另一根柱子。&lt;/p&gt;&lt;p&gt;其次学习方式也存在问题，计算机系统技术大部分是工程师们在不断地解决问题之后得出的总结及其积累，也就是说，在这些技术当中理论并不是占主导作用，更多是为了解决问题而通过各种尝试后得出的 &lt;em&gt;最佳实践&lt;/em&gt;。因此较好的的学习方式应该是先从探索和尝试开始入手，然后&lt;strong&gt;边实践边试错、边领会边总结&lt;/strong&gt;，而不是先学一大堆原理，做完一堆习题，再来实践。&lt;/p&gt;&lt;p&gt;&lt;img src=&#34;images/way.zh.png&#34; alt=&#34;way&#34;&gt;&lt;/p&gt;&lt;p&gt;总的来说，虽然我们几乎都学过跟计算机系统相关的科目，但因为跟系统的构建方式和过程都相差甚远，所以实际上并没有真正掌握到这些技术。不妨试试在没有网络的帮助下，看看能否自己设计一套最简的指令集，然后动手画画微架构（microarchitecture）的大致数据通路（data path）；或者给定一个目标架构，编写一个冷启动的引导程序；又或者不依赖任何库，从零开始手写一个简单的语法解析器，你会发现这都很困难。&lt;/p&gt;&lt;h2 id=&#34;特点&#34;&gt;特点&lt;/h2&gt;&lt;p&gt;实际上我们在平时的工作和学习当中已经积累了一定的系统知识，只是它们在脑海里是松散的或者不完整的，我希望能通过一系列文章，把这些知识有序地连接起来，从而成为你真正掌握的知识和技术。这系列文章有如下特点：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;不再是 “先讲原理然后做项目”，而是从探索和尝试入手，在实践和试错过程中再穿插原理（有时我还会穿插一些小典故）。而且跟很多实践型教程不一样，这系列不单单讲 &lt;strong&gt;如何做&lt;/strong&gt;，还会为每一个操作步骤讲 &lt;strong&gt;为什么要这样做&lt;/strong&gt;。很多实践型教程往往忽视了第二点，它们一般是哗啦啦地把每个操作步骤、输入的每个参数等详细地罗列出来，你必须严格跟着指引一步一步走才能最后成功。跟着这些教程虽然你也能做出 “作品”，不过对其中的缘由肯定非常模糊。而且这些操作指引对环境和工具非常依赖，常常因为软硬件环境的变化或者工具的版本的更新，导致其中某些步骤有细微变化，跟教程不一致，而最后无法成功。&lt;/li&gt;&lt;li&gt;不再分学科，而是根据系统的构建过程以及我们能理解的程度，把整个系列切分为多个小阶段。每个小阶都会同时涉及多个学科的知识，但同时都是够用为止，不会过度深入，只有完成一个阶段之后再进入下一个阶段。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;不需要任何专门的 IDE、SDK 或者库&lt;/strong&gt;，从零开始构建。开始阶段只需几个通用的开源免费的编译器和工具，后面则会使用自己的工具。因为连工具都是自己构建的，因此可以彻底弄明白每一个技术细节而不会留有死角。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;不需要任何专门的软件和硬件&lt;/strong&gt;，只使用几个通用的开源免费的软件，和几个最广泛使用的（久经考验的）最廉价的硬件模块，即可以完成到最后一章。很多专业的系统技术教程或者培训需要各种高大上的昂贵的专业软件和硬件，而我们这个系列一共只需一两百来块钱（当然这系列的文章是免费的，文章当中也不会有任何广告或者推广链接）。最重要的是这个系列不是为了让你成为某个软件或者硬件的操作工和使用者，而是让你自己创造工具、构建系统。&lt;/li&gt;&lt;li&gt;不是科普，不是走马观花式的观摩，而是真正深入地对计算机系统的完整实践。通过这一系列文章，你会对系统有正确的认识和理解，可以不被那些流传广泛而实则错误的各种时髦 “知识” 所迷惑（比如很多人认为计算机核心技术只有芯片制造机器，似乎解决这一项其它都不是问题，而事实上这是完全错误的）。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;这一系列文章会以 RISC-V 指令集作为学习和实现的目标架构，之所以选择 RISC-V 原因有：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;它的指令集相对比较简单，这使得我们自己动手实现 &amp;ldquo;最小的能工作的&amp;rdquo; 编译器及处理器成为可能；&lt;/li&gt;&lt;li&gt;有大量相关的开源免费的工具和文档，可以享用现有的工具来检查和验证我们的 &amp;ldquo;作品&amp;rdquo; 是否正确，这对摸索和学习过程非常重要；&lt;/li&gt;&lt;li&gt;最后如果我们做出了产品，也无需顾虑授权问题。&lt;/li&gt;&lt;/ul&gt;&lt;h2 id=&#34;内容简介&#34;&gt;内容简介&lt;/h2&gt;&lt;p&gt;无可否认计算机系统的内容非常之多，它是几十年以来成千上万个全球最顶尖工程师的总结和积累，无论是知识的广度和深度都几乎逼近人脑的极限，甚至可以说它是&lt;strong&gt;远超越我们当前时代&lt;/strong&gt;的一群人的作品。河马蜀黍知道无法简单地通过几篇文章就能讲完，所以准备了四个系列（series），每个系列分为若干部（part），每部含若干篇文章（chapter）。好吧，一共也就百来篇长文。用一句话描述这一系列文章的主要内容就是：&lt;strong&gt;学习现有的工具和系统，制作自己的工具，打造新的系统&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;&lt;img src=&#34;images/content.zh.png&#34; alt=&#34;content&#34;&gt;&lt;/p&gt;&lt;p&gt;虽然内容非常多，不过你不用担心难度过高而无法完成，因为每一个部分虽然名堂很大，但都是仅实现最基本的 &amp;ldquo;刚好能用&amp;rdquo; 的程度即止。最主要的是，系统技术的&lt;strong&gt;每一个小环节只要单独拿出来分析和实践都会出乎意料地简单&lt;/strong&gt;，所以只需一步步跟着来，就不会发生在中途就被卡住的情况。&lt;/p&gt;&lt;p&gt;当然我也会在 “简陋” 和 “实用” 之间平衡，让每一部的 “作品” 都有实用价值。现代主流的计算机系统都有沉重的历史包袱，比如 GCC 已有三十多年的历史，Linux 内核也持续开发三十年，对于新手来说，无论是阅读理解、修改、扩充都非常困难，而且很多新观念无法整合。而我们的系统因为是从零开始，完全没有包袱，所以实现起来相对会简单轻松，有些顽固问题也可以从根本上解决；新理念（严格来说并不是新的，只是鲜有人知而已）也能无所顾忌地加入，比如：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;同一门语言可以同时用于硬件开发、底层开发、后端开发和前端开发；&lt;/li&gt;&lt;li&gt;一门阅读友好的汇编语言；&lt;/li&gt;&lt;li&gt;一门函数型的链接脚本语言；&lt;/li&gt;&lt;li&gt;使用微内核的系统，驱动程序能像普通程序一样轻松开发、调试、安装和发布；&lt;/li&gt;&lt;li&gt;系统永不需关机和重启，可回滚的更新机制；&lt;/li&gt;&lt;li&gt;基于能力（capability）而不是 &lt;em&gt;用户和组&lt;/em&gt; 的系统安全模型；&lt;/li&gt;&lt;li&gt;数据结构化的 Shell；&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;当然还有很多特性，在具体章节里会再详细列举。所以这套系统有相当多的特点和优点，特别是&lt;strong&gt;我们会制作和使用自己的工具&lt;/strong&gt;，所以即使你能看到类似 “从零开始构建系统” 的书籍或文章，我们这个系列仍会让你感到耳目一新 😁。&lt;/p&gt;&lt;h2 id=&#34;点赞转发打赏&#34;&gt;点赞、转发、打赏&lt;/h2&gt;&lt;p&gt;虽然这系列文章的大部分内容我都已经实践过，不过我发现要把它们从头到尾讲解起来相当有挑战性：庞大而交叉的内容如何组织，如何挑选实践的内容，如何做到篇章之间的自然过渡和衔接，如何确保知识的准确性，如何让读者看得轻松明白等等，单单第一个系列的前 8 篇文章，经过反复琢磨和修改，前前后后居然用了四个多月的时间。我不知道还要多少年时间才能把最后一章写完。&lt;/p&gt;&lt;p&gt;而另一方面，虽然从宏观上来说计算机系统技术承载着科学技术的传承和创新，承载者现代工业的基础等重要意义，但对于个人来说，却很 &amp;ldquo;现实地&amp;rdquo; 几乎没有任何用处（💰），毕竟几乎所有企业都从事应用层面的开发，系统技术无论是对普通人还是对开发人员都太过遥远了。虽然我努力地写好每一篇文章，但显然，阅读的人肯定是寥寥可数的，这其中又只有极其少数人才会感兴趣。因此，如果你碰巧看到这一系列文章，如果觉得有收获，请毫不犹豫地打赏我吧！你的一瓶可乐一杯咖啡的打赏就是我下一篇文章的写作动力 😄。&lt;/p&gt;&lt;div&gt;    &lt;img src=&#34;https://hemashushu.github.io/images/subscribe-and-donate.zh.png&#34; class=&#34;block-image image-480px&#34;/&gt;&lt;/div&gt;&lt;p&gt;最后，虽然系统技术没有现实上的用处，但它却能可以很好地满足你的 “好奇心、探索欲，以及创造的冲动”。试想一下，还有什么比 “独自一人徒手征服人类史上最复杂的机器” 更酷的事情呢？！当你完成最后一章时，相信会看到一个不同的世界。点击下面的目录标题开始异世界之旅吧！&lt;/p&gt;&lt;hr&gt;&lt;h2 id=&#34;目录&#34;&gt;目录&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;&lt;strong&gt;note&lt;/strong&gt; 此目录会持续更新&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;strong&gt;系列 1: 一步一步深入 RISC-V 系统&lt;/strong&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;第一部：了解编译器、链接器、调试器以及一些常用二进制工具的使用方法，了解程序的组成，构建最小独立式可执行程序（freestanding，也叫 &lt;em&gt;裸机程序&lt;/em&gt;）等；&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&#34;../2022-11-05-s01c01-cross-compile-and-run-the-first-program&#34;&gt;S01C01 什么是交叉编译？GCC 交叉编译及运行第一个程序&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;第二部：通过微控制器（MCU）来简单地了解软件和硬件之间的交互原理，通过不使用 SDK 或者硬件抽象库（HAL），而是直接读写寄存器的方式编写裸机程序（固件），控制电信号的输入输出（GPIO），实现串口通信等；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;第三部：了解现代系统的程序加载、动态链接的原理，了解 RISC-V 的函数调用规程以及基本指令，使用汇编语言编写简单的程序；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;第四部：设计一门目标架构为 RISC-V 的汇编语言，实现其汇编器，同时了解简单的语法解析器的原理；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;第五部：设计一门链接脚本语言，实现其链接器，同时了解脚本解析器的原理。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;系列 2: 一步一步实现一门现代语言及其编译器&lt;/strong&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;第一部：设计一门中间语言（IR），实现从中间语言到汇编语言的代码生成器（code generator）；&lt;/li&gt;&lt;li&gt;第二部：设计一门现代的静态类型的语言，实现高级语言到中间语言的代码生成器，至此完成了一个 &lt;em&gt;简单的完整的编译系统&lt;/em&gt;；&lt;/li&gt;&lt;li&gt;第三部：实现 &lt;a href=&#34;https://webassembly.org/&#34;&gt;WASM&lt;/a&gt; 虚拟机（VM），然后实现中间语言到 WASM 的代码生成器。实现 WASM VM 的同时可以大致地认识一个处理器是如何工作的，另一方面有了 WASM 代码生成器，意味着我们的语言能在浏览器中运行；&lt;/li&gt;&lt;li&gt;第四部：实现中间语言到 &lt;a href=&#34;https://llvm.org/docs/LangRef.html&#34;&gt;LLVM IR&lt;/a&gt; 的代码生成器，让我们的语言能生成目标架构为 &lt;code&gt;x86&lt;/code&gt; 和 &lt;code&gt;arm&lt;/code&gt; 的程序。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img src=&#34;images/compilation-system.png&#34; alt=&#34;compilation system&#34;&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;第五部：实现项目构建器及包管理器，这是任何现代语言都必备的。&lt;/li&gt;&lt;li&gt;第六部：用当前语言重写编译器，实现语言自托管（self-hosting），即编译器可以编译自己的源代码，从此我们开始使用自己的工具来构建系统。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;系列 3: 一步一步实现一个实用型的 RISC-V CPU&lt;/strong&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;第一部：设计一个最小的指令集，实现数字累加和内存加载和存储功能；然后通过数字电路仿真软件实现一个最简处理器，该处理器包含了 ROM、RAM、寄存器堆（register file）、译码器、控制器及算术逻辑单元（ALU）等基本处理器要素，能执行我们的指令集。通过这一部来了解处理器的基本运作原理，以及软件如何变成电信号。&lt;/li&gt;&lt;li&gt;第二部：从我们的语言派生出一门 HDL 语言，实现该门语言的数字逻辑电路模拟器以及测试（验证）框架；实现从这门语言到 &lt;a href=&#34;https://en.wikipedia.org/wiki/SystemVerilog&#34;&gt;SystemVerilog&lt;/a&gt; 的代码生成器，然后用这门语言重新实现上一部的基础组件以及处理器，并下载到 FPGA 硬件上通电测试；&lt;/li&gt;&lt;li&gt;第三部：使用自己的 HDL 语言实现一个多时钟周期的 RV64I 处理器，并下载到 FPGA 硬件上通电测试；&lt;/li&gt;&lt;li&gt;第四部：实现常见的通信协议（比如 UART、$I^2C$、SPI），书写常见的外设（比如 GPIO 接口、SPI Flash、SD 卡、SSD 1306 显示屏等）的驱动。整合我们的处理器，实现一个完整的硬件系统；&lt;/li&gt;&lt;li&gt;第五部：将处理器微架构升级为多级流水线设计。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;系列 4: 一步一步实现一个实用的微内核操作系统&lt;/strong&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;第一部：为处理器添加内存管理单元（MMU）以及特权相关的模块；&lt;/li&gt;&lt;li&gt;第二部：实现最小的内核，即实现基本的串口输入输出，多级页表，内存管理，程序的加载及进程的简单分时切换，以及消息机制等；&lt;/li&gt;&lt;li&gt;第三部：实现简化版的 &lt;code&gt;ext4&lt;/code&gt; 文件系统；&lt;/li&gt;&lt;li&gt;第四部：实现简单的用户交互界面（shell）；&lt;/li&gt;&lt;li&gt;第五部：实现简单的网络接口；&lt;/li&gt;&lt;li&gt;第六部：实现一个包管理器；&lt;/li&gt;&lt;li&gt;第七部：为处理器添加浮点运算模块，以及一个矩阵计算协处理器（coprocessor）；&lt;/li&gt;&lt;li&gt;第八部：实现一个简单的机器学习库，实现手写数字识别程序；&lt;/li&gt;&lt;li&gt;第九部：实现一个简单的图形加速协处理器；&lt;/li&gt;&lt;li&gt;第十部：实现一个简单的图形库，实现一个复古风格的横向卷轴动作游戏。&lt;/li&gt;&lt;/ul&gt;</description>
     </item>
   
 </channel>
</rss>
