
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
 <channel>
   <title>作品 on 河马蜀黍的个人主页</title>
   <link>https://hemashushu.github.io/zh/works/</link>
   <description>Recent content in 作品 on 河马蜀黍的个人主页</description>
   <generator>Hugo -- gohugo.io</generator>
   <language>zh</language>
   <copyright>Copyright &amp;copy; 2023 - Hippospark Young</copyright>
   
       <atom:link href="https://hemashushu.github.io/zh/works/index.xml" rel="self" type="application/rss+xml" />
   
   
     <item>
       <title>S01C02 什么是裸机程序？编写一个无需操作系统也可独自运行的 Hello World 程序</title>
       <link>https://hemashushu.github.io/zh/posts/2022-11-06-s01c02-write-a-bare-metal-program-run-alone-without-os/</link>
       <pubDate>Sun, 06 Nov 2022 00:00:00 +0000</pubDate>
       
       <guid>https://hemashushu.github.io/zh/posts/2022-11-06-s01c02-write-a-bare-metal-program-run-alone-without-os/</guid>
       <description>&lt;p&gt;&lt;a href=&#34;../2022-11-05-s01c01-cross-compile-and-run-the-first-program&#34;&gt;上一章&lt;/a&gt; 我们写了一个 &amp;ldquo;Hello, World!&amp;rdquo; 程序，然后用 GCC 交叉编译并使用 QEMU 模拟器成功运行。不过我们也发现程序的体积有几百KB，里面肯定有很多不是我们自己写的内容，而且它还依赖操作系统才能运行。这一章将会编写一个无需操作系统、无需任何库，即可独自运行的 &amp;ldquo;Hello, World!&amp;rdquo; 程序（这种程序叫 &lt;em&gt;裸机程序&lt;/em&gt;），然后同样会使用 GCC 交叉编译并尝试使用 QEMU 运行。通过裸机程序，我们可以了解一个完整的程序是如何组成的，同时还会了解机器通电后如何执行程序。&lt;/p&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&#34;#1-%E4%BB%80%E4%B9%88%E6%98%AF%E8%A3%B8%E6%9C%BA%E7%A8%8B%E5%BA%8F&#34;&gt;1. 什么是裸机程序？&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#2-%E5%A6%82%E4%BD%95%E5%90%AF%E5%8A%A8%E8%A3%B8%E6%9C%BA%E7%A8%8B%E5%BA%8F&#34;&gt;2. 如何启动裸机程序&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#3-%E5%88%B6%E4%BD%9C%E8%A3%B8%E6%9C%BA%E7%89%88%E7%9A%84-hello-world-%E7%A8%8B%E5%BA%8F&#34;&gt;3. 制作裸机版的 &amp;ldquo;Hello, World!&amp;rdquo; 程序&lt;/a&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&#34;#31-%E5%A6%82%E4%BD%95%E7%9B%B4%E6%8E%A5%E8%AE%BF%E9%97%AE%E7%A1%AC%E4%BB%B6&#34;&gt;3.1 如何直接访问硬件？&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#32-%E9%80%9A%E8%BF%87%E4%B8%B2%E5%8F%A3%E5%8F%91%E9%80%81%E5%AD%97%E7%AC%A6&#34;&gt;3.2 通过串口发送字符&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#%E5%AE%9E%E7%8E%B0-print_string-%E5%87%BD%E6%95%B0&#34;&gt;实现 print_string 函数&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#%E4%B8%BB%E7%A8%8B%E5%BA%8F&#34;&gt;主程序&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E5%99%A8&#34;&gt;程序启动器&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#%E7%BC%96%E8%AF%91&#34;&gt;编译&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#%E9%93%BE%E6%8E%A5&#34;&gt;链接&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#%E8%BF%90%E8%A1%8C&#34;&gt;运行&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#%E6%89%93%E5%8C%85%E9%9D%99%E6%80%81%E5%BA%93&#34;&gt;打包静态库&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#%E6%80%BB%E7%BB%93&#34;&gt;总结&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;!-- raw HTML omitted --&gt;&lt;h2 id=&#34;1-什么是裸机程序&#34;&gt;1. 什么是裸机程序？&lt;/h2&gt;&lt;p&gt;&lt;em&gt;裸机程序&lt;/em&gt; 是指在 &amp;ldquo;无操作系统&amp;rdquo; 的环境中运行的程序，初一听起来可能会觉得很神奇：“一台机器不用安装操作系统也能运行程序？没有操作系统我怎样输入程序的名称？怎样启动程序？” 但仔细想想，操作系统的启动引导器（比如 &lt;a href=&#34;https://www.gnu.org/software/grub/&#34;&gt;GRUB&lt;/a&gt;），还有操作系统内核，它们都是在没有操作系统的情况下运行的。所以程序肯定能在没有操作系统的情况下运行，只是可能用了我们尚未知晓的魔法。&lt;/p&gt;&lt;p&gt;然而裸机程序并没有魔法，实际上它跟普通程序并没有太大的区别，无论是数值计算、流程控制、还是程序的结构，其代码跟普通程序是一样的。不同的地方在于进行一些特权操作或者硬件设备的 I/O 操作时，程序需要自己完成，无法让操作系统代劳。除此之外，裸机程序并不是通过文件名启动的，因为运行环境里可能根本没有文件系统，裸机程序通常以二进制形式存在于 ROM 或者磁盘的固定位置。&lt;/p&gt;&lt;p&gt;如果你想让裸机程序实现播放音乐和访问互联网功能，则需要自己写声卡和网卡的硬件驱动程序及其应用程序；如果想让音乐播放和上网两个程序同时进行，那么还得写进程管理程序；如果想保存文件到硬盘或者 SSD 里，则还得写文件系统；如果想让程序运行起来安全可靠一些，还得实现虚拟内存管理器。可见当你需要的功能越多，裸机程序就越接近一个操作系统，实际上操作系统内核就是一个典型的裸机程序。当然如果你只是想让机器做一些很简单的事情，裸机程序也可以极其简单，比如下面要写的 &amp;ldquo;Hello, World!&amp;rdquo; 程序。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;CPU 一般有 &lt;em&gt;监督者&lt;/em&gt;（&lt;em&gt;supervisor&lt;/em&gt;）和 &lt;em&gt;用户&lt;/em&gt; 两种模式。内核运行在内核模式下，可以使用大部分机器指令，即可以访问任何资源。应用程序运行在用户模式下，只有数值计算、内存读写等非常有限的机器指令可以使用。换句话说，在用户模式下，程序无法直接跟诸如键盘、鼠标、显示器、网卡等外设交流信息，在此模式下，应用程序几乎毫无用处。那么我们平常使用的程序丰富的功能是如何实现呢？答案是 CPU 为用户模式提供了一个 &lt;em&gt;系统调用&lt;/em&gt;（&lt;em&gt;syscall&lt;/em&gt;）指令，应用程序通过系统调用向操作系统（内核）请求对外部资源的访问从而实现各种各样的功能。值得一提的是，系统调用并非用户模式里的程序跟外部交流的唯一通道，比如 Linux 内核会创建诸如 &lt;code&gt;/dev&lt;/code&gt;, &lt;code&gt;/sys&lt;/code&gt; 等虚拟文件系统，用户程序通过读写这些虚拟文件也可以达到跟硬件交流的目的。除此之外，有些硬件外设会把自己的访问接口映射到内存的某段地址，用户程序对这段内存数据的读写，会转换成对硬件外设的访问。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;另外在微控制器（MCU）里运行的程序（通常称为 &lt;em&gt;固件&lt;/em&gt;，&lt;em&gt;firmware&lt;/em&gt;）也叫做裸机程序，因为微控制器的资源很少，没法运行一个操作系统，因此程序是独自运行的。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;有一种叫做 &lt;em&gt;实时操作系统&lt;/em&gt;（&lt;em&gt;RTOS&lt;/em&gt;）的程序，通常是以库的形式存在，它跟我们平常说的操作系统是完全不同的概念。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&#34;2-如何启动裸机程序&#34;&gt;2. 如何启动裸机程序&lt;/h2&gt;&lt;p&gt;机器通电或者复位之后，CPU 会从某个约定的内存地址开始执行第一条指令，这个内存地址一般对应着一段固定在 ROM 芯片里的 &lt;em&gt;加载程序&lt;/em&gt;（&lt;em&gt;loader&lt;/em&gt;）或硬件初始化程序（比如 BIOS，UEFI 程序，有时也叫做 &lt;em&gt;固件&lt;/em&gt;，&lt;em&gt;firmware&lt;/em&gt;）。然后加载程序会尝试从约定的地方加载系统 &lt;em&gt;引导程序&lt;/em&gt;（&lt;em&gt;boot loader&lt;/em&gt;）并跳转到该引导程序的第一条指令（简称 &lt;em&gt;入口&lt;/em&gt;），引导程序再加载 &lt;em&gt;内核&lt;/em&gt; 并跳转到内核的入口。可见机器的启动过程就是连续的几个程序运行和跳转的过程。&lt;/p&gt;&lt;p&gt;&lt;img src=&#34;./images/linux-boot-process.png&#34; alt=&#34;Linux 启动过程&#34;&gt;&lt;/p&gt;&lt;p&gt;需要注意的是并不是每一台机器通电后的启动过程都一样，有些硬件平台可能只有其中的一个或两个步骤，有些则可能会有更多的步骤。但有一点是确定的：每个程序的位置和入口都是上一个步骤约定的，所以要让机器运行我们写的裸机程序，最简单的方法是把这个程序放置在预留给 &lt;em&gt;引导程序&lt;/em&gt; 或者 &lt;em&gt;内核&lt;/em&gt; 的位置，这样就可以 &amp;ldquo;冒充&amp;rdquo; 为引导程序或者内核，机器通电后经过若干个步骤就会执行我们的程序。&lt;/p&gt;&lt;p&gt;我们要实现是一个 &amp;ldquo;裸机&amp;rdquo; 版的 &amp;ldquo;Hello, World!&amp;rdquo; 程序，该程序将会在 &lt;em&gt;QEMU RISC-V 64-bit Virt&lt;/em&gt; 的 &lt;em&gt;全系统模式&lt;/em&gt; 里运行。&lt;/p&gt;&lt;h2 id=&#34;3-制作裸机版的-hello-world-程序&#34;&gt;3. 制作裸机版的 &amp;ldquo;Hello, World!&amp;rdquo; 程序&lt;/h2&gt;&lt;p&gt;先看看传统的 &amp;ldquo;Hello, World!&amp;rdquo; 程序的源代码：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;) {&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;printf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Hello, World!&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上面的程序非常简单，关键的只有一条语句：通过调用 &lt;code&gt;printf&lt;/code&gt; 函数向屏幕输出 &amp;ldquo;Hello, World!&amp;rdquo; 字符串。通过调试程序逐步跟踪，或者查看 &lt;a href=&#34;https://sourceware.org/git/?p=glibc.git&#34;&gt;libc&lt;/a&gt; 的源码，会发现 &lt;code&gt;printf&lt;/code&gt; 函数（包括 &lt;code&gt;puts&lt;/code&gt; 函数）会经历一系列过程，最后通过 &lt;code&gt;write&lt;/code&gt; &lt;em&gt;系统调用&lt;/em&gt; 实现字符串输出。这表明了这个程序需要在操作系统的环境里才能正常运行，因此无法成为裸机程序。&lt;/p&gt;&lt;p&gt;如果要实现裸机版的 &amp;ldquo;Hello, World!&amp;rdquo; 程序，就必须自己实现向屏幕（硬件）显示字符的函数。&lt;/p&gt;&lt;h3 id=&#34;31-如何直接访问硬件&#34;&gt;3.1 如何直接访问硬件？&lt;/h3&gt;&lt;p&gt;幸好跟硬件打交道并不算太复杂，计算机硬件主要由数字电路组成。从程序的角度来看，这些电路里有许许多多 &amp;ldquo;小开关&amp;rdquo;。其中有些开关用于改变电路的元件状态从而实现某些特定的功能，也有一些开关会自己打开或者关闭，如同小灯泡一样，用于反映电路的状态。&lt;/p&gt;&lt;p&gt;这些 “小开关” 实际上对应着数字电路中的 &lt;em&gt;寄存器&lt;/em&gt; 元件，这些寄存器的输入端或者输出端会映射到内存空间的某个地址。于是当我们向这些内存地址写入比特 0 或者 1 时，就可以设置相应寄存器的状态（即低电平和高电平，分别用 0 和 1 表示），反之，读取这些内存地址，就能获得相应寄存器的状态。于是跟硬件打交道就简化为 &lt;strong&gt;向指定内存地址写入或者读取数据&lt;/strong&gt;。&lt;/p&gt;&lt;h3 id=&#34;32-通过串口发送字符&#34;&gt;3.2 通过串口发送字符&lt;/h3&gt;&lt;p&gt;虚拟机 &lt;em&gt;QEMU RISC-V 64-bit Virt&lt;/em&gt; 里有一个虚拟的硬件（芯片） &lt;a href=&#34;https://www.qemu.org/docs/master/system/riscv/virt.html&#34;&gt;NS16550&lt;/a&gt;，它实现了 &lt;a href=&#34;https://en.wikipedia.org/wiki/Universal_asynchronous_receiver-transmitter&#34;&gt;UART 通信协议&lt;/a&gt;，也就是我们常说的串口通信。当向这个硬件写入数据时，数据会通过 RS-232 接口（在现代计算机里，已经被 USB 接口取代）和电缆传送到另一端的设备，在 &lt;em&gt;QEMU RISC-V 64-bit Virt&lt;/em&gt; 里，这个 &lt;em&gt;另一端的设备&lt;/em&gt; 就是运行 QEMU 程序的虚拟终端。&lt;/p&gt;&lt;p&gt;通过阅读 &lt;a href=&#34;http://caro.su/msx/ocm_de1/16550.pdf&#34;&gt;NS16550 的数据手册（data sheet）&lt;/a&gt; 可知芯片一共有 13 个寄存器，这些寄存器用于控制硬件的工作参数，以及写入或者读取通信数据。每个寄存器根据其作用都有一个名称，比如 NS16550 的第一个寄存器叫做 &lt;code&gt;THR&lt;/code&gt;（Transmitter HoldingRegister），它用于存放待发送的数据。同时，每个寄存器都有其数据大小，在 NS16550 里每个寄存器大小刚好都是 8 bit，这组寄存器排列在一起将会形成一段数据空间。从数据手册可知 NS16550 的寄存器组形成了一段 8 bytes 的数据。这段数据将会映射到内存空间，于是这段空间就有了 &lt;em&gt;地址&lt;/em&gt;，程序通过 &lt;em&gt;偏移地址&lt;/em&gt; 可以定位其中的每个寄存器。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;NS16550 的寄存器空间之所以不是大小 &lt;code&gt;13 * 1 byte = 13 bytes&lt;/code&gt; 的空间，是因为部分寄存器共用了同一个位置。比如 &lt;code&gt;RHR&lt;/code&gt; 和 &lt;code&gt;THR&lt;/code&gt; 的地址都是 0。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/qemu/qemu/blob/master/hw/riscv/virt.c&#34;&gt;QEMU RISC-V virt 的源代码&lt;/a&gt; 有列出硬件外设（peripherals）的内存映射地址：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; MemMapEntry virt_memmap[] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ...&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    [VIRT_MROM] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;         {     &lt;span style=&#34;color:#ae81ff&#34;&gt;0x1000&lt;/span&gt;,        &lt;span style=&#34;color:#ae81ff&#34;&gt;0xf000&lt;/span&gt; },&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    [VIRT_UART0] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;        { &lt;span style=&#34;color:#ae81ff&#34;&gt;0x10000000&lt;/span&gt;,         &lt;span style=&#34;color:#ae81ff&#34;&gt;0x100&lt;/span&gt; },&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    [VIRT_FLASH] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;        { &lt;span style=&#34;color:#ae81ff&#34;&gt;0x20000000&lt;/span&gt;,     &lt;span style=&#34;color:#ae81ff&#34;&gt;0x4000000&lt;/span&gt; },&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    [VIRT_DRAM] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;         { &lt;span style=&#34;color:#ae81ff&#34;&gt;0x80000000&lt;/span&gt;,           &lt;span style=&#34;color:#ae81ff&#34;&gt;0x0&lt;/span&gt; },&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ...&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其中 UART 表示串口设备，从上面的列表得知这台虚拟机的串口设备 NS16550 的内存地址为 &lt;code&gt;0x10000000&lt;/code&gt;（某个外设的起始地址一般称为 &lt;em&gt;基址&lt;/em&gt;）。结合数据手册可知，寄存器 &lt;code&gt;THR&lt;/code&gt; 的地址是 &lt;code&gt;0x10000000 + 0 = 0x10000000&lt;/code&gt;，寄存器 &lt;code&gt;LSR&lt;/code&gt;（Line Status Register）的地址是 &lt;code&gt;0x10000000 + 0x5 = 0x10000005&lt;/code&gt;，如此类推。&lt;/p&gt;&lt;p&gt;如果要通过串口发送一个字符，只需向寄存器 &lt;code&gt;THR&lt;/code&gt; 的地址 &lt;code&gt;0x1000_0000&lt;/code&gt; 写入指定字符对应的 ASCII 数值（一个 uint8 类型整数），这个字符就会被重定向到正在运行 QEMU 程序的虚拟终端。&lt;/p&gt;&lt;p&gt;所以要实现打印单个字符的函数是很简单的，在任意目录新建一个名 &lt;code&gt;put_char.S&lt;/code&gt; 的文件, 内容如下：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-S&#34; data-lang=&#34;S&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.equ VIRT_UART0, &lt;span style=&#34;color:#ae81ff&#34;&gt;0x10000000&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.section .text.put_char&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.globl put_char&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;put_char&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    li s1, VIRT_UART0&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    mv s2, a0&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    sb s2, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;(s1)&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ret&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上面汇编源代码定义了一个名为 &lt;code&gt;put_char&lt;/code&gt; 的 &amp;ldquo;函数&amp;rdquo;，其中的代码作用如下：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;code&gt;.equ VIRT_UART0, 0x10000000&lt;/code&gt;：定义了一个名字为 &lt;code&gt;VIRT_UART0&lt;/code&gt; 的常量；&lt;/li&gt;&lt;li&gt;&lt;code&gt;put_char:&lt;/code&gt; 定义了一个名字为 &lt;code&gt;put_char&lt;/code&gt; 的 &lt;em&gt;标签&lt;/em&gt;。所谓 &lt;em&gt;标签&lt;/em&gt; 就是给一个内存地址命名。当编译器编译一个 C 语言里的用户自定义函数时，函数主体会被翻译成一段机器指令，这段机器指令由一个标签开始，最后由一个 &lt;em&gt;返回&lt;/em&gt; 指令结束，标签的名字取自函数的名称。在 C 语言里，调用一个函数本质上就是让 CPU 跳转到该函数的第一条指令的位置开始执行。如果该函数不是私有函数，则还会由 &lt;code&gt;.globl&lt;/code&gt; 指令导出，导出之后的标签叫 &lt;em&gt;导出符号&lt;/em&gt;。&lt;/li&gt;&lt;/ol&gt;&lt;blockquote&gt;&lt;p&gt;除了函数，C 语言里的全局变量、静态变量也是通过 &lt;em&gt;标签&lt;/em&gt; 来实现的，因为它们本质上是内存当中的一个数据，&lt;em&gt;标签&lt;/em&gt; 就是它们在内存当中的地址，程序通过标签就可以读写这些变量了；&lt;/p&gt;&lt;/blockquote&gt;&lt;ol start=&#34;3&#34;&gt;&lt;li&gt;&lt;code&gt;li s1, VIRT_UART0&lt;/code&gt;：将常量 &lt;code&gt;VIRT_UART0&lt;/code&gt; 的值加载进寄存器 &lt;code&gt;s1&lt;/code&gt;；&lt;/li&gt;&lt;li&gt;&lt;code&gt;mv s2, a0&lt;/code&gt;：将寄存器 &lt;code&gt;a0&lt;/code&gt; 的值，也就是函数的第一个参数的值，复制到寄存器 &lt;code&gt;s2&lt;/code&gt;；&lt;/li&gt;&lt;/ol&gt;&lt;blockquote&gt;&lt;p&gt;如果你之前了解过汇编，会发现 RISC-V 汇编代码的 &lt;a href=&#34;https://en.wikipedia.org/wiki/X86_assembly_language#Syntax&#34;&gt;指令参数的语法&lt;/a&gt; 接近 Intel 风格，而不是 AT&amp;amp;T 风格。不同风格的指令参数的阅读方向完全相反，书写汇编代码时需要注意这一点。&lt;/p&gt;&lt;/blockquote&gt;&lt;ol start=&#34;5&#34;&gt;&lt;li&gt;&lt;code&gt;sb s2, 0(s1)&lt;/code&gt;：将 &lt;code&gt;s2&lt;/code&gt; 的值写到内存地址 &lt;code&gt;s1 + 0&lt;/code&gt;。上面 3 句的作用综合起来就是把函数第一个参数的值写到内存 &lt;code&gt;0x10000000&lt;/code&gt;；&lt;/li&gt;&lt;li&gt;&lt;code&gt;ret&lt;/code&gt;：返回到函数调用者，&lt;/li&gt;&lt;li&gt;&lt;code&gt;.globl put_char&lt;/code&gt;：导出符号 &lt;code&gt;put_char&lt;/code&gt;，只有导出的符号才能被其它模块调用。&lt;/li&gt;&lt;/ol&gt;&lt;blockquote&gt;&lt;p&gt;RISC-V 汇编的内容会在后面的章节会详细讲解。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;code&gt;put_char&lt;/code&gt; 函数也可以用 C 语言实现，两个版本任意一个都可以正常工作。新建名为 &lt;code&gt;put_char.c&lt;/code&gt; 的文件，其内容如下：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#define VIRT_UART0 0x10000000&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;volatile&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; VIRT_UART0_PTR &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;)VIRT_UART0;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;put_char&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; c)&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;VIRT_UART0_PTR &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; c;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上面代码中关键字 &lt;code&gt;volatile&lt;/code&gt; 用于标记该变量的值可能会在程序之外被改变，通常用于数值来自内存某个地址的变量。&lt;/p&gt;&lt;p&gt;比如在源代码里有 &lt;strong&gt;连续多次读取&lt;/strong&gt; 同一个变量的语句，如果没有标记为 &lt;code&gt;volatile&lt;/code&gt;，编译器会把它优化为 &lt;strong&gt;只读取一次&lt;/strong&gt;。因为显而易见后面的几次读取都是同样的值，所以生成汇编时只会生成 &amp;ldquo;从内存读取&amp;rdquo; 的指令一次。如果这语句用于读取 UART 的接收到的字符，那么就会出错，因为这个变量的值会在程序外部被改变的。这时就必须为变量加上 &lt;code&gt;volatile&lt;/code&gt; 关键字，让编译器不要对它进行优化，而是原原本本地生成多条 &amp;ldquo;从内存读取&amp;rdquo; 的指令。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;为了简单起见，这里忽略了 UART 发送所需的延迟。如果是在真实硬件上编写发送字符的程序，应该检查 UART TX FIFO 的值，仅当上一个字符发送完毕之后（即 TX 空闲之后）再发送下一个字符。完整的发送/接收代码可以参考这个文件 &lt;a href=&#34;https://github.com/michaeljclark/riscv-probe/blob/master/libfemto/drivers/ns16550a.c&#34;&gt;ns16550a.c&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 id=&#34;实现-print_string-函数&#34;&gt;实现 print_string 函数&lt;/h3&gt;&lt;p&gt;在函数 &lt;code&gt;put_char&lt;/code&gt; 基础之上，可以实现打印字符串函数 &lt;code&gt;print_string&lt;/code&gt;。新建名为 &lt;code&gt;libprint.c&lt;/code&gt; 的文件，其内容如下：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;#34;put_char.h&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;print_string&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;str)&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;str &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;\0&amp;#39;&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;put_char&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;str);&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        str&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;主程序&#34;&gt;主程序&lt;/h3&gt;&lt;p&gt;主程序很简单，新建名为 &lt;code&gt;app.c&lt;/code&gt; 的文件，其内容如下：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;#34;libprint.h&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;bare_main&lt;/span&gt;()&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;print_string&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Hello, World!&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;因为这个是裸机程序，为了跟标准程序区分，这里把平常的主函数 &lt;code&gt;main&lt;/code&gt; 命名为 &lt;code&gt;bare_main&lt;/code&gt;（随意的取一个名字都可以）。&lt;/p&gt;&lt;h3 id=&#34;程序启动器&#34;&gt;程序启动器&lt;/h3&gt;&lt;p&gt;学习过 C 语言编程的大概都知道程序最先被执行的是 &lt;code&gt;main&lt;/code&gt; 函数，可实际上程序的入口（即最先被开始执行的指令）是由编译器自动生成的 &lt;code&gt;_start&lt;/code&gt; 过程，该过程会做一些初始化工作，比如设置栈顶地址等，然后才跳转到函数 &lt;code&gt;main&lt;/code&gt;。不过仅在编译和链接为标准 Linux 的程序时，编译器才会自动添加 &lt;code&gt;_start&lt;/code&gt; 过程，现在我们写的是裸机程序，所以需要自己手写类似的入口过程。新建名为 &lt;code&gt;startup.S&lt;/code&gt; 的文件，其内容如下：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-S&#34; data-lang=&#34;S&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.section .text.entry&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.globl _start&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;_start&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    la sp, stack_top&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    call bare_main&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;_loop&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    nop&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    j _loop&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其中的代码的大致作用如下：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;code&gt;la sp, stack_top&lt;/code&gt; 因为程序有嵌套的函数调用，所以需要用到 &lt;em&gt;栈&lt;/em&gt;。在 RISC-V 体系里，通过向 &lt;code&gt;sp&lt;/code&gt;（stack pointer）寄存器写入一个地址即可设置栈顶地址，这样就把 &lt;em&gt;栈&lt;/em&gt; 搭建好了；（注意代码中的 &lt;code&gt;stack_top&lt;/code&gt; 来自下面的链接脚本 &lt;code&gt;app.ld&lt;/code&gt; 导出的符号）&lt;/li&gt;&lt;li&gt;&lt;code&gt;_loop:&lt;/code&gt; 定义一个名字为 &lt;code&gt;_loop&lt;/code&gt; 的符号，这个符号没有导出，所以它是内部使用的；&lt;/li&gt;&lt;li&gt;&lt;code&gt;nop&lt;/code&gt; 这是一个伪指令，对应的真实指令是 &lt;code&gt;addi zero, zero, 0&lt;/code&gt;，这个指令的作用是将寄存器 &lt;code&gt;zero&lt;/code&gt; 的值加 0，显然这是无作用的指令，通常用于表示什么都不做。&lt;/li&gt;&lt;li&gt;&lt;code&gt;j _loop&lt;/code&gt; 无条件跳转到符号 &lt;code&gt;_loop&lt;/code&gt;。这 3 行形成了一个死循环。&lt;/li&gt;&lt;li&gt;&lt;code&gt;call bare_main&lt;/code&gt; 调用主函数 &lt;code&gt;bare_main&lt;/code&gt;。当 &lt;code&gt;bare_main&lt;/code&gt; 函数执行完毕并返回后，就执行由 &lt;code&gt;_loop ... j _loop&lt;/code&gt; 组成的死循环。&lt;/li&gt;&lt;/ol&gt;&lt;blockquote&gt;&lt;p&gt;注意在汇编里没有函数或者过程的概念，如果没有遇到跳转或者分支指令或者错误，CPU 会一直往下执行。上面的一段程序之所以需要一个死循环，是为了防止从函数 &lt;code&gt;bare_main&lt;/code&gt; 返回之后 CPU 继续往下执行内存中那些乱七八糟的数据（硬件通电后内存中的数据是随机的），所以设置这样的一段小程序让 CPU 在原地打转（虽然不优雅却管用）。注意，当 QEMU 执行到这里时，你的电脑风扇也会飞快地旋转起来，不过不用担心，只需结束 QEMU 程序就好了。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&#34;编译&#34;&gt;编译&lt;/h2&gt;&lt;p&gt;编译各个源文件，但暂时不需要链接：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ riscv64-elf-as -o startup.o startup.S&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ riscv64-elf-gcc -I . -Wall -fPIC -c -o app.o app.c&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ riscv64-elf-gcc -I . -Wall -fPIC -c -o libprint.o libprint.c&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ riscv64-elf-as -o put_char.o put_char.S&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在编译 &lt;code&gt;app.c&lt;/code&gt; 时你可能会感到疑惑，在 &lt;code&gt;app.c&lt;/code&gt; 里调用了函数 &lt;code&gt;print_string&lt;/code&gt;，但这个函数却在后面才编译，那么为什么 &lt;code&gt;app.c&lt;/code&gt; 在 &amp;ldquo;引用了一个尚未编译的函数&amp;rdquo; 的情况下也能成功编译呢？&lt;/p&gt;&lt;p&gt;这正是 GCC 编译的工作原理，在编译一个源文件时，如果代码里有外部函数调用，编译器实际上是不管这个外部函数是否存在（是否已经编译），也不管它在哪里，你只需提供这个函数的签名给它即可（在当前的例子里，&lt;code&gt;print_string&lt;/code&gt; 的函数签名位于头文件 &lt;code&gt;libprint.h&lt;/code&gt; 里），这也是为什么各个源文件可以各自单独编译，甚至多个源文件可以并行编译的原因。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;平时编译软件可能会经常输入的类似 &lt;code&gt;$ make -j $(nproc)&lt;/code&gt; 或者直接 &lt;code&gt;$ make -j&lt;/code&gt; 这样的命令，它可以让编译速度提高几倍，现在你应该知道它的原理是：使用多个进程进行并行编译。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&#34;链接&#34;&gt;链接&lt;/h2&gt;&lt;p&gt;在上面的 &lt;a href=&#34;#%E5%A6%82%E4%BD%95%E7%9B%B4%E6%8E%A5%E8%AE%BF%E9%97%AE%E7%A1%AC%E4%BB%B6&#34;&gt;如何直接访问硬件？&lt;/a&gt; 一节里提到，需要把裸机程序放置在某个指定的位置，机器才能正确找到并执行，在 QEMU 里这个位置是内存地址 &lt;code&gt;0x80000000&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;怎样才能让 QEMU 把程序加载到指定的位置呢？&lt;code&gt;qemu-system-riscv64&lt;/code&gt; 支持加载 ELF 格式的程序和纯二进制数据：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;当加载的是 ELF 格式文件时，它会按照 ELF 的结构信息加载到指定的位置；&lt;/li&gt;&lt;li&gt;当加载的是纯二进制数据是，可以通过参数 &lt;code&gt;-device loader,file=FILENAME,addr=0x80000000&lt;/code&gt; 指定加载地址。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;下面采用的是第一种方法，只需在链接时指定一个链接脚本，就可以让链接器按照脚本的描述来组织和生成可执行文件。新建名为 &lt;code&gt;app.ld&lt;/code&gt; 的文件，其内容如下：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;OUTPUT_ARCH(riscv)&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ENTRY(_start)&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;BASE_ADDRESS = 0x80000000;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;SECTIONS&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  . = BASE_ADDRESS;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  .text : {&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    *(.text.entry)&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    *(.text .text.*)&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  .rodata : {&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    *(.rodata .rodata.*)&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  .data : {&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    *(.data .data.*)&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  .bss :{&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    *(.bss .bss.*)&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  . = ALIGN(8);&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  /* a 4KB stack */&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  stack_bottom = .;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  . += 4096;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  stack_top = .;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其中 &lt;code&gt;. = BASE_ADDRESS&lt;/code&gt; 语句用于指定程序的第一个段的加载地址，相当于指定了程序的加载位置。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;有关 &lt;em&gt;程序段&lt;/em&gt; 以及链接脚本的详细内容，会在下一章讲解。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;然后使用 &lt;code&gt;ld&lt;/code&gt; 命令把 &lt;code&gt;startup.o&lt;/code&gt;，&lt;code&gt;app.o&lt;/code&gt;，&lt;code&gt;libprint.o&lt;/code&gt; 和 &lt;code&gt;put_char.o&lt;/code&gt; 链接起来，并根据链接脚本 &lt;code&gt;app.ld&lt;/code&gt; 生成可执行文件：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ riscv64-elf-ld -T app.ld -o app.out startup.o app.o libprint.o put_char.o&lt;/code&gt;&lt;/p&gt;&lt;p&gt;命令中个参数的作用：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;-T app.ld&lt;/code&gt; 表示使用指定的链接脚本 &lt;code&gt;app.ld&lt;/code&gt;，如果省略这个参数，链接器会用内置的默认链接脚本。&lt;/li&gt;&lt;li&gt;&lt;code&gt;-o app.out&lt;/code&gt; 指定输出文件的文件名。&lt;/li&gt;&lt;li&gt;&lt;code&gt;startup.o app.o libprint.o put_char.o&lt;/code&gt; 表示待链接的文件列表（注意，文件列表和共享库列表一样，尽量按照 &amp;ldquo;被依赖的项排在后面&amp;rdquo; 这样的顺序排列。顺序错误的话可能会导致链接失败）。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;命令运行之后将会得到 ELF 格式的可执行文件 &lt;code&gt;app.out&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;当然上面的编译和链接过程也可以只用一个命令来完成：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;riscv64-elf-gcc &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;    -I . &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;    -Wall &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;    -fPIC &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;    -g &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;    -Wl,-T,app.ld &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;    -nostdlib &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;    -o app.out &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;    startup.S app.c libprint.c put_char.S&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上面命令有两个新的参数：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;-Wl,-T,app.ld&lt;/code&gt; 这个参数用于 &amp;ldquo;传递参数给链接器 &lt;code&gt;ld&lt;/code&gt;&amp;quot;，相当于 &lt;code&gt;$ ld ... -T app.ld ...&lt;/code&gt;。当需要把参数从 GCC 传递给链接器时，可以构造这种以逗号分隔的字符串。&lt;/li&gt;&lt;li&gt;&lt;code&gt;-nostdlib&lt;/code&gt; 表示不需要自动往目标程序添加 &lt;code&gt;_start&lt;/code&gt; 启动过程以及链接 C 的标准库（标准库提供了诸如 &lt;code&gt;printf&lt;/code&gt; 等函数），上一章我们知道 GCC 会自动往目标程序添加很多内容，而参数 &lt;code&gt;-nostdlib&lt;/code&gt; 用于告诉链接器：整个程序的内容都由我们自己的代码提供，这是构建裸机程序必须的。&lt;/li&gt;&lt;/ul&gt;&lt;blockquote&gt;&lt;p&gt;还有跟 &lt;code&gt;-nostdlib&lt;/code&gt; 参数类似的几个链接参数：&lt;code&gt;-nostartfiles&lt;/code&gt;、&lt;code&gt;-nodefaultlibs&lt;/code&gt; 和 &lt;code&gt;-nolibc&lt;/code&gt;。它们分别表示不需要添加启动过程、不要链接默认的库（如 &lt;code&gt;libgcc&lt;/code&gt;）以及不要链接 C 标准库（&lt;code&gt;libc&lt;/code&gt;）。参数 &lt;code&gt;-nostdlib&lt;/code&gt; 相当于前两个参数的组合，一般编译裸机程序只需添加这个链接参数即可，另外如果仅仅想自己指定启动函数，则只添加 &lt;code&gt;-nostartfiles&lt;/code&gt;，另外两个参数的使用场合较少。详细的可以参阅 &lt;a href=&#34;https://gcc.gnu.org/onlinedocs/gcc/Link-Options.html&#34;&gt;GCC 链接参数说明&lt;/a&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;有时目标架构缺少某些指令（比如 rv32i 缺少乘法和除法指令），GCC 编译器会使用其它指令的组合来代替，如果使用了 &lt;code&gt;-nostdlib&lt;/code&gt; 链接参数，则需要手动加上 &lt;code&gt;-lgcc&lt;/code&gt; 参数。&lt;code&gt;gcc&lt;/code&gt; 库跟 &lt;code&gt;libc&lt;/code&gt; 库的不同地方在于，前者提供的函数主要用于解决编译问题，后者则用于跟操作系统打交道以及提供常用函数。所以前者一般也称为 &lt;em&gt;编译器的私有库&lt;/em&gt;，我们写程序时是不会直接调用到这个库，相反，&lt;code&gt;libc&lt;/code&gt; 则高频地被我们的程序代码所调用。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&#34;运行&#34;&gt;运行&lt;/h2&gt;&lt;p&gt;下面使用 QEMU 的 &lt;em&gt;全系统模式&lt;/em&gt; 程序 &lt;code&gt;qemu-system-riscv64&lt;/code&gt; 运行该文件：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ qemu-system-riscv64 &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;    -machine virt &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;    -nographic &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;    -bios none &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;    -kernel app.out&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如无意外，应该能看到正确的输出结果 &amp;ldquo;Hello, World!&amp;quot;。&lt;/p&gt;&lt;p&gt;&lt;img src=&#34;images/qemu-system.png&#34; alt=&#34;qemu system&#34;&gt;&lt;/p&gt;&lt;p&gt;这时你的主机（通常称为 &lt;em&gt;host&lt;/em&gt;）可能会有一个核心（core）的负载率高达 100%，这是因为 &amp;ldquo;Hello, World!&amp;rdquo; 程序从 &lt;em&gt;bare_main&lt;/em&gt; 函数返回之后，来到了一个死循环（即 &lt;code&gt;startup.S&lt;/code&gt; 里的 &lt;code&gt;_loop&lt;/code&gt;），你需要结束 QEMU 程序才能让 CPU 平静下来。&lt;/p&gt;&lt;p&gt;请注意你需要按 &lt;code&gt;Ctrl+a&lt;/code&gt; 然后松开 &lt;code&gt;Ctrl&lt;/code&gt; 键再按 &lt;code&gt;x&lt;/code&gt; 来结束 QEMU 程序，而不是平常的 &lt;code&gt;Ctrl+c&lt;/code&gt;，这个奇怪的组合键可能跟 VIM 的退出方法一样，会让你手忙脚乱一阵子。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;QEMU 不使用 &lt;code&gt;Ctrl+c&lt;/code&gt; 退出自身是有原因的，因为在 QEMU 里运行的是一个系统（通常称为 &lt;em&gt;guest&lt;/em&gt;），比如一个完整的 Linux 系统，或者一个 Linux 桌面，QEMU 需要保留 &lt;code&gt;Ctrl+x&lt;/code&gt; 这个常用的组合键给 guest 里面的程序，所以虚拟机本身当然不能用 &lt;code&gt;Ctrl+c&lt;/code&gt; 来退出了。有些串口通信程序也是使用这样 &amp;ldquo;奇怪&amp;rdquo; 的组合键来结束程序本身，比如 &lt;a href=&#34;https://github.com/npat-efault/picocom&#34;&gt;picocom&lt;/a&gt; 和 &lt;a href=&#34;https://salsa.debian.org/minicom-team/minicom&#34;&gt;minicom&lt;/a&gt; 使用 &lt;code&gt;Ctrl+a, Ctrl+x&lt;/code&gt;（或者按住 &lt;code&gt;Ctrl&lt;/code&gt; 键，然后依次按 &lt;code&gt;a&lt;/code&gt; 键和 &lt;code&gt;x&lt;/code&gt; 键）。还有 SSH 连接被动断开时，需要使用 &lt;code&gt;Ctrl+D&lt;/code&gt; 或者 &lt;code&gt;~.&lt;/code&gt;（即先按 &lt;code&gt;Shift+~&lt;/code&gt; 再按 &lt;code&gt;.&lt;/code&gt;）这些不寻常的组合键，都是基于同样的原因。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&#34;打包静态库&#34;&gt;打包静态库&lt;/h2&gt;&lt;p&gt;多写几个裸机程序之后，你可能会发现诸如 &lt;code&gt;startup.S&lt;/code&gt;、&lt;code&gt;libprint.c&lt;/code&gt; 和 &lt;code&gt;put_char.S&lt;/code&gt; 等基础功能会经常被不同的程序所引用，我们可以把这些基础功能的代码编译并打包为一个库，就像 C 标准库 &lt;code&gt;libc&lt;/code&gt; 一样，这样可以方便以后使用。&lt;/p&gt;&lt;p&gt;在 Linux 系统里，&lt;em&gt;库&lt;/em&gt; 分有 &lt;em&gt;静态库&lt;/em&gt; 和 &lt;em&gt;动态库&lt;/em&gt; 两种，扩展名分别为 &lt;code&gt;*.a&lt;/code&gt; 和 &lt;code&gt;*.so&lt;/code&gt;。静态库的代码会在编译的过程直接复制到输出文件（即可执行文件），而动态库则需要操作系统的支持，在程序运行时动态地链接上。当前程序是裸机程序，所以只能使用静态库了。使用工具 &lt;code&gt;ar&lt;/code&gt; 可以将一个或多个 &lt;em&gt;可重定位文件&lt;/em&gt; 打包成一个静态库，例如：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ riscv64-elf-ar rs libbaremetal.a startup.o libprint.o put_char.o&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;ar&lt;/code&gt; 命令后面跟着 &lt;em&gt;一个操作码&lt;/em&gt; 以及 &lt;em&gt;零个或多个修饰符&lt;/em&gt;：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;操作码 &lt;code&gt;r&lt;/code&gt; 表示插入新的文件，或者替换静态库中已存在的文件，通常用于新建静态库；&lt;/li&gt;&lt;li&gt;修饰符 &lt;code&gt;s&lt;/code&gt; 表示为静态库创建索引，相当于创建完静态库之后执行了一次 &lt;code&gt;$ riscv64-elf-ranlib libbaremetal.a&lt;/code&gt; 命令；&lt;/li&gt;&lt;li&gt;&lt;code&gt;libbaremetal.a&lt;/code&gt; 是输出的文件的文件名；&lt;/li&gt;&lt;li&gt;&lt;code&gt;startup.o libprint.o ...&lt;/code&gt; 是待打包的文件列表。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;运行之后将得到静态库文件 &lt;code&gt;libbaremetal.a&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;工具 &lt;code&gt;ar&lt;/code&gt; 除了可以创建静态库，还可以用于查看或者修改，使用不同的操作码就能实现不同的功能。比如下面的命令可以查看静态库文件里含有哪些文件：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ riscv64-elf-ar t libbaremetal.a&lt;/code&gt;&lt;/p&gt;&lt;p&gt;输出的结果如下：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;startup.o&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;libprint.o&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;put_char.o&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;由此可以确定已经正确打包所需的文件了。然后编译时就再也不需要 &lt;code&gt;startup.S&lt;/code&gt;、&lt;code&gt;libprint.c&lt;/code&gt; 和 &lt;code&gt;put_char.S&lt;/code&gt;（当然头文件 &lt;code&gt;libprint.h&lt;/code&gt; 仍需要），使用一个 &lt;code&gt;libbaremetal.a&lt;/code&gt; 代替它们三个即可，编译命令也得到了简化：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;riscv64-elf-gcc &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;    -I . &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;    -Wall &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;    -fPIC &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;    -g &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;    -Wl,-T,app.ld &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;    -nostdlib &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;    -o app-one.out &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;    app.c libbaremetal.a&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;运行之后将得到可执行文件 &lt;code&gt;app-one.out&lt;/code&gt;，这个文件跟 &lt;code&gt;app.out&lt;/code&gt; 是一模一样的。（可以使用命令 &lt;code&gt;$ diff app-one.out app.out&lt;/code&gt; 验证）&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;工具 &lt;a href=&#34;https://en.wikipedia.org/wiki/Ar_(Unix)&#34;&gt;ar&lt;/a&gt; 实际上是一个通用的打包程序，只是后来被 &lt;code&gt;tar&lt;/code&gt; 替换了，目前 &lt;code&gt;ar&lt;/code&gt; 主要用于创建静态库。顺便一提，&lt;em&gt;Debian&lt;/em&gt; 的包文件 &lt;code&gt;*.deb&lt;/code&gt; 也是 ar 格式。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;&lt;p&gt;这章我们创建了一种无需操作系统、无需任何库，就可以独自运行的程序，并了解了机器通电后是如何一步步地加载并运行我们的程序，同时也知道操作系统的内核其实是一个 &amp;ldquo;大号&amp;rdquo; 的裸机程序，而这章写的裸机程序也可以粗略地看作是一个功能弱到爆的 &lt;em&gt;系统内核&lt;/em&gt;。希望通过这章的学习和实践，能够破除内核的神秘感，同时能解开诸如 “机器通电后经历会做些什么？” 这些长期存在我们心中的困惑。&lt;/p&gt;&lt;p&gt;下一章将会深入剖析 &lt;em&gt;可执行文件&lt;/em&gt; 的组成和结构，让我们看看 &amp;ldquo;Hello, World!&amp;rdquo; 在 &amp;ldquo;物理&amp;rdquo; 层面究竟是什么样子的。&lt;/p&gt;&lt;div&gt;    &lt;img src=&#34;https://hemashushu.github.io/images/subscribe-and-donate.zh.png&#34; class=&#34;block-image image-480px&#34;/&gt;&lt;/div&gt;</description>
     </item>
   
     <item>
       <title>S01C01 什么是交叉编译？GCC 交叉编译及运行第一个程序</title>
       <link>https://hemashushu.github.io/zh/posts/2022-11-05-s01c01-cross-compile-and-run-the-first-program/</link>
       <pubDate>Sat, 05 Nov 2022 00:00:00 +0000</pubDate>
       
       <guid>https://hemashushu.github.io/zh/posts/2022-11-05-s01c01-cross-compile-and-run-the-first-program/</guid>
       <description>&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;p&gt;这是《一步一步深入 RISC-V 系统》系列文章的第一章。在这个系列里，我们将会了解程序是如何构建、程序文件本身是什么样的结构、程序是如何运行、软件和硬件之间是如何交流，以及汇编语言是怎样被转换为指令，等等有关程序的基本原理。在这个系列的后半阶段，我们会实现一个 RISC-V 汇编器和链接器，以及一门有特色的 RISC-V 汇编语言和链接器脚本语言。有了汇编器和链接器，我们就有能力生成程序（二进制可执行文件），这是我们制作自己的工具的基础。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;在 &lt;em&gt;John R. Levine&lt;/em&gt; 的《Linkers &amp;amp; Loaders》第一章里提到：“大概一个房间就能装得下世上所有编写链接器的人” （原文：&lt;em&gt;all the linker writers in the world could probably fit in one room&lt;/em&gt;）。也许我们学完这个系列之后也可以挤进这个小房间了，哈哈。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;这个系列的汇编器和脚本解析器我会用 &lt;a href=&#34;https://www.rust-lang.org/&#34;&gt;Rust&lt;/a&gt; 来编写。很多跟编译器和系统开发相关的文章、教程和项目都选择 C 语言作为编程语言。我知道在这个时代 C 语言已经无法提起你的兴趣，幸运的是现在有了更好的选择，使用 Rust 并不是为了追赶时髦，而是为了让我们避免低级错误，减少学习和开发过程中的挫折感，这对系统开发的初学者尤其重要。同时 Rust 有便利的工具链（正如很多现代语言那样），这些工具可以让我们专注于开发，减少一些反复的工作；当然在前面讲述基本原理的章节里，我还是会用到 C 语言，毕竟它非常直接明了，能够很好地跟底层技术对应上。&lt;/p&gt;&lt;p&gt;你可能会问：“为什么我们不直接开始动手写一门语言，或者写一个操作系统，或者写一个 CPU？” 虽然我能理解这种急切的心情，不过这种方法是行不通的。这是因为无论是上述的哪一个题目，起步都很高，如果从这些项目直接开始学习或者实践，会同时遇到很多新概念，当你试图弄懂其中的一个概念时，又会引出更多的新概念，最终我们的思路会被太多不能理解的事物所淹没。当然探索和学习的道路肯定不止一条，不过在跌跌撞撞地摸索一翻之后，大概率最终又会返回到当前这个位置，这里是系统开发的新手村。为了避免不必要的弯路，请从这里开始你的探索之旅吧。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;很多初学者可能都问过类似的问题：“CPU 怎样工作的？”，“怎样写操作系统？”，遗憾的是这些问题一般都得不到令提问者满意的答案，这是因为这些问题其实很庞大。类似的问题就像让你回答：“为什么干电池能点亮灯泡？”，“为什么磁铁会吸引铁片？”，一开始你可能会觉得这些问题很简单，但随着提问者不断深入，你会发现新出现的问题没完没了，直到你遇到知识盲区无法回答为止。&lt;/p&gt;&lt;/blockquote&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&#34;#1-%E5%89%8D%E8%A8%80&#34;&gt;1. 前言&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#2-%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91&#34;&gt;2. 什么是交叉编译？&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#3-gcc-%E7%BC%96%E8%AF%91%E5%99%A8&#34;&gt;3. GCC 编译器&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#4-%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F&#34;&gt;4. 交叉编译第一个程序&lt;/a&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&#34;#41-%E5%88%9B%E5%BB%BA-hello-world-%E7%A8%8B%E5%BA%8F&#34;&gt;4.1 创建 &amp;ldquo;Hello, World!&amp;rdquo; 程序&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#42-%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91&#34;&gt;4.2 交叉编译&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#43-elf-%E6%A0%BC%E5%BC%8F&#34;&gt;4.3 ELF 格式&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#5-%E8%BF%90%E8%A1%8C&#34;&gt;5. 运行&lt;/a&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&#34;#51-%E5%AE%89%E8%A3%85-qemu&#34;&gt;5.1 安装 QEMU&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#52-%E5%B0%9D%E8%AF%95%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F&#34;&gt;5.2 尝试运行程序&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#53-%E6%8C%87%E5%AE%9A%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%99%A8%E8%B7%AF%E5%BE%84&#34;&gt;5.3 指定动态链接器路径&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#54-%E7%BC%96%E8%AF%91%E4%B8%BA%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%A8%8B%E5%BA%8F&#34;&gt;5.4 编译为静态链接类型的程序&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#55-%E6%94%B9%E5%8F%98%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%99%A8&#34;&gt;5.5 改变程序的动态链接器&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#6-%E5%88%86%E9%98%B6%E6%AE%B5%E7%BC%96%E8%AF%91&#34;&gt;6. 分阶段编译&lt;/a&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&#34;#61-%E9%A2%84%E5%A4%84%E7%90%86&#34;&gt;6.1 预处理&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#62-%E7%BC%96%E8%AF%91&#34;&gt;6.2 编译&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#63-%E6%B1%87%E7%BC%96&#34;&gt;6.3 汇编&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#64-%E9%93%BE%E6%8E%A5&#34;&gt;6.4 链接&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#7-%E5%B8%B8%E7%94%A8%E7%9A%84%E7%BC%96%E8%AF%91%E5%8F%82%E6%95%B0&#34;&gt;7. 常用的编译参数&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#8-%E6%80%BB%E7%BB%93&#34;&gt;8. 总结&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;!-- raw HTML omitted --&gt;&lt;h2 id=&#34;1-前言&#34;&gt;1. 前言&lt;/h2&gt;&lt;p&gt;为了弄懂程序是如何构建的，我们可以借助一些现有的、被广泛使用的工具，也就是接下来要讲的编译器和调试器。同时为了能在一个人的能力范围之内实现一个相对完整的编译器，这个系列会选择相对简单、门槛较低的 RISC-V 体系结构作为研究和实践对象。当然我们现在所使用的计算机大部分都是 &lt;em&gt;x86_64&lt;/em&gt; 架构或者 &lt;em&gt;ARM&lt;/em&gt; 架构，所以为了构建 RISC-V 程序，就得从 &lt;em&gt;交叉编译&lt;/em&gt; 开始。&lt;/p&gt;&lt;h2 id=&#34;2-什么是交叉编译&#34;&gt;2. 什么是交叉编译？&lt;/h2&gt;&lt;p&gt;在一台电脑里编译生成在手机运行的应用程序，这种编译是 &lt;em&gt;交叉编译&lt;/em&gt;；在 Linux 系统里编译生成 Windows 应用程序，这种编译也是交叉编译；当然，在 &lt;em&gt;x86_64&lt;/em&gt; 架构版本的 Linux 系统里编译生成 &lt;em&gt;RISC-V&lt;/em&gt; 架构版本的 Linux 应用程序这种也是交叉编译。&lt;/p&gt;&lt;p&gt;简单来说，只要 &amp;ldquo;编译器所运行的环境&amp;rdquo; 跟 &amp;ldquo;生成的程序运行的环境&amp;rdquo; 不一样的编译过程叫做 &lt;em&gt;交叉编译&lt;/em&gt;。其中目标运行环境包括 &lt;em&gt;目标架构&lt;/em&gt; 和 &lt;em&gt;目标平台&lt;/em&gt; 两个元素：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;目标架构&lt;/em&gt; 是指目标机器的 CPU 指令集架构（ISA，有时简称为 &lt;em&gt;指令集&lt;/em&gt;），比如常用的 Intel 和 AMD 的 CPU 指令集是 &lt;em&gt;x86_64&lt;/em&gt;，现在流行的手机用的 ARM CPU 指令集是 &lt;em&gt;A64&lt;/em&gt;（我们经常听到的 &lt;em&gt;aarch64&lt;/em&gt; 是指 ARM CPU 的某一个运行状态的名称，当然理解为 &lt;em&gt;一个指令集子集&lt;/em&gt; 也是可以的）。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;目标平台&lt;/em&gt; 是指目标机器运行的操作系统类型，比如 &lt;em&gt;Linux&lt;/em&gt;, &lt;em&gt;Windows&lt;/em&gt; 以及 &lt;em&gt;Darwin/macOS&lt;/em&gt; 等。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;无论是_本地编译_（即普通的编译）还是_交叉编译_，其工作原理和过程是一模一样的，都是将高级语言翻译成目标环境的机器指令（汇编代码）。所以 &amp;ldquo;交叉编译&amp;rdquo; 这个名称并不是指某种功能，而是用于描述一种编译情况，即编译环境跟运行环境不同，仅此而已。&lt;/p&gt;&lt;p&gt;&lt;img src=&#34;./images/compilation-comparasion.png&#34; alt=&#34;本地编译和交叉编译&#34;&gt;&lt;/p&gt;&lt;p&gt;当然在开发程序时，除了需要考虑目标架构和目标平台，可能还得考虑更细致的一些信息，比如当你在开发 Linux 应用程序时，需要考虑不同发行版之间的细微差别。不过对于编译器来说，它的确只关心目标架构和目标平台。&lt;/p&gt;&lt;p&gt;另外还有一些不需要操作系统而能够自己独立运行的程序，这种程序叫做 &lt;em&gt;freestanding 程序&lt;/em&gt; 或者 &lt;em&gt;裸机（bare metal）程序&lt;/em&gt;，比如在微控制器（MCU）里运行的程序（通常也叫做 &lt;em&gt;固件&lt;/em&gt;）和内核程序，在编译这种程序则只需指定 &lt;em&gt;目标架构&lt;/em&gt; 而不需要指定 &lt;em&gt;目标平台&lt;/em&gt;。&lt;/p&gt;&lt;p&gt;交叉编译主要有两个目的：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;一是为了方便生成不同目标环境的程序文件（二进制可执行文件）。假如我们开发了一个应用程序需要发布到多个平台，通过交叉编译，每次更新时只需在开发机器上跑几次交叉编译就可以生成所需的程序文件。如果没有交叉编译，则需要将源代码复制到每一个目标环境然后再编译，这将会非常繁琐且耗时；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;其次，也是最重要的原因，有些目标环境根本无法运行编译器。比如在微控制器里，往往只有几十 KB 的 RAM 和几百 KB 的 Flash（相当于固态硬盘），只能运行一些很小的程序，这种情况下只能借助交叉编译来生成程序。你应该不会指望你家的电饭煲或者智能马桶能运行一整套编译器工具，并且在里面编译程序。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;顺便一提，我们将要实现的编译器的目标指令集是 &lt;em&gt;riscv64gc&lt;/em&gt;，也是一个交叉编译器。下面先学习一下目前主流的编译器，这些编译器都拥有交叉编译的能力。&lt;/p&gt;&lt;h2 id=&#34;3-gcc-编译器&#34;&gt;3. GCC 编译器&lt;/h2&gt;&lt;p&gt;目前主流的编译器有 GCC 和 LLVM，两者都是开源且免费的。因为在后面的讲述软硬件交流原理的章节里会用到微控制器（MCU），而在微控制器领域里 GCC 更常用一些，所以为了简单起见，下面只讲 GCC 编译器。&lt;/p&gt;&lt;p&gt;在开发程序时，除了编译器还会经常用到二进制工具 &lt;em&gt;Binutils&lt;/em&gt;、调试工具 &lt;em&gt;GDB&lt;/em&gt; 以及标准库和内核头文件等，这一套被称为 &lt;em&gt;GNU Toolchain&lt;/em&gt;。在大部分 Linux 发行版里都可以通过包管理器轻松安装 GNU Toolchain。根据编译目标的不同，工具链的软件包的名字也会不同，比如 &lt;a href=&#34;https://github.com/riscv-collab/riscv-gnu-toolchain&#34;&gt;RISC-V GNU Toolchain&lt;/a&gt;，它们的包名（在 &lt;em&gt;Arch Linux&lt;/em&gt; 里）分别是：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;riscv64-linux-gnu-binutils&lt;/li&gt;&lt;li&gt;riscv64-linux-gnu-gcc&lt;/li&gt;&lt;li&gt;riscv64-linux-gnu-gdb&lt;/li&gt;&lt;li&gt;riscv64-linux-gnu-glibc&lt;/li&gt;&lt;li&gt;riscv64-linux-gnu-linux-api-headers&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;另外编译目标为 RISC-V 裸机程序的包有：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;riscv64-elf-binutils&lt;/li&gt;&lt;li&gt;riscv64-elf-gcc&lt;/li&gt;&lt;li&gt;riscv64-elf-gdb&lt;/li&gt;&lt;li&gt;riscv64-elf-newlib&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;在不同的 Linux 发行版里包的名字会有所不同，比如在 &lt;em&gt;Debian&lt;/em&gt;/&lt;em&gt;Ubuntu&lt;/em&gt; 里包名是：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;binutils-riscv64-linux-gnu&lt;/li&gt;&lt;li&gt;gcc-riscv64-linux-gnu&lt;/li&gt;&lt;li&gt;binutils-riscv64-unknown-elf&lt;/li&gt;&lt;li&gt;gcc-riscv64-unknown-elf&lt;/li&gt;&lt;li&gt;gdb-multiarch&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;如果你系统的包仓库里没有 RISC-V GNU Toolchain，则可以 &lt;a href=&#34;https://github.com/riscv-collab/riscv-gnu-toolchain&#34;&gt;下载源代码&lt;/a&gt; 然后通过源代码的方式安装。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;如果没有另外的说明，整个系列文章的操作都是在 Linux 系统环境里完成的，当然你也可以在自己平常使用的系统上操作，不过如果你决心要深入学习系统技术的话，建议还是使用 Linux 系统环境，除了比较方便之外，更重要的是 Linux 系统（特别是内核）就像一个开放的图书馆，里面充满了宝藏，摆在身旁的宝藏都不要那实在太浪费了。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&#34;4-交叉编译第一个程序&#34;&gt;4. 交叉编译第一个程序&lt;/h2&gt;&lt;p&gt;&amp;ldquo;Hello, World!&amp;rdquo; 程序就像编程世界里的史莱姆一般的存在，作为交叉编译的第一个实践对象当然不会放过它。&lt;/p&gt;&lt;h3 id=&#34;41-创建-hello-world-程序&#34;&gt;4.1 创建 &amp;ldquo;Hello, World!&amp;rdquo; 程序&lt;/h3&gt;&lt;p&gt;在任意位置新建一个名为 &lt;code&gt;app.c&lt;/code&gt; 的文件，内容如下：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;) {&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;printf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Hello, World!&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;程序的功能非常简单：向屏幕打印一行文字 &amp;ldquo;Hello, World!&amp;quot;，然后结束程序，程序的返回值为 &lt;code&gt;0&lt;/code&gt;。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;每个程序运行结束后，都会向调用者返回一个整数，此整数称为 &lt;em&gt;返回值&lt;/em&gt;（&lt;em&gt;exit code&lt;/em&gt;）。它是一个 &lt;code&gt;uint32&lt;/code&gt; 数字，需注意的是在 Linux 环境里 &lt;em&gt;返回值&lt;/em&gt; 只有其二进制的最小 8 位是有效的，因此有效值的范围是从 0 到 255。如果返回一个负数，则会以 &lt;a href=&#34;https://en.wikipedia.org/wiki/Two%27s_complement&#34;&gt;补码&lt;/a&gt; 的形式返回，比如 &lt;code&gt;-10&lt;/code&gt;，即二进制 &lt;code&gt;0000,1010&lt;/code&gt; 补码为 &lt;code&gt;1111,0101 + 1&lt;/code&gt; = &lt;code&gt;1111,0110&lt;/code&gt;，对应的十进制为 &lt;code&gt;246&lt;/code&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;在 Linux 环境里约定程序成功退出时返回 0，失败返回非 0，注意这个跟一般编程语言里的 &lt;em&gt;Boolean&lt;/em&gt; 值约定刚好相反，所以在编写 Shell 脚本时要注意，其 &lt;code&gt;true&lt;/code&gt; 的值是 0。在 Shell 里可以通过命令 &lt;code&gt;echo $?&lt;/code&gt; 显示上一个程序的返回值，比如运行命令 &lt;code&gt;true; echo $?&lt;/code&gt; 将会看到数字 0。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;在每篇文章的目录里我都会创建一个名为 &lt;code&gt;resources&lt;/code&gt; 的文件夹，其中存放着该篇文章所有示例的源代码，有需要的可以到 &lt;a href=&#34;https://github.com/hemashushu/hemashushu.github.io/tree/main/src/content/posts&#34;&gt;我 Blog 的 Github 源代码仓库&lt;/a&gt; 下载。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 id=&#34;42-交叉编译&#34;&gt;4.2 交叉编译&lt;/h3&gt;&lt;p&gt;GNU Toolchain 当中的编译、汇编、链接的程序分别是 &lt;code&gt;gcc&lt;/code&gt;，&lt;code&gt;as&lt;/code&gt; 和 &lt;code&gt;ld&lt;/code&gt;，如果需要本地编译，则直接输入这些程序名即可。在交叉编译时，则需要在对应的命令名称添加一个前缀。在当前的例子里，前缀是 &lt;code&gt;riscv64-linux-gnu-&lt;/code&gt;，所以交叉编译的命令如下：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ riscv64-linux-gnu-gcc -g -Wall -o app.elf app.c&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;各个参数的含义如下：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;-g&lt;/code&gt;：用于生成供 GDB 使用的调试信息，调试信息包括源代码当中的变量名称，指令对应的源代码的位置（行数）等。额外的调试信息会保持在输出文件里面。虽然在当前例子里暂时用不上调试信息，不过在平时编译时都加上 &lt;code&gt;-g&lt;/code&gt; 参数可以培养良好的习惯；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;-Wall&lt;/code&gt;：用于报告编译过程中的所有警告信息，比如声明了局部变量却没使用，或者某个变量只赋值却从未被读取等，这些警告信息有助于书写良好的代码。类似的参数还有 &lt;code&gt;-Wextra&lt;/code&gt;，它能打开除了 &lt;code&gt;all&lt;/code&gt; 之外的更多的警告开关，比如将 &lt;code&gt;int&lt;/code&gt; 类型和 &lt;code&gt;unsigned int&lt;/code&gt; 类型的变量进行比较时，&lt;code&gt;-Wextra&lt;/code&gt; 会输出提示。&lt;a href=&#34;https://gcc.gnu.org/onlinedocs/gcc/Warning-Options.html&#34;&gt;详细列表可以参见 GCC 3.8 Options to Request or Suppress Warnings&lt;/a&gt;；&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote&gt;&lt;p&gt;有时编译一些旧代码时会报告一些错误并导致编译中断，但旧版本的编译器却可以顺利完成，这有可能是因为新版本的编译器引入了新的错误检查规则，或者某些规则在旧版本编译器里只是警告而不是错误。如果你没办法修改源代码，则可以通过在编译命令后添加 &lt;code&gt;-Wno-error=...&lt;/code&gt; 参数让编译器暂时忽略指定的规则，比如 &lt;code&gt;-Wno-error=int-conversion&lt;/code&gt; 可以让指针类型的值赋值给整型的变量或者传递给整型的参数。当然这是在没有别的办法的情况下才使用的方法。相反地，可以通过添加 &lt;code&gt;-Werror=...&lt;/code&gt; 参数让某些规则从提示级别上升为错误级别。&lt;/p&gt;&lt;/blockquote&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;-o app.elf&lt;/code&gt;：用于指定输出的文件的名称，如果缺省这个参数，默认的输出文件名为 &lt;code&gt;a.out&lt;/code&gt;。注意 &lt;code&gt;-o app.elf&lt;/code&gt; 是一个完整的参数，而随后的 &lt;code&gt;app.c&lt;/code&gt; 并不属于这个参数的一部分。&lt;/li&gt;&lt;/ul&gt;&lt;blockquote&gt;&lt;p&gt;在 Linux 系统里，可执行文件的的扩展名可以随意，这跟 Windows 系统里可执行文件的扩展名必须是 &lt;code&gt;exe&lt;/code&gt; 的情况不同。&lt;/p&gt;&lt;/blockquote&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;app.c&lt;/code&gt;：是源代码文件的名称。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;编译完成后得到文件 &lt;code&gt;app.elf&lt;/code&gt;。&lt;/p&gt;&lt;h3 id=&#34;43-elf-格式&#34;&gt;4.3 ELF 格式&lt;/h3&gt;&lt;p&gt;ELF 是二进制可执行文件的一种格式，比如上一步得到的 &lt;code&gt;app.elf&lt;/code&gt; 就是 ELF 格式的文件。下面使用 &lt;code&gt;file&lt;/code&gt; 命令查看输出文件 &lt;code&gt;app.elf&lt;/code&gt; 的格式信息：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ file app.elf&lt;/code&gt;&lt;/p&gt;&lt;p&gt;输出结果大致如下：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;app.elf: ELF 64-bit LSB pie executable, UCB RISC-V, RVC, double-float ABI, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux-riscv64-lp64d.so.1, BuildID[sha1]=afe0994d7df77dc817058ae17e814d8f0a4163ed, for GNU/Linux 4.15.0, with debug_info, not stripped&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上面一段文本部分内容的含义是：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;ELF&lt;/code&gt; 和 &lt;code&gt;executable&lt;/code&gt;：表明当前文件是一个 &lt;em&gt;ELF 文件格式&lt;/em&gt; 当中的 &lt;em&gt;可执行文件&lt;/em&gt;。ELF 格式有 3 种类型：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;code&gt;executable&lt;/code&gt;：&lt;em&gt;可执行文件&lt;/em&gt;，这是最常见的一种类型。注意在 Linux 系统里有些可执行文件并不是 ELF 格式，它们只是添加了可执行权限的脚本文件，其内容是文本而不是二进制指令和数据；&lt;/li&gt;&lt;li&gt;&lt;code&gt;shared object&lt;/code&gt;：&lt;em&gt;共享对象文件&lt;/em&gt;，也就是共享库。用于在运行时动态地链接到程序。目录 &lt;code&gt;/lib&lt;/code&gt; 和 &lt;code&gt;/usr/lib&lt;/code&gt; 里面那一堆 &amp;ldquo;*.so&amp;rdquo; 文件就是这种类型。&lt;/li&gt;&lt;li&gt;&lt;code&gt;relocatable&lt;/code&gt;：&lt;em&gt;可重定位文件&lt;/em&gt;，即编译任务中途产生的文件。上面的 GCC 编译命令在背后大致做了两件事：将 C 源代码转换为一系列机器指令并保存在可重定位文件里，这个过程称为 &lt;em&gt;编译&lt;/em&gt;；另一件事是把一个或多个可重定位文件连接成为一个可执行文件或者共享库，这个过程称为 &lt;em&gt;链接&lt;/em&gt;。&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;dynamically linked&lt;/code&gt;, &lt;code&gt;interpreter ...&lt;/code&gt;：表明当前可执行文件是 &lt;em&gt;动态链接&lt;/em&gt; 类型，也就是说它在运行时，需要其它共享库的帮忙才能完成工作。而这些库的加载和初始化任务则由 &lt;code&gt;interpreter&lt;/code&gt; 指定的程序来完成，这个程序也叫 &lt;em&gt;运行时动态链接器&lt;/em&gt;，这个程序通常是 &lt;code&gt;/usr/bin/ld.so&lt;/code&gt;（虽然这个程序的扩展名是 &lt;code&gt;so&lt;/code&gt;，看起来像一个共享库，不过它却是可执行文件，之所以添加了 &lt;code&gt;so&lt;/code&gt; 后缀，估计是为了区分 &lt;em&gt;静态链接&lt;/em&gt; 程序 &lt;code&gt;ld&lt;/code&gt;）。可执行文件还可以是 &lt;em&gt;静态链接（statically linked）&lt;/em&gt; 类型，表示它在运行时不需要其它共享库帮忙，它自己就能完成所有工作。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;pie&lt;/code&gt;：表明当前的可执行文件是 &lt;em&gt;位置无关的可执行文件&lt;/em&gt;（&lt;em&gt;Position Independent Executables&lt;/em&gt;），这部分内容以后会详细讲解。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;64-bit&lt;/code&gt;, &lt;code&gt;RISC-V&lt;/code&gt;, &lt;code&gt;double-float ABI&lt;/code&gt;，&lt;code&gt;GNU/Linux 4.15.0&lt;/code&gt;：这些信息表明当前可执行文件的目标架构、目标平台以及目标平台的一些细致信息。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;LSB&lt;/code&gt;：表明当前文件里的数据是 &lt;em&gt;低端字节&lt;/em&gt; 优先（&lt;em&gt;least-significant byte&lt;/em&gt; first）的，也就是平常说的 &lt;em&gt;低端序&lt;/em&gt;（&lt;em&gt;little-endian&lt;/em&gt;）。跟 &lt;code&gt;LSB&lt;/code&gt; 相反的是 &lt;code&gt;MSB&lt;/code&gt;，即 &lt;em&gt;高端字节&lt;/em&gt; 优先（&lt;em&gt;most-significant byte&lt;/em&gt; first），也就是平常说的 &lt;em&gt;高端序&lt;/em&gt;（&lt;em&gt;big-endian&lt;/em&gt;）。字节顺序决定了一个整数（比如 int32 和 int64 等必须由多个字节组成的整数）在内存或者磁盘中如何储存。比如数字 &lt;code&gt;0x11223344&lt;/code&gt;，如果在内存中使用 &lt;code&gt;LSB&lt;/code&gt; 存储，则各个字节的排列顺序为 &amp;ldquo;(开始) 44 33 22 11&amp;rdquo;，如果使用 &lt;code&gt;MSB&lt;/code&gt; 存储，则排列顺序为 &amp;ldquo;(开始) 11 22 33 44&amp;rdquo;。用十六进制查看器查看 &lt;code&gt;LSB&lt;/code&gt; 字节序的可执行文件的内容时，如果看的内容是整数，那么需要在脑海里把整数当中的各个字节顺序反过来再组合才是它的真实值，而如果看的内容是字符串，则可以按看到的顺序阅读。简单来说，看数字需要反转一次，而文本内容（仅限 ASCII 文本）则可以直接阅读，而 &lt;code&gt;MSB&lt;/code&gt; 则刚好相反。不过这都是人类才有的烦恼，对于计算机来说都是一样的。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;with debug_info&lt;/code&gt;, &lt;code&gt;not stripped&lt;/code&gt;：表明当前可执行文件里包含调试信息。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;code&gt;file&lt;/code&gt; 命令只能非常粗略地查看文件的格式和基本信息，如果想查看可执行文件的详细内容，需要 GNU Toolchain 里面一组叫做 &lt;a href=&#34;https://www.gnu.org/software/binutils/&#34;&gt;GNU Binutils&lt;/a&gt; 的工具，后面的章节会详细讲解。&lt;/p&gt;&lt;h2 id=&#34;5-运行&#34;&gt;5. 运行&lt;/h2&gt;&lt;p&gt;如果你尝试直接运行上面编译得到的 &lt;code&gt;app.elf&lt;/code&gt;，就会发现它没法正常运行。这是因为该可执行文件的目标架构是 RISC-V（这里假设你当前的机器不是 RISC-V 架构的），为了运行该程序，比较方便的方法是使用模拟器（emulator）来模拟一个 RISC-V 的机器。&lt;/p&gt;&lt;p&gt;一般大家熟知的 &lt;em&gt;虚拟机软件&lt;/em&gt;（&lt;em&gt;virtualization software&lt;/em&gt;，严格来说应该翻译作 &lt;em&gt;虚拟化软件&lt;/em&gt;），比如 VirtualBox、VMWare 等只能虚拟一台跟主机（host machine）架构一样的机器，也就是说，这些软件所提供的虚拟处理器（CPU）实际上是由主机上 CPU 硬件提供的。如果需要虚拟一台不同架构的机器，则需要使用模拟器，比如 &lt;a href=&#34;https://www.qemu.org/&#34;&gt;QEMU&lt;/a&gt; 来实现。模拟器使用软件来模拟目标 CPU，然后再模拟一些诸如网络接口、图形接口、固态存储驱动器等外设，从而封装形成一台虚拟的机器。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;请注意在编程语言的运行时（runtime）里也时常提到虚拟机（vm，virtual machine）这个名称，这是跟上述的模拟器比较接近的概念。就是运行时模拟了一个比较理想化的处理器（这个处理器跟主机上的处理器在架构上完全没关联），然后让这个处理器来执行特定编程语言编译出来的字节码。跟模拟器不同的是，vm 仅模拟处理器，而对于系统的调用和硬件的调用，都是直接重定向到主机的，所以 vm 并不是完整的一台机器。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 id=&#34;51-安装-qemu&#34;&gt;5.1 安装 QEMU&lt;/h3&gt;&lt;p&gt;QEMU 是一款开源免费的软件，在大部分 Linux 发行版里的包仓库里都包含有 QEMU，所以只需使用系统的包管理器就可以安装 QEMU。在 &lt;em&gt;Arch Linux&lt;/em&gt; 里，软件包是：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;qemu-system-riscv&lt;/li&gt;&lt;li&gt;qemu-user&lt;/li&gt;&lt;li&gt;qemu-user-static&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;在 &lt;em&gt;Debian&lt;/em&gt;/&lt;em&gt;Ubuntu&lt;/em&gt; 里，软件包是：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;qemu-system&lt;/li&gt;&lt;li&gt;qemu-user&lt;/li&gt;&lt;li&gt;qemu-user-static&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;对于包仓库里没有 QEMU 的发行版，可以下载 QEMU 的源代码，然后根据&lt;a href=&#34;https://wiki.qemu.org/Documentation/Platforms/RISCV&#34;&gt;这篇指引&lt;/a&gt;编译安装。&lt;/p&gt;&lt;p&gt;QEMU 可以模拟一整套完整的硬件，包括 CPU、内存、磁盘、网络接口等组件，在这种模式下可以执行所有 CPU 指令，可以运行裸机程序，这种工作模式称为 &lt;em&gt;全系统模式&lt;/em&gt;；除此之外，QEMU 还可以模拟一个独立的 Linux 系统，在这种模式下可以直接运行编译目标架构不同的 Linux 应用程序，这种工作模式称为 &lt;em&gt;用户模式&lt;/em&gt;。在这种模式下，QEMU 会把应用程序当中的指令动态地转换为主机架构的指令，当然同时会转换程序当中的系统调用。&lt;/p&gt;&lt;p&gt;全系统模式使用程序 &lt;code&gt;qemu-system-riscv64&lt;/code&gt; 来启动，通过命令行参数指定机器类型、CPU 核心的数量、内存的容量、虚拟磁盘等配置。用户模式使用程序 &lt;code&gt;qemu-riscv64&lt;/code&gt; 来启动，把我们写的应用程序（可执行文件）的文件路径作为参数传给 &lt;code&gt;qemu-riscv64&lt;/code&gt; 即可。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;QEMU 出自一位颇具传奇色彩的程序员 &lt;a href=&#34;https://bellard.org/&#34;&gt;Fabrice Bellard&lt;/a&gt; 之手，他写的 &lt;a href=&#34;http://ffmpeg.org/&#34;&gt;FFmpeg&lt;/a&gt; 几乎存在每一台计算机里（尽管可能很多人都不知道，但却是真的），大部分媒体播放器软件及视频编辑软件都依赖它，另外他还写了 TCC、QuickJS 等出名的程序。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 id=&#34;52-尝试运行程序&#34;&gt;5.2 尝试运行程序&lt;/h3&gt;&lt;p&gt;如果使用全系统模式运行我们的程序，还需要给虚拟机配置系统引导器、一个包含有 RISC-V 架构版本的 Linux 系统的虚拟磁盘，另外还需要把应用程序复制进虚拟系统等。所以为了快速把上面写的 &amp;ldquo;Hello, World!&amp;rdquo; 程序跑起来，下面使用用户模式来运行：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ qemu-riscv64 app.elf&lt;/code&gt;&lt;/p&gt;&lt;p&gt;运行的结果是：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;qemu-riscv64: Could not open &amp;#39;/lib/ld-linux-riscv64-lp64d.so.1&amp;#39;: No such file or directory&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;显然程序并没有正确地运行。GCC 默认产生动态链接类型的程序，这种程序在运行时需要一个 &lt;em&gt;运行时动态链接器&lt;/em&gt; 来加载程序所需的共享库，以及进行一系列的初始化工作。运行时动态链接器即程序 &lt;code&gt;ld.so&lt;/code&gt;，在当前的例子里，它就是错误信息里显示的那个 &lt;code&gt;/lib/ld-linux-riscv64-lp64d.so.1&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;GCC 默认产生的程序是假定在 &amp;ldquo;普通的 Linux 系统&amp;rdquo; 里运行，而当前我们是在 &lt;em&gt;QEMU 用户模式&lt;/em&gt; 这种特殊的环境里。从 &amp;ldquo;Hello, World!&amp;rdquo; 程序的角度来看，它并不知道自己运行在特殊的环境里，而以为运行在一个 RISC-V 架构的 Linux 系统里，所以就如同往常一样，寻找动态链接器 &lt;code&gt;/lib/ld-linux-riscv64-lp64d.so.1&lt;/code&gt;。而实际上我们当前环境（作者的机器）的是 &lt;em&gt;x86_64&lt;/em&gt; 版的 Linux 系统，动态链接器是 &lt;code&gt;/lib/ld-linux-x86-64.so.2&lt;/code&gt;。QEMU 用户模式仅转换 CPU 指令，而不会转换其它数据比如文件路径，所以程序运行失败。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;你可能已经发现 &lt;code&gt;./app.elf&lt;/code&gt; 是可以直接运行的，而且产生的错误信息也是一样的！那是因为 Linux 内核通过 &lt;a href=&#34;https://www.kernel.org/doc/html/latest/admin-guide/binfmt-misc.html&#34;&gt;MISC binary&lt;/a&gt; 特性支持执行那些需要解析器的程序。查看文件 &lt;code&gt;/proc/sys/fs/binfmt_misc/qemu-riscv64&lt;/code&gt; 可知当你从命令行直接运行 &lt;code&gt;./app.elf&lt;/code&gt; 时，实际上调用的是命令 &lt;code&gt;/usr/bin/qemu-riscv64-static ./app.elf&lt;/code&gt;。&lt;code&gt;qemu-riscv64-static&lt;/code&gt; 除了它本身是静态链接之外，其功能跟上面的 &lt;code&gt;qemu-riscv64&lt;/code&gt; 是一样的。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 id=&#34;53-指定动态链接器路径&#34;&gt;5.3 指定动态链接器路径&lt;/h3&gt;&lt;p&gt;如果你的系统是 &lt;em&gt;Arch Linux&lt;/em&gt;，并且安装了软件包 &lt;code&gt;riscv64-linux-gnu-glibc&lt;/code&gt;，会发现系统里的确存在文件 &lt;code&gt;ld-linux-riscv64-lp64d.so.1&lt;/code&gt;，但它的路径是 &lt;code&gt;/usr/riscv64-linux-gnu/lib/ld-linux-riscv64-lp64d.so.1&lt;/code&gt;。按照 &lt;code&gt;qemu-riscv64&lt;/code&gt; 的说明，通过参数 &lt;code&gt;-L&lt;/code&gt; 或者环境变量 &lt;code&gt;QEMU_LD_PREFIX&lt;/code&gt; 传入一个路径，QEMU 就会把这个路径作为前缀添加到 ELF 的 &lt;code&gt;interpreter&lt;/code&gt; 指定的程序的前面。&lt;/p&gt;&lt;p&gt;因此可以这样运行 &amp;ldquo;app.elf&amp;rdquo; 程序：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;$ qemu-riscv64 -L /usr/riscv64-linux-gnu/ app.elf&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;$ QEMU_LD_PREFIX=/usr/riscv64-linux-gnu/ qemu-riscv64 app.elf&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;如无意外，上面两个命令都能正确运行，能看到程序输出的 &amp;ldquo;Hello, World!&amp;rdquo; 文本。&lt;/p&gt;&lt;p&gt;&lt;img src=&#34;./images/qemu-user.png&#34; alt=&#34;QEMU User Mode&#34;&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;在 Linux 系统里，可以使用 &lt;code&gt;locate&lt;/code&gt; 命令快速定位所需的文件，比如命令 &lt;code&gt;$ locate lp64d.so.1&lt;/code&gt; 可以帮你找到动态链接器的路径。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 id=&#34;54-编译为静态链接类型的程序&#34;&gt;5.4 编译为静态链接类型的程序&lt;/h3&gt;&lt;p&gt;除了通过指定 &lt;em&gt;QEMU 用户模式&lt;/em&gt; 的动态链接器来运行程序之外，还有另外一个方法，就是让 GCC 生成静态链接类型的可执行文件。&lt;/p&gt;&lt;p&gt;所谓静态链接程序，就是把外部函数的二进制代码（即指令序列）在编译时复制到目标可执行文件里，这样程序在运行时就不再需要其它共享库，当然也就不再需要动态链接器 &lt;code&gt;ld.so&lt;/code&gt; 了。在 GCC 编译命令里添加 &lt;code&gt;-static&lt;/code&gt; 参数可指示 GCC 生成静态链接的程序，修改后的编译命令如下：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ riscv64-linux-gnu-gcc -static -o app-static.elf app.c&lt;/code&gt;&lt;/p&gt;&lt;p&gt;先使用 &lt;code&gt;file&lt;/code&gt; 命令查看文件的格式：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ file app-static.elf&lt;/code&gt;&lt;/p&gt;&lt;p&gt;输出的部分结果如下：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;app-static.elf: ... statically linked ...&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可见原先的 &amp;ldquo;dynamically linked&amp;rdquo; 已经变为 &amp;ldquo;statically linked&amp;rdquo;。&lt;/p&gt;&lt;p&gt;然后用 &lt;code&gt;qemu-riscv64&lt;/code&gt; 运行这个程序：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ qemu-riscv64 app-static.elf&lt;/code&gt;&lt;/p&gt;&lt;p&gt;这次不需要参数 &lt;code&gt;-L&lt;/code&gt; 或者环境变量 &lt;code&gt;QEMU_LD_PREFIX&lt;/code&gt; 就能正确运行 &amp;ldquo;Hello, World!&amp;rdquo; 程序了。这是因为，静态链接类型的程序不需要任何外界的共享库，程序自己负责实现所有的功能，自己实现不了的功能则通过 &lt;em&gt;系统调用&lt;/em&gt; 向内核求助。换句话说，对于静态链接类型的程序，除非它需要读写硬盘上的文件，否则它完全无视当前的文件系统。&lt;/p&gt;&lt;p&gt;既然静态类型的程序在使用时这么自由这么方便，为什么不把所有的程序都编译成静态链接类型的呢？让我们比较同一个 &amp;ldquo;Hello, World!&amp;rdquo; 程序的动态链接类型和静态链接类型的文件大小：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ ls -lh&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;total 668K&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-rw-r--r-- 1 yang yang   78 Nov 26 04:00 app.c&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-rwxr-xr-x 1 yang yang 9.8K Nov 27 13:38 app.elf&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-rwxr-xr-x 1 yang yang 645K Nov 27 21:40 app-static.elf&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;结果显示动态类型的程序大小是 &lt;code&gt;9.8K&lt;/code&gt;，而静态类型的程序是 &lt;code&gt;645K&lt;/code&gt;，后者比前者大了许多，那是因为编译器把 &lt;code&gt;printf&lt;/code&gt; 函数所需要的函数的代码（即二进制指令）都复制到目标可执行文件里头了。静态链接类型的程序不止体积大，加载时也会消耗更多的时间，在运行时也会占用更多的内存。而同一个动态共享库在一个系统里只需加载一次，然后通过内存映射的方式共享给所有应用程序使用。因此动态链接类型的程序加载速度快，占用内存少。当一个程序直接或间接引用很多库时，这两者的区别会更大。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;em&gt;动态链接&lt;/em&gt; 对系统来说是个不错的机制，但它带来的问题也相当令人头痛。在日常使用 Linux 经验里，很少有程序能下载即能运行，大部分情况都会出现共享库找不到或者版本不匹配等错误。如果要安装一个在软件包仓库里不存在的程序，则只能通过编译源代码的方式来安装了，这种方式对于普通用户（非专业用户）来说无疑难度太大。作者认为这个问题是因为过度使用共享库引起的，很多细小且不是很通用的库实际上没必要作为共享库。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;我们即将要实现的操作系统，将完全禁止用户向系统添加全局的共享库，全局共享库仅限非常通用且有必要的库，并由内核维护者来维护。而且应用程序也应该相互隔离，即一个程序自带的共享库只能由程序自己或者子程序使用，而不能提供给其它程序使用。以此机制从根本上解决共享库带来的便携性问题，减少应用程序分发、用户安装和使用的麻烦，并且再也不需要第三方维护者，应用程序的更新将会更加有效、及时。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 id=&#34;55-改变程序的动态链接器&#34;&gt;5.5 改变程序的动态链接器&lt;/h3&gt;&lt;p&gt;除了上面的两种方法，还能通过修改程序的动态链接器来让程序运行起来。具体来说就是在编译时传入链接参数 &lt;code&gt;--dynamic-linker&lt;/code&gt; 以更改程序的 &lt;code&gt;interpreter&lt;/code&gt; 值，命令如下：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ riscv64-linux-gnu-gcc -g -Wall -Wl,--dynamic-linker,/usr/riscv64-linux-gnu/lib/ld-linux-riscv64-lp64d.so.1 -o app-inter.elf app.c -L /usr/riscv64-linux-gnu/lib -lc&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;命令当中的参数 &lt;code&gt;-Wl,--dynamic-linker,...&lt;/code&gt; 的作用是向链接器传递参数；参数 &lt;code&gt;-L ...&lt;/code&gt; 用于指定链接器搜索共享库的路径；参数 &lt;code&gt;-lc&lt;/code&gt; 用于指定链接共享库 &lt;code&gt;libc.so&lt;/code&gt;。这些参数在后面的章节还会详细讲解。&lt;/p&gt;&lt;p&gt;编译完毕之后，使用 &lt;code&gt;file&lt;/code&gt; 命令检查程序：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ file app-inter.elf&lt;/code&gt;&lt;/p&gt;&lt;p&gt;输出的部分结果如下：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;app-inter.elf: ... interpreter /usr/riscv64-linux-gnu/lib/ld-linux-riscv64-lp64d.so.1 ...&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可见程序的 &lt;code&gt;interpreter&lt;/code&gt; 已经更改为指定的路径了。然而运行这程序时又有新的错误提示：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ qemu-riscv64 app-inter.elf&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;app-inter.elf: error while loading shared libraries: libc.so.6: cannot open shared object file: No such file or directory&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;看来 RISC-V 版的 &lt;code&gt;ld.so&lt;/code&gt; 已经起作用了，但这个动态链接器找不到 RISC-V 版的共享库 &lt;code&gt;libc.so.6&lt;/code&gt;。这个问题比较好解决，只要通过环境变量 &lt;code&gt;LD_LIBRARY_PATH&lt;/code&gt; 就可以指定程序所依赖的共享库的路径，例如：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ LD_LIBRARY_PATH=/usr/riscv64-linux-gnu/lib qemu-riscv64 app-inter.elf&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&#34;./images/interpreter-path.png&#34; alt=&#34;Interpreter Path&#34;&gt;&lt;/p&gt;&lt;p&gt;程序同样能正确运行。不过这种方法并没有太大用处，因为比前面两种方法复杂太多，而且生成的程序只适合在当前机器上 &lt;em&gt;QEMU 用户模式&lt;/em&gt; 里运行，没法在标准的 RISC-V 架构的 Linux 环境里运行。这里主要是为了演示如何修改程序的 &lt;code&gt;interpreter&lt;/code&gt;。有关动态链接器的详细资料可以通过命令 &lt;code&gt;$ man ld.so&lt;/code&gt; 调出文档查看。&lt;/p&gt;&lt;h2 id=&#34;6-分阶段编译&#34;&gt;6. 分阶段编译&lt;/h2&gt;&lt;p&gt;当执行命令 &lt;code&gt;riscv64-linux-gnu-gcc&lt;/code&gt; 将一个 C 源代码编译为一个可执行文件时，实际上 GCC 是分 4 个阶段（或者说步骤）来完成的：&lt;/p&gt;&lt;p&gt;&lt;img src=&#34;images/gcc-compile-stage.png&#34; alt=&#34;GCC compile stages&#34;&gt;&lt;/p&gt;&lt;h3 id=&#34;61-预处理&#34;&gt;6.1 预处理&lt;/h3&gt;&lt;p&gt;将源代码里 &lt;code&gt;#include ...&lt;/code&gt; 指定的文件复制进来，然后解析其中的条件编译指令（&lt;code&gt;#ifdef&lt;/code&gt;），展开宏（&lt;code&gt;macro&lt;/code&gt;）等。相当于命令：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ riscv64-linux-gnu-cpp app.c &amp;gt; app.i&lt;/code&gt;&lt;/p&gt;&lt;p&gt;或者&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ riscv64-linux-gnu-gcc -E app.c &amp;gt; app.i&lt;/code&gt;&lt;/p&gt;&lt;p&gt;经过预处理的 C 语言源代码文件的扩展名为 &lt;code&gt;*.i&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;注意程序 &lt;code&gt;riscv64-linux-gnu-cpp&lt;/code&gt; 当中的 &amp;ldquo;cpp&amp;rdquo; 是指 &amp;ldquo;C Preprocessor&amp;rdquo;，而不是 &amp;ldquo;C++&amp;rdquo; 的意思。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;通过 GCC 命令的 &lt;code&gt;-D&lt;/code&gt; 参数可以传递选项值到 C 代码里，用于控制代码里的条件编译指令的开关。比如 &lt;code&gt;-D DEBUG&lt;/code&gt;（等同于 &lt;code&gt;-D DEBUG=1&lt;/code&gt;）能让 C 代码里的条件编译指令 &lt;code&gt;#ifdef DEBUG ...&lt;/code&gt; 的条件值为 &lt;code&gt;真&lt;/code&gt;，详细请参阅 &lt;a href=&#34;https://gcc.gnu.org/onlinedocs/gcc/Preprocessor-Options.html&#34;&gt;GCC Preprocessor&lt;/a&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 id=&#34;62-编译&#34;&gt;6.2 编译&lt;/h3&gt;&lt;p&gt;将 C 源代码编译为汇编源代码，相当于命令：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ riscv64-linux-gnu-gcc -S app.i&lt;/code&gt;&lt;/p&gt;&lt;p&gt;生成的汇编源代码文件的扩展名为 &lt;code&gt;*.s&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;注意我们手写汇编源代码的文件扩展名一般是 &lt;code&gt;*.S&lt;/code&gt;（大写 &lt;code&gt;S&lt;/code&gt;），&lt;code&gt;*.S&lt;/code&gt; 文件在汇编时会进行预处理（比如处理 &lt;code&gt;.include&lt;/code&gt; 指令），而扩展名为 &lt;code&gt;*.s&lt;/code&gt;（小写 &lt;code&gt;s&lt;/code&gt;）则不会进行预处理。具体的扩展名和 GCC 参数可以参考&lt;a href=&#34;https://gcc.gnu.org/onlinedocs/gcc/Overall-Options.html&#34;&gt;GCC Options Controlling the Kind of Output&lt;/a&gt;。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;第 1 到第 2 步也可以合并为一步完成：&lt;code&gt;$ riscv64-linux-gnu-gcc -S app.c&lt;/code&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 id=&#34;63-汇编&#34;&gt;6.3 汇编&lt;/h3&gt;&lt;p&gt;将汇编源代码转换为机器指令序列，生成 &lt;em&gt;可重定位文件&lt;/em&gt;，相当于命令：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ riscv64-linux-gnu-as -o app.o app.s&lt;/code&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;第 1 到第 3 步也可以合并为一步完成：&lt;code&gt;$ riscv64-linux-gnu-gcc -c -o app.o app.c&lt;/code&gt;，参数 &lt;code&gt;-c&lt;/code&gt; 表示只编译但不链接。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 id=&#34;64-链接&#34;&gt;6.4 链接&lt;/h3&gt;&lt;p&gt;将一个或多个 &lt;em&gt;可重定位文件&lt;/em&gt; 连接起来，并重新定位其中的全局变量、静态变量和函数的地址，最后生成 ELF 格式的可执行文件，相当于命令：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ riscv64-linux-gnu-ld -o app.elf startup.o app.o&lt;/code&gt;&lt;/p&gt;&lt;p&gt;上面的命令会将 &lt;code&gt;startup.o&lt;/code&gt; 和 &lt;code&gt;app.o&lt;/code&gt; 两个文件链接起来生成可执行文件 &lt;code&gt;app.elf&lt;/code&gt;。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;code&gt;startup.o&lt;/code&gt; 是应用程序启动器，提供应用的入口 &lt;code&gt;_start&lt;/code&gt; 过程以及做一些初始化和清理工作，将会在下一章实现它。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;上面 4 个步骤就是命令 &lt;code&gt;$ riscv64-linux-gnu-gcc -o app.elf app.c&lt;/code&gt; 在背后进行的一系列操作，如果想知道 GCC 在编译过程中的每个步骤以及细节，可以传入 &lt;code&gt;-v&lt;/code&gt; 参数，比如 &lt;code&gt;$ riscv64-linux-gnu-gcc -v -o app.elf app.c&lt;/code&gt;，这样 GCC 会把每一步的操作都显示出来。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;在平常的编译程序任务中，我们并不需要分成 4 步。一般只需分成两个阶段：即从第 1 到第 3 步合并为 &lt;em&gt;编译&lt;/em&gt; 阶段，第 4 步则是 &lt;em&gt;链接&lt;/em&gt; 阶段。而且一般都是借助诸如 &lt;code&gt;make&lt;/code&gt; 等构建工具来完成这两个阶段。但我们仍然需要清楚知道编译过程背后有哪些步骤及其作用，理解这些概念有助于解决在编译过程遇到的各种问题。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&#34;7-常用的编译参数&#34;&gt;7. 常用的编译参数&lt;/h2&gt;&lt;p&gt;GCC 还有一些其它常用的参数：&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;-I&lt;/code&gt; 用于指定编译时的头文件的路径&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;有时头文件（&lt;code&gt;*.h&lt;/code&gt;）分布在多个目录，这时可以用参数 &lt;code&gt;-I&lt;/code&gt; 把额外的头文件的路径包含进来，比如当前的路径为 &lt;code&gt;/home/yang/hello-world/app.c&lt;/code&gt;，假如有额外的头文件位于 &lt;code&gt;/home/yang/hello-world/include/&lt;/code&gt;，则可以这样传入参数：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ riscv64-linux-gnu-gcc -I /home/yang/hello-world/include app.c&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;-L&lt;/code&gt; 和 &lt;code&gt;-l&lt;/code&gt; 分别用于指定链接时额外库的路径和名称&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;接着上一个例子，如果应用程序需要使用到共享库 &lt;code&gt;/usr/lib/hello-world/libmymath.so&lt;/code&gt;，则可以这样传入参数：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ riscv64-linux-gnu-gcc app.c -L /usr/lib/hello-world/ -lmymath&lt;/code&gt;&lt;/p&gt;&lt;p&gt;参数 &lt;code&gt;-lmymath&lt;/code&gt; 表示链接过程会使用到共享库 &lt;code&gt;libmymath.so&lt;/code&gt;。注意参数 &lt;code&gt;-l&lt;/code&gt; 的值不是库的文件名，而是库的 &amp;ldquo;soname&amp;rdquo;。比如上面例子中共享库文件的真实名称是 &lt;code&gt;libmymath.so&lt;/code&gt;，去除了前缀 &lt;code&gt;lib&lt;/code&gt; 和后缀 &lt;code&gt;.so&lt;/code&gt; 之后就是 &amp;ldquo;soname&amp;rdquo; 了。如此类推，&lt;code&gt;-lm&lt;/code&gt; 表示共享库 &lt;code&gt;libm.so&lt;/code&gt;，&lt;code&gt;-lpthread&lt;/code&gt; 表示共享库 &lt;code&gt;libpthread.so&lt;/code&gt;。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;一般把参数 &lt;code&gt;-L ... -l ...&lt;/code&gt; 放在命令的末尾，也就是遵循 &amp;ldquo;被依赖的放在后面&amp;rdquo; 的顺序。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;如果将编译任务分为 &lt;em&gt;编译&lt;/em&gt; 和 &lt;em&gt;链接&lt;/em&gt; 两步，则在编译阶段只需指定 &lt;code&gt;-I&lt;/code&gt; 参数，而链接阶段只需指定 &lt;code&gt;-L&lt;/code&gt; 和 &lt;code&gt;-l&lt;/code&gt; 参数，因为头文件仅供预处理使用的，对链接无意义，而库文件则仅供链接使用，对编译无意义。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;你可能已经发现 GCC 的参数和参数值的写法跟普通的程序不太一样，比如参数 &lt;code&gt;-lmymath&lt;/code&gt;，实际上是 &lt;code&gt;-l mymath&lt;/code&gt; 的简写，即 &lt;code&gt;-l&lt;/code&gt; 是参数名称，&lt;code&gt;mymath&lt;/code&gt; 是参数值。而参数 &lt;code&gt;-static&lt;/code&gt; 按照标准的写法应该是 &lt;code&gt;--static&lt;/code&gt;，这些特殊的写法可能是历史遗留下来的。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&#34;8-总结&#34;&gt;8. 总结&lt;/h2&gt;&lt;p&gt;这章主要讲解什么是交叉编译，以及交叉编译了一个 &amp;ldquo;Hello, World!&amp;rdquo; 程序，然后使用 QEMU 模拟一个不同架构的 Linux 环境来运行交叉编译得到的可执行文件。通过这一章我们知道如何构建一个程序，同时也知道其实交叉编译并没什么特别的地方，操作方法跟普通编译几乎一样，只是编译出来的结果（可执行文件）的运行方式不太一样而已（即我们无法在当前机器上直接运行）。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;这章是我们漫长的几个系列文章当中的第一个系列的第一章，如果你发现这章里有些地方不太明白，这是很正常的。正如 &lt;a href=&#34;../2022-10-31-building-a-modern-computer-system-from-scratch-step-by-step&#34;&gt;项目介绍&lt;/a&gt; 所说，系统技术相互交叉，有些内容必须到了后面的章节才能展开。你可以继续往下阅读，到了某个阶段时再回来这里重温一遍，可能会发现一下子全都懂了。就像看悬疑电影那样，有些伏笔到了最后会自然解开。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;如果你觉得这章的内容太难了，甚至完全不知道在讲什么。可能只是因为你对 C 语言或者说一般的编程技术，以及 Linux 环境不是很熟悉，你可以适当停下来，然后看看一些经典的书籍和教程。注意学习 C 语言一定要 Linux 环境，在其它环境里学习 C 语言你只能学会语法，然后一无所知。另外请记住计算机的每门科目都不需要一下子从头到尾看完，每次看一两章就可以停下来，然后去做点别的事情或者其它科目，让你的大脑在背后慢慢地消化。如此一段时间之后再回来看这系列文章估计就没什么问题了。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;好了，如果觉得没问题那就点击下一章吧。下一章将会构建一个简单的无需操作系统就可以独自运行的程序。&lt;/p&gt;&lt;div&gt;    &lt;img src=&#34;https://hemashushu.github.io/images/subscribe-and-donate.zh.png&#34; class=&#34;block-image image-480px&#34;/&gt;&lt;/div&gt;</description>
     </item>
   
 </channel>
</rss>
