
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
 <channel>
   <title>文章 on 河马蜀黍的个人主页</title>
   <link>https://hemashushu.github.io/zh/posts/</link>
   <description>Recent content in 文章 on 河马蜀黍的个人主页</description>
   <generator>Hugo -- gohugo.io</generator>
   <language>en-us</language>
   <copyright>Copyright &amp;copy; 2022 - Hippospark</copyright>
   <lastBuildDate>Sun, 06 Nov 2022 00:00:00 +0000</lastBuildDate>
   
       <atom:link href="https://hemashushu.github.io/zh/posts/index.xml" rel="self" type="application/rss+xml" />
   
   
     <item>
       <title>S01C02 编写一个无需操作系统，可独自运行的 Hello World 程序</title>
       <link>https://hemashushu.github.io/zh/posts/2022-11-06-s01c02-write-a-program-run-alone-without-os/</link>
       <pubDate>Sun, 06 Nov 2022 00:00:00 +0000</pubDate>
       
       <guid>https://hemashushu.github.io/zh/posts/2022-11-06-s01c02-write-a-program-run-alone-without-os/</guid>
       <description>&lt;p&gt;&lt;a href=&#34;../2022-11-05-s01c01-cross-compile-and-run-the-first-program&#34;&gt;上一章&lt;/a&gt; 我们写了一个 &amp;ldquo;Hello, World!&amp;rdquo; 程序，然后用 GCC 交叉编译并使用 QEMU 模拟器成功运行。不过我们也发现程序的体积有几百KB，里面肯定有很多不是我们自己写的内容，而且它还依赖操作系统才能运行。这一章将会编写一个无需操作系统、无需任何库，即可独自运行的 &amp;ldquo;Hello, World!&amp;rdquo; 程序（这种程序叫 &lt;em&gt;裸机程序&lt;/em&gt;），然后同样会使用 GCC 交叉编译并尝试使用 QEMU 运行。通过裸机程序，我们可以了解一个完整的程序是如何组成的，同时还会了解机器通电后如何执行程序。&lt;/p&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&#34;#1-%E4%BB%80%E4%B9%88%E6%98%AF%E8%A3%B8%E6%9C%BA%E7%A8%8B%E5%BA%8F&#34;&gt;1. 什么是裸机程序？&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#%E5%A6%82%E4%BD%95%E5%90%AF%E5%8A%A8%E8%A3%B8%E6%9C%BA%E7%A8%8B%E5%BA%8F&#34;&gt;如何启动裸机程序&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#%E8%A3%B8%E6%9C%BA%E7%89%88%E7%9A%84-hello-world-%E7%A8%8B%E5%BA%8F&#34;&gt;裸机版的 &amp;ldquo;Hello, World!&amp;rdquo; 程序&lt;/a&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&#34;#%E5%A6%82%E4%BD%95%E7%9B%B4%E6%8E%A5%E8%AE%BF%E9%97%AE%E7%A1%AC%E4%BB%B6&#34;&gt;如何直接访问硬件？&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#%E9%80%9A%E8%BF%87%E4%B8%B2%E5%8F%A3%E5%8F%91%E9%80%81%E5%AD%97%E7%AC%A6&#34;&gt;通过串口发送字符&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#%E5%AE%9E%E7%8E%B0-print_string-%E5%87%BD%E6%95%B0&#34;&gt;实现 print_string 函数&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#%E4%B8%BB%E7%A8%8B%E5%BA%8F&#34;&gt;主程序&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E5%99%A8&#34;&gt;程序启动器&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#%E7%BC%96%E8%AF%91&#34;&gt;编译&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#%E9%93%BE%E6%8E%A5&#34;&gt;链接&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#%E8%BF%90%E8%A1%8C&#34;&gt;运行&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#%E6%89%93%E5%8C%85%E9%9D%99%E6%80%81%E5%BA%93&#34;&gt;打包静态库&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#%E6%80%BB%E7%BB%93&#34;&gt;总结&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;!-- raw HTML omitted --&gt;&lt;h2 id=&#34;1-什么是裸机程序&#34;&gt;1. 什么是裸机程序？&lt;/h2&gt;&lt;p&gt;&lt;em&gt;裸机程序&lt;/em&gt; 是指在 &amp;ldquo;无操作系统&amp;rdquo; 的环境中运行的程序，初一听起来可能会觉得很神奇：“一个机器不用安装操作系统也能运行程序？没有操作系统我怎样输入程序的名称，怎样启动程序？” 但仔细想想，操作系统内核，还有系统的启动引导器（比如 &lt;a href=&#34;https://www.gnu.org/software/grub/&#34;&gt;GRUB&lt;/a&gt;），它们都是在没有操作系统的情况下运行的，所以机器的确能直接运行程序。&lt;/p&gt;&lt;p&gt;其实裸机程序跟普通应用程序并没有太大的区别，其中的数值计算、流程控制、程序的结构等等跟普通应用程序是一样的，只是在进行一些特权或者 I/O 操作时，无法让操作系统代劳（因为运行环境中根本没有操作系统）,裸机程序需要自己直接跟硬件打交道。而一般的程序进行 I/O 操作时，是通过调用标准库，标准库再向操作系统发起 &lt;em&gt;系统调用&lt;/em&gt; 等一系列过程实现的。除此之外，裸机程序并不是通过文件名启动的，因为运行环境里根本没有文件系统，裸机程序通常以二进制形式存在于 ROM 或者磁盘的固定位置。&lt;/p&gt;&lt;p&gt;如果你想在裸机程序里让机器播放音乐或者访问互联网，则还得自己写声卡和网卡的硬件驱动（当然如果这些外设有开源的驱动的话就不必自己重头写）及其应用程序；如果想让机器能够一边播放音乐一边上网，那么还得写进程管理程序；如果想保存音乐文件到硬盘或者 SSD 里，则还得写文件系统；如果想让程序运行起来安全可靠一些，可能还得实现虚拟内存管理器。可见当你要求的功能越多，裸机程序就越接近一个操作系统，操作系统内核就是一个典型的裸机程序。当然如果你只是想让机器做一些很简单的事情，裸机程序也可以极其简单，比如下面要写的 &amp;ldquo;Hello, World!&amp;rdquo; 程序。&lt;/p&gt;&lt;p&gt;另外在微控制器（MCU）里运行的程序（通常称为 &lt;em&gt;固件&lt;/em&gt;，&lt;em&gt;firmware&lt;/em&gt;）也是裸机程序，因为微控制器的资源很少，没法运行一个操作系统，因此程序是独自运行的。（有一种程序叫 &lt;em&gt;实时操作系统&lt;/em&gt;，&lt;em&gt;RTOS&lt;/em&gt;，通常是以库的形式存在，跟通常概念里的操作系统不同）&lt;/p&gt;&lt;h2 id=&#34;如何启动裸机程序&#34;&gt;如何启动裸机程序&lt;/h2&gt;&lt;p&gt;机器通电之后 CPU 会从某个固定的内存地址开始执行第一条指令，这个内存地址一般对应着一段固定在 ROM 芯片里的 &lt;em&gt;加载程序&lt;/em&gt;（&lt;em&gt;loader&lt;/em&gt;）或硬件初始化程序（比如 BIOS），然后加载程序会尝试从约定的几个地方加载 &lt;em&gt;引导程序&lt;/em&gt;（&lt;em&gt;boot loader&lt;/em&gt;）并跳转到该引导程序的第一条指令（简称 &lt;em&gt;入口&lt;/em&gt;），引导程序再加载 &lt;em&gt;内核&lt;/em&gt; 并跳转到内核的入口。&lt;/p&gt;&lt;p&gt;需要注意的是并不是每一台机器通电后的过程都一样的，有些硬件平台可能只有其中的一个或两个步骤，有些则可能会有更多的步骤。但有一点是确定的：每个程序的位置和入口都是上一个环节约定的，所以要让机器运行我们写的裸机程序，只需把这个程序放置在预留给 &lt;em&gt;引导程序&lt;/em&gt; 或者 &lt;em&gt;内核&lt;/em&gt; 的位置，这样就可以 &amp;ldquo;冒充&amp;rdquo; 为引导程序或者内核，机器通电后经过若干个步骤就会执行我们的程序。&lt;/p&gt;&lt;h2 id=&#34;裸机版的-hello-world-程序&#34;&gt;裸机版的 &amp;ldquo;Hello, World!&amp;rdquo; 程序&lt;/h2&gt;&lt;p&gt;下面要实现是一个 &amp;ldquo;裸机&amp;rdquo; 版的 &amp;ldquo;Hello, World!&amp;rdquo; 程序，该程序将会在 &lt;em&gt;QEMU 全系统模式&lt;/em&gt; 的 &lt;em&gt;RISC-V 64&lt;/em&gt; 机器（也就是程序 &lt;code&gt;qemu-system-riscv64&lt;/code&gt;）里运行。&lt;/p&gt;&lt;h3 id=&#34;如何直接访问硬件&#34;&gt;如何直接访问硬件？&lt;/h3&gt;&lt;p&gt;传统的 &amp;ldquo;Hello, World!&amp;rdquo; 的程序很简单，主要就是调用 &lt;code&gt;printf&lt;/code&gt; 函数向屏幕输出 &amp;ldquo;Hello, World!&amp;rdquo; 字符串。可是现在因为机器里没有操作系统，没法使用底层的 &lt;code&gt;write&lt;/code&gt; &lt;em&gt;系统调用&lt;/em&gt;（&lt;em&gt;syscall&lt;/em&gt;），当然也无法直接调用 &lt;code&gt;printf&lt;/code&gt; 函数。为了向屏幕输出文字信息，只能硬着头皮直接跟硬件打交道了。&lt;/p&gt;&lt;p&gt;幸好跟硬件打交道并不算太复杂，硬件主要就是数字电路，你可以粗略地把它看作由一系列 &amp;ldquo;小开关&amp;rdquo; 构成的电路。其中有些开关供外部设置，有些开关用于向外部反映状态。这些开关实际上对应着数字电路中的 &lt;em&gt;寄存器&lt;/em&gt; 元件（注意这里的寄存器不是指处理器里面那组寄存器，而是一般数字电路当中的寄存器），这些寄存器的输入端或者输出端会通过复用器映射到内存空间的某个地址。于是当我们向这些内存地址写入比特 0 或者 1 时，就可以设置相应寄存器的状态（即低电平和高电平，分别用 0 和 1 表示），反之，读取这些内存地址，就能获得相应寄存器的状态。于是跟硬件打交道就简化为 &lt;strong&gt;向指定内存地址写入或者读取数字&lt;/strong&gt;。&lt;/p&gt;&lt;h3 id=&#34;通过串口发送字符&#34;&gt;通过串口发送字符&lt;/h3&gt;&lt;p&gt;虚拟机 &lt;em&gt;QEMU RISC-V 64 Virt&lt;/em&gt; 里有一个虚拟的硬件 &lt;a href=&#34;https://www.qemu.org/docs/master/system/riscv/virt.html&#34;&gt;NS16550&lt;/a&gt;，它是一个实现了 &lt;a href=&#34;https://en.wikipedia.org/wiki/Universal_asynchronous_receiver-transmitter&#34;&gt;UART 通信协议&lt;/a&gt; （也就是我们常说的串口通信）的芯片。当向这个芯片读入数据时，数据会通过 RS-232 接口和电缆传送到另一端的设备，在 &lt;em&gt;QEMU RISC-V 64 Virt&lt;/em&gt; 里，这个 &lt;em&gt;另一端的设备&lt;/em&gt; 就是运行 QEMU 程序的虚拟终端。&lt;/p&gt;&lt;p&gt;通过阅读 &lt;a href=&#34;http://caro.su/msx/ocm_de1/16550.pdf&#34;&gt;NS16550 的数据手册（data sheet）&lt;/a&gt; 可知芯片一共有 13 个寄存器，这些寄存器用于控制硬件的工作参数，以及读取或写入通信数据。每个寄存器根据其作用一般都有一个名称，比如 NS16550 的第一个寄存器叫做 &lt;code&gt;THR&lt;/code&gt;（Transmitter HoldingRegister），从名称可以大概知道它是用于存放待发送的数据。同时，每个寄存器都有其数据大小，在 NS16550 里每个寄存器大小刚好都是 8 bit，所有寄存器排列在一起将会形成一段数据空间，从数据手册里可知 NS16550 寄存器形成了一个 8 bytes 的数据空间。这样我们就可以用 &lt;em&gt;地址&lt;/em&gt; 来定位寄存器了。寄存器的地址也叫 &lt;em&gt;偏移地址&lt;/em&gt;。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;NS16550 的寄存器空间之所以不是 13 * 1 byte = 13 bytes 的空间，是因为部分寄存器共享了同一个位置。比如 &lt;code&gt;RHR&lt;/code&gt; 和 &lt;code&gt;THR&lt;/code&gt; 的地址都是 0。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;然后再通过 &lt;a href=&#34;https://github.com/qemu/qemu/blob/master/hw/riscv/virt.c&#34;&gt;QEMU RISC-V virt 的源代码&lt;/a&gt; 所显示的硬件外设（peripherals）的内存映射地址列表，得知 UART 被映射到内存 &lt;code&gt;0x10000000&lt;/code&gt; 位置。&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; MemMapEntry virt_memmap[] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ...&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    [VIRT_MROM] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;         {     &lt;span style=&#34;color:#ae81ff&#34;&gt;0x1000&lt;/span&gt;,        &lt;span style=&#34;color:#ae81ff&#34;&gt;0xf000&lt;/span&gt; },&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    [VIRT_UART0] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;        { &lt;span style=&#34;color:#ae81ff&#34;&gt;0x10000000&lt;/span&gt;,         &lt;span style=&#34;color:#ae81ff&#34;&gt;0x100&lt;/span&gt; },&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    [VIRT_FLASH] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;        { &lt;span style=&#34;color:#ae81ff&#34;&gt;0x20000000&lt;/span&gt;,     &lt;span style=&#34;color:#ae81ff&#34;&gt;0x4000000&lt;/span&gt; },&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    [VIRT_DRAM] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;         { &lt;span style=&#34;color:#ae81ff&#34;&gt;0x80000000&lt;/span&gt;,           &lt;span style=&#34;color:#ae81ff&#34;&gt;0x0&lt;/span&gt; },&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ...&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;也就是说，NS16550 芯片的寄存器组的在内存中的基址为 &lt;code&gt;0x10000000&lt;/code&gt;，那么寄存器 &lt;code&gt;THR&lt;/code&gt; 的实际地址就是 &lt;code&gt;0x10000000&lt;/code&gt; + &lt;code&gt;0&lt;/code&gt;，寄存器 &lt;code&gt;LSR&lt;/code&gt;（Line Status Register）的实际地址为 &lt;code&gt;0x10000000&lt;/code&gt; + &lt;code&gt;0x5&lt;/code&gt;：&lt;/p&gt;&lt;p&gt;综合以上信息，如果要向串口发送一个字符，只需向地址 &lt;code&gt;0x1000_0000&lt;/code&gt; 写入字符对应的 ASCII 数值（一个 uint8 类型整数），然后这个字符就会被重定向到正在运行 QEMU 程序的虚拟终端。&lt;/p&gt;&lt;p&gt;所以要实现打印单个字符的函数是很简单的，在任意目录新建一个名为 &lt;code&gt;bare-metal&lt;/code&gt; 的目录，然后创建名为 &lt;code&gt;put_char.S&lt;/code&gt; 的文件, 内容如下：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-S&#34; data-lang=&#34;S&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.equ VIRT_UART0, &lt;span style=&#34;color:#ae81ff&#34;&gt;0x10000000&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.section .text.put_char&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.globl put_char&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;put_char&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    li s1, VIRT_UART0&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    mv s2, a0&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    sb s2, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;(s1)&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ret&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;&lt;p&gt;源代码可以到 &lt;a href=&#34;https://github.com/hemashushu/hemashushu.github.io/tree/main/src/content/posts&#34;&gt;文章的 Github 源代码仓库&lt;/a&gt; 下载。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;上面汇编源代码定义了一个名为 &lt;code&gt;put_char&lt;/code&gt; 的函数，其中的代码的大致作用如下：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;code&gt;.equ VIRT_UART0, 0x10000000&lt;/code&gt; 定义了一个名字为 &lt;code&gt;VIRT_UART0&lt;/code&gt; 的常量；&lt;/li&gt;&lt;li&gt;&lt;code&gt;put_char:&lt;/code&gt; 定义了一个名字为 &lt;code&gt;put_char&lt;/code&gt; 的 &lt;em&gt;标签&lt;/em&gt;，所谓 &lt;em&gt;标签&lt;/em&gt; 就是一个内存地址，因为函数通常由一个标签开始，并且由 &lt;code&gt;.globl&lt;/code&gt; 指令导出，导出之后叫 &lt;em&gt;导出符号&lt;/em&gt;，所以表示函数开始的标签也可以简单称为 &lt;em&gt;符号&lt;/em&gt;。除了函数名称，符号还可以是全局变量、静态变量等的名称；&lt;/li&gt;&lt;li&gt;&lt;code&gt;li s1, VIRT_UART0&lt;/code&gt; 将常量 &lt;code&gt;VIRT_UART0&lt;/code&gt; 的值加载进寄存器 &lt;code&gt;s1&lt;/code&gt;；&lt;/li&gt;&lt;li&gt;&lt;code&gt;mv s2, a0&lt;/code&gt; 将寄存器 &lt;code&gt;a0&lt;/code&gt; 的值，也就是函数的第一个参数的值，复制到寄存器 &lt;code&gt;s2&lt;/code&gt;；&lt;/li&gt;&lt;li&gt;将 &lt;code&gt;s2&lt;/code&gt; 的值写到内存地址 &lt;code&gt;s1 + 0&lt;/code&gt;，简单来说，上面 3 句的作用就是把第一个参数的值写到内存 &lt;code&gt;0x10000000&lt;/code&gt;；&lt;/li&gt;&lt;li&gt;&lt;code&gt;ret&lt;/code&gt; 返回到函数调用者，&lt;/li&gt;&lt;li&gt;&lt;code&gt;.globl put_char&lt;/code&gt; 导出符号 &lt;code&gt;put_char&lt;/code&gt;，导出的符号用于供外部使用。&lt;/li&gt;&lt;/ol&gt;&lt;blockquote&gt;&lt;p&gt;RISC-V 汇编的内容会在后面的章节陆陆续续出现，在这里只需知道大概的作用即可。对于这里没有说明的语句，会在后面的章节讲解。&lt;/p&gt;&lt;p&gt;如果你之前了解过汇编，会发现 RISC-V 的 &lt;a href=&#34;https://en.wikipedia.org/wiki/X86_assembly_language#Syntax&#34;&gt;汇编源代码的语法&lt;/a&gt; 是 Intel 风格，而不是 GNU 默认采用的 AT&amp;amp;T 风格，包括后面将会接触的 ARM thumb 汇编，也是 Intel 风格。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;code&gt;put_char&lt;/code&gt; 函数也可以用 C 语言实现，两个版本随意选一个即可。新建名为 &lt;code&gt;put_char.c&lt;/code&gt; 的文件，其内容如下：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#define VIRT_UART0 0x10000000&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;volatile&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; VIRT_UART0_PTR &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;)VIRT_UART0;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;put_char&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; c)&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;VIRT_UART0_PTR &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; c;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上面是一段很普通的 C 语言代码，其中关键字 &lt;code&gt;volatile&lt;/code&gt; 可能比较陌生。关键字 &lt;code&gt;volatile&lt;/code&gt; 用于标记变量的值可能会在程序之外被改变，通常情况是该变量的值来自内存某个地址，加了这个关键字之后可以防止编译器对它进行优化。&lt;/p&gt;&lt;p&gt;比如在源代码里有 &lt;strong&gt;连续多次读取&lt;/strong&gt; 同一个变量的语句，如果没有标记为 &lt;code&gt;volatile&lt;/code&gt;，编译器会把它优化为 &lt;strong&gt;只读取一次&lt;/strong&gt;。因为显而易见后面的几次读取都是同样的值，所以生成汇编时只会生成 &amp;ldquo;从内存读取&amp;rdquo; 的指令一次。如果这语句用于读取 UART 的接收到的字符，那么就会出错，因为这个变量的值会在程序外部被改变的。这时就必须为变量加上 &lt;code&gt;volatile&lt;/code&gt; 关键字，让编译器不要对它进行优化，而是原原本本地生成多条 &amp;ldquo;从内存读取&amp;rdquo; 的指令。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;为了简单起见，这里忽略了 UART 发送所需的延迟。如果是在真实硬件上编写发送字符的程序，应该检查 UART TX FIFO 的值，仅当上一个字符发送完毕之后（即 TX 空闲之后）再发送下一个字符。完整的发送/接收代码可以参考这个文件 &lt;a href=&#34;https://github.com/michaeljclark/riscv-probe/blob/master/libfemto/drivers/ns16550a.c&#34;&gt;ns16550a.c&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 id=&#34;实现-print_string-函数&#34;&gt;实现 print_string 函数&lt;/h3&gt;&lt;p&gt;在函数 &lt;code&gt;put_char&lt;/code&gt; 基础之上，可以实现打印字符串函数 &lt;code&gt;print_string&lt;/code&gt;。新建名为 &lt;code&gt;libprint.c&lt;/code&gt; 的文件，其内容如下：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;#34;put_char.h&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;print_string&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;str)&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;str &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;\0&amp;#39;&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        put_char(&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;str);&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        str&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;主程序&#34;&gt;主程序&lt;/h3&gt;&lt;p&gt;主程序很简单，新建名为 &lt;code&gt;app.c&lt;/code&gt; 的文件，其内容如下：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;#34;libprint.h&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;bare_main&lt;/span&gt;()&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    print_string(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Hello, World!&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;因为这个是裸机程序，为了跟标准程序区分，这里把平常的主函数 &lt;code&gt;main&lt;/code&gt; 命名为 &lt;code&gt;bare_main&lt;/code&gt;（随意的取一个名字都可以）。&lt;/p&gt;&lt;h3 id=&#34;程序启动器&#34;&gt;程序启动器&lt;/h3&gt;&lt;p&gt;学习过 C 语言编程的大概都知道程序最先被执行的是 &lt;code&gt;main&lt;/code&gt; 函数，可实际上程序的入口（即最先被开始执行的指令）是由编译器自动生成的 &lt;code&gt;_start&lt;/code&gt; 过程，该过程会做一些初始化工作，比如设置栈顶地址等，然后才跳转到函数 &lt;code&gt;main&lt;/code&gt;。不过仅在编译和链接为标准 Linux 的程序时，编译器才会自动添加 &lt;code&gt;_start&lt;/code&gt; 过程，现在我们写的是裸机程序，所以需要自己手写类似的入口过程。新建名为 &lt;code&gt;startup.S&lt;/code&gt; 的文件，其内容如下：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-S&#34; data-lang=&#34;S&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.section .text.entry&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.globl _start&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;_start&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    la sp, stack_top&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    call bare_main&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;_loop&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    nop&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    j _loop&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其中的代码的大致作用如下：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;code&gt;la sp, stack_top&lt;/code&gt; 因为程序有嵌套的函数调用，所以需要用到 &lt;em&gt;栈&lt;/em&gt;。在 RISC-V 体系里，通过向 &lt;code&gt;sp&lt;/code&gt;（stack pointer）寄存器写入一个地址即可设置栈顶地址，这样就把 &lt;em&gt;栈&lt;/em&gt; 搭建好了；（注意代码中的 &lt;code&gt;stack_top&lt;/code&gt; 来自下面的链接脚本 &lt;code&gt;app.ld&lt;/code&gt; 导出的符号）&lt;/li&gt;&lt;li&gt;&lt;code&gt;_loop:&lt;/code&gt; 定义一个名字为 &lt;code&gt;_loop&lt;/code&gt; 的符号，这个符号没有导出，所以它是内部使用的；&lt;/li&gt;&lt;li&gt;&lt;code&gt;nop&lt;/code&gt; 这是一个伪指令，对应的真实指令是 &lt;code&gt;addi zero, zero, 0&lt;/code&gt;，这个指令的作用是将寄存器 &lt;code&gt;zero&lt;/code&gt; 的值加 0，显然这是无作用的指令，通常用于表示什么都不做。&lt;/li&gt;&lt;li&gt;&lt;code&gt;j _loop&lt;/code&gt; 无条件跳转到符号 &lt;code&gt;_loop&lt;/code&gt;。这 3 行形成了一个死循环。&lt;/li&gt;&lt;li&gt;&lt;code&gt;call bare_main&lt;/code&gt; 调用主函数 &lt;code&gt;bare_main&lt;/code&gt;。当 &lt;code&gt;bare_main&lt;/code&gt; 函数执行完毕并返回后，就执行由 &lt;code&gt;_loop ... j _loop&lt;/code&gt; 组成的死循环。&lt;/li&gt;&lt;/ol&gt;&lt;blockquote&gt;&lt;p&gt;注意在汇编里没有函数或者过程的概念，如果没有遇到跳转或者分支指令或者错误，CPU 会一直往下执行。上面的一段程序之所以需要一个死循环，是为了防止从函数 &lt;code&gt;bare_main&lt;/code&gt; 返回之后 CPU 继续往下执行内存中那些乱七八糟的数据（硬件通电后内存中的数据是随机的），所以设置这样的一段小程序让 CPU 在原地打转（虽然不优雅却管用）。注意，当 QEMU 执行到这里时，你的电脑风扇也会飞快地旋转起来，不过不用担心，只需结束 QEMU 程序就好了。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&#34;编译&#34;&gt;编译&lt;/h2&gt;&lt;p&gt;编译各个源文件，但暂时不需要链接：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ riscv64-elf-as -o startup.o startup.S&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ riscv64-elf-gcc -I . -Wall -fPIC -c -o app.o app.c&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ riscv64-elf-gcc -I . -Wall -fPIC -c -o libprint.o libprint.c&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ riscv64-elf-as -o put_char.o put_char.S&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在编译 &lt;code&gt;app.c&lt;/code&gt; 时你可能会感到疑惑，在 &lt;code&gt;app.c&lt;/code&gt; 里调用了函数 &lt;code&gt;print_string&lt;/code&gt;，但这个函数却在后面才编译，那么为什么 &lt;code&gt;app.c&lt;/code&gt; 在 &amp;ldquo;引用了一个尚未编译的函数&amp;rdquo; 的情况下也能成功编译呢？&lt;/p&gt;&lt;p&gt;这正是 GCC 编译的工作原理，在编译一个源文件时，如果代码里有外部函数调用，编译器实际上是不管这个外部函数是否存在（是否已经编译），也不管它在哪里，你只需提供这个函数的签名给它即可（在当前的例子里，&lt;code&gt;print_string&lt;/code&gt; 的函数签名位于头文件 &lt;code&gt;libprint.h&lt;/code&gt; 里），这也是为什么各个源文件可以各自单独编译，甚至多个源文件可以并行编译的原因。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;平时编译软件可能会经常输入的类似 &lt;code&gt;$ make -j $(nproc)&lt;/code&gt; 或者直接 &lt;code&gt;$ make -j&lt;/code&gt; 这样的命令，它可以让编译速度提高几倍，现在你应该知道它的原理是：使用多个进程进行并行编译。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&#34;链接&#34;&gt;链接&lt;/h2&gt;&lt;p&gt;在上面的 &lt;a href=&#34;#%E5%A6%82%E4%BD%95%E7%9B%B4%E6%8E%A5%E8%AE%BF%E9%97%AE%E7%A1%AC%E4%BB%B6&#34;&gt;如何直接访问硬件？&lt;/a&gt; 一节里提到，需要把裸机程序放置在某个指定的位置，机器才能正确找到并执行，在 QEMU 里这个位置是内存地址 &lt;code&gt;0x80000000&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;怎样才能让 QEMU 把程序加载到指定的位置呢？&lt;code&gt;qemu-system-riscv64&lt;/code&gt; 支持加载 ELF 格式的程序和纯二进制数据：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;当加载的是 ELF 格式文件时，它会按照 ELF 的结构信息加载到指定的位置；&lt;/li&gt;&lt;li&gt;当加载的是纯二进制数据是，可以通过参数 &lt;code&gt;-device loader,file=FILENAME,addr=0x80000000&lt;/code&gt; 指定加载地址。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;下面采用的是第一种方法，只需在链接时指定一个链接脚本，就可以让链接器按照脚本的描述来组织和生成可执行文件。新建名为 &lt;code&gt;app.ld&lt;/code&gt; 的文件，其内容如下：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;OUTPUT_ARCH(riscv)&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ENTRY(_start)&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;BASE_ADDRESS = 0x80000000;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;SECTIONS&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  . = BASE_ADDRESS;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  .text : {&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    *(.text.entry)&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    *(.text .text.*)&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  .rodata : {&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    *(.rodata .rodata.*)&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  .data : {&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    *(.data .data.*)&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  .bss :{&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    *(.bss .bss.*)&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  . = ALIGN(8);&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  /* a 4KB stack */&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  stack_bottom = .;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  . += 4096;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  stack_top = .;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其中 &lt;code&gt;. = BASE_ADDRESS&lt;/code&gt; 语句用于指定程序的第一个段的加载地址，相当于指定了程序的加载位置。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;有关 &lt;em&gt;程序段&lt;/em&gt; 以及链接脚本的详细内容，会在下一章讲解。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;然后使用 &lt;code&gt;ld&lt;/code&gt; 命令把 &lt;code&gt;startup.o&lt;/code&gt;，&lt;code&gt;app.o&lt;/code&gt;，&lt;code&gt;libprint.o&lt;/code&gt; 和 &lt;code&gt;put_char.o&lt;/code&gt; 链接起来，并根据链接脚本 &lt;code&gt;app.ld&lt;/code&gt; 生成可执行文件：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ riscv64-elf-ld -T app.ld -o app.out startup.o app.o libprint.o put_char.o&lt;/code&gt;&lt;/p&gt;&lt;p&gt;命令中个参数的作用：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;-T app.ld&lt;/code&gt; 表示使用指定的链接脚本 &lt;code&gt;app.ld&lt;/code&gt;，如果省略这个参数，链接器会用内置的默认链接脚本。&lt;/li&gt;&lt;li&gt;&lt;code&gt;-o app.out&lt;/code&gt; 指定输出文件的文件名。&lt;/li&gt;&lt;li&gt;&lt;code&gt;startup.o app.o libprint.o put_char.o&lt;/code&gt; 表示待链接的文件列表（注意，文件列表和共享库列表一样，尽量按照 &amp;ldquo;被依赖的项排在后面&amp;rdquo; 这样的顺序排列。顺序错误的话可能会导致链接失败）。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;命令运行之后将会得到 ELF 格式的可执行文件 &lt;code&gt;app.out&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;当然上面的编译和链接过程也可以只用一个命令来完成：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;riscv64-elf-gcc &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;    -I . &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;    -Wall &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;    -fPIC &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;    -g &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;    -Wl,-T,app.ld &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;    -nostdlib &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;    -o app.out &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;    startup.S app.c libprint.c put_char.S&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上面命令有两个新的参数：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;-Wl,-T,app.ld&lt;/code&gt; 这个参数用于 &amp;ldquo;传递参数给链接器 &lt;code&gt;ld&lt;/code&gt;&amp;quot;，相当于 &lt;code&gt;$ ld ... -T app.ld ...&lt;/code&gt;。当需要把参数从 GCC 传递给链接器时，可以构造这种以逗号分隔的字符串。&lt;/li&gt;&lt;li&gt;&lt;code&gt;-nostdlib&lt;/code&gt; 表示不需要自动往目标程序添加 &lt;code&gt;_start&lt;/code&gt; 启动过程以及链接 C 的标准库（标准库提供了诸如 &lt;code&gt;printf&lt;/code&gt; 等函数），上一章我们知道 GCC 会自动往目标程序添加很多内容，而参数 &lt;code&gt;-nostdlib&lt;/code&gt; 用于告诉链接器：整个程序的内容都由我们自己的代码提供，这是构建裸机程序必须的。&lt;/li&gt;&lt;/ul&gt;&lt;blockquote&gt;&lt;p&gt;还有跟 &lt;code&gt;-nostdlib&lt;/code&gt; 参数类似的几个链接参数：&lt;code&gt;-nostartfiles&lt;/code&gt;、&lt;code&gt;-nodefaultlibs&lt;/code&gt; 和 &lt;code&gt;-nolibc&lt;/code&gt;。它们分别表示不需要添加启动过程、不要链接默认的库（如 &lt;code&gt;libgcc&lt;/code&gt;）以及不要链接 C 标准库（&lt;code&gt;libc&lt;/code&gt;）。参数 &lt;code&gt;-nostdlib&lt;/code&gt; 相当于前两个参数的组合，一般编译裸机程序只需添加这个链接参数即可，另外如果仅仅想自己指定启动函数，则只添加 &lt;code&gt;-nostartfiles&lt;/code&gt;，另外两个参数的使用场合较少。详细的可以参阅 &lt;a href=&#34;https://gcc.gnu.org/onlinedocs/gcc/Link-Options.html&#34;&gt;GCC 链接参数说明&lt;/a&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;有时目标架构缺少某些指令（比如 rv32i 缺少乘法和除法指令），GCC 编译器会使用其它指令的组合来代替，如果使用了 &lt;code&gt;-nostdlib&lt;/code&gt; 链接参数，则需要手动加上 &lt;code&gt;-lgcc&lt;/code&gt; 参数。&lt;code&gt;gcc&lt;/code&gt; 库跟 &lt;code&gt;libc&lt;/code&gt; 库的不同地方在于，前者提供的函数主要用于解决编译问题，后者则用于跟操作系统打交道以及提供常用函数。所以前者一般也称为 &lt;em&gt;编译器的私有库&lt;/em&gt;，我们写程序时是不会直接调用到这个库，相反，&lt;code&gt;libc&lt;/code&gt; 则高频地被我们的程序代码所调用。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&#34;运行&#34;&gt;运行&lt;/h2&gt;&lt;p&gt;下面使用 QEMU 的 &lt;em&gt;全系统模式&lt;/em&gt; 程序 &lt;code&gt;qemu-system-riscv64&lt;/code&gt; 运行该文件：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ qemu-system-riscv64 &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;    -machine virt &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;    -nographic &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;    -bios none &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;    -kernel app.out&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如无意外，应该能看到正确的输出结果 &amp;ldquo;Hello, World!&amp;quot;。&lt;/p&gt;&lt;p&gt;&lt;img src=&#34;images/qemu-system.png&#34; alt=&#34;qemu system&#34;&gt;&lt;/p&gt;&lt;p&gt;这时你的主机（通常称为 &lt;em&gt;host&lt;/em&gt;）可能会有一个核心（core）的负载率高达 100%，这是因为 &amp;ldquo;Hello, World!&amp;rdquo; 程序从 &lt;em&gt;bare_main&lt;/em&gt; 函数返回之后，来到了一个死循环（即 &lt;code&gt;startup.S&lt;/code&gt; 里的 &lt;code&gt;_loop&lt;/code&gt;），你需要结束 QEMU 程序才能让 CPU 平静下来。&lt;/p&gt;&lt;p&gt;请注意你需要按 &lt;code&gt;Ctrl+a&lt;/code&gt; 然后松开 &lt;code&gt;Ctrl&lt;/code&gt; 键再按 &lt;code&gt;x&lt;/code&gt; 来结束 QEMU 程序，而不是平常的 &lt;code&gt;Ctrl+c&lt;/code&gt;，这个奇怪的组合键可能跟 VIM 的退出方法一样，会让你手忙脚乱一阵子。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;QEMU 不使用 &lt;code&gt;Ctrl+c&lt;/code&gt; 退出自身是有原因的，因为在 QEMU 里运行的是一个系统（通常称为 &lt;em&gt;guest&lt;/em&gt;），比如一个完整的 Linux 系统，或者一个 Linux 桌面，QEMU 需要保留 &lt;code&gt;Ctrl+x&lt;/code&gt; 这个常用的组合键给 guest 里面的程序，所以虚拟机本身当然不能用 &lt;code&gt;Ctrl+c&lt;/code&gt; 来退出了。有些串口通信程序也是使用这样 &amp;ldquo;奇怪&amp;rdquo; 的组合键来结束程序本身，比如 &lt;a href=&#34;https://github.com/npat-efault/picocom&#34;&gt;picocom&lt;/a&gt; 和 &lt;a href=&#34;https://salsa.debian.org/minicom-team/minicom&#34;&gt;minicom&lt;/a&gt; 使用 &lt;code&gt;Ctrl+a, Ctrl+x&lt;/code&gt;（或者按住 &lt;code&gt;Ctrl&lt;/code&gt; 键，然后依次按 &lt;code&gt;a&lt;/code&gt; 键和 &lt;code&gt;x&lt;/code&gt; 键）。还有 SSH 连接被动断开时，需要使用 &lt;code&gt;Ctrl+D&lt;/code&gt; 或者 &lt;code&gt;~.&lt;/code&gt;（即先按 &lt;code&gt;Shift+~&lt;/code&gt; 再按 &lt;code&gt;.&lt;/code&gt;）这些不寻常的组合键，都是基于同样的原因。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&#34;打包静态库&#34;&gt;打包静态库&lt;/h2&gt;&lt;p&gt;多写几个裸机程序之后，你可能会发现诸如 &lt;code&gt;startup.S&lt;/code&gt;、&lt;code&gt;libprint.c&lt;/code&gt; 和 &lt;code&gt;put_char.S&lt;/code&gt; 等基础功能会经常被不同的程序所引用，我们可以把这些基础功能的代码编译并打包为一个库，就像 C 标准库 &lt;code&gt;libc&lt;/code&gt; 一样，这样可以方便以后使用。&lt;/p&gt;&lt;p&gt;在 Linux 系统里，&lt;em&gt;库&lt;/em&gt; 分有 &lt;em&gt;静态库&lt;/em&gt; 和 &lt;em&gt;动态库&lt;/em&gt; 两种，扩展名分别为 &lt;code&gt;*.a&lt;/code&gt; 和 &lt;code&gt;*.so&lt;/code&gt;。静态库的代码会在编译的过程直接复制到输出文件（即可执行文件），而动态库则需要操作系统的支持，在程序运行时动态地链接上。当前程序是裸机程序，所以只能使用静态库了。使用工具 &lt;code&gt;ar&lt;/code&gt; 可以将一个或多个 &lt;em&gt;可重定位文件&lt;/em&gt; 打包成一个静态库，例如：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ riscv64-elf-ar rs libbaremetal.a startup.o libprint.o put_char.o&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;ar&lt;/code&gt; 命令后面跟着 &lt;em&gt;一个操作码&lt;/em&gt; 以及 &lt;em&gt;零个或多个修饰符&lt;/em&gt;：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;操作码 &lt;code&gt;r&lt;/code&gt; 表示插入新的文件，或者替换静态库中已存在的文件，通常用于新建静态库；&lt;/li&gt;&lt;li&gt;修饰符 &lt;code&gt;s&lt;/code&gt; 表示为静态库创建索引，相当于创建完静态库之后执行了一次 &lt;code&gt;$ riscv64-elf-ranlib libbaremetal.a&lt;/code&gt; 命令；&lt;/li&gt;&lt;li&gt;&lt;code&gt;libbaremetal.a&lt;/code&gt; 是输出的文件的文件名；&lt;/li&gt;&lt;li&gt;&lt;code&gt;startup.o libprint.o ...&lt;/code&gt; 是待打包的文件列表。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;运行之后将得到静态库文件 &lt;code&gt;libbaremetal.a&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;工具 &lt;code&gt;ar&lt;/code&gt; 除了可以创建静态库，还可以用于查看或者修改，使用不同的操作码就能实现不同的功能。比如下面的命令可以查看静态库文件里含有哪些文件：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ riscv64-elf-ar t libbaremetal.a&lt;/code&gt;&lt;/p&gt;&lt;p&gt;输出的结果如下：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;startup.o&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;libprint.o&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;put_char.o&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;由此可以确定已经正确打包所需的文件了。然后编译时就再也不需要 &lt;code&gt;startup.S&lt;/code&gt;、&lt;code&gt;libprint.c&lt;/code&gt; 和 &lt;code&gt;put_char.S&lt;/code&gt;（当然头文件 &lt;code&gt;libprint.h&lt;/code&gt; 仍需要），使用一个 &lt;code&gt;libbaremetal.a&lt;/code&gt; 代替它们三个即可，编译命令也得到了简化：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;riscv64-elf-gcc &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;    -I . &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;    -Wall &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;    -fPIC &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;    -g &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;    -Wl,-T,app.ld &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;    -nostdlib &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;    -o app-one.out &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;    app.c libbaremetal.a&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;运行之后将得到可执行文件 &lt;code&gt;app-one.out&lt;/code&gt;，这个文件跟 &lt;code&gt;app.out&lt;/code&gt; 是一模一样的。（可以使用命令 &lt;code&gt;$ diff app-one.out app.out&lt;/code&gt; 验证）&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;工具 &lt;a href=&#34;https://en.wikipedia.org/wiki/Ar_(Unix)&#34;&gt;ar&lt;/a&gt; 实际上是一个通用的打包程序，只是后来被 &lt;code&gt;tar&lt;/code&gt; 替换了，目前 &lt;code&gt;ar&lt;/code&gt; 主要用于创建静态库。顺便一提，&lt;em&gt;Debian&lt;/em&gt; 的包文件 &lt;code&gt;*.deb&lt;/code&gt; 也是 ar 格式。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;&lt;p&gt;这章我们创建了一种无需操作系统、无需任何库，就可以独自运行的程序，并了解了机器通电后是如何一步步地加载并运行我们的程序，同时也知道操作系统的内核其实是一个 &amp;ldquo;大号&amp;rdquo; 的裸机程序，而这章写的裸机程序也可以粗略地看作是一个功能弱到爆的 &lt;em&gt;系统内核&lt;/em&gt;。希望通过这章的学习和实践，能够破除内核的神秘感，同时能解开诸如 “机器通电后经历会做些什么？” 这些长期存在我们心中的困惑。&lt;/p&gt;&lt;p&gt;下一章将会深入剖析 &lt;em&gt;可执行文件&lt;/em&gt; 的组成和结构，让我们看看 &amp;ldquo;Hello, World!&amp;rdquo; 在 &amp;ldquo;物理&amp;rdquo; 层面究竟是什么样子的。&lt;/p&gt;&lt;div&gt;    &lt;img src=&#34;https://hemashushu.github.io/images/subscribe-and-donate.zh.png&#34; class=&#34;block-image image-480px&#34;/&gt;&lt;/div&gt;</description>
     </item>
   
     <item>
       <title>S01C01 什么是交叉编译？GCC 交叉编译及运行第一个程序</title>
       <link>https://hemashushu.github.io/zh/posts/2022-11-05-s01c01-cross-compile-and-run-the-first-program/</link>
       <pubDate>Sat, 05 Nov 2022 00:00:00 +0000</pubDate>
       
       <guid>https://hemashushu.github.io/zh/posts/2022-11-05-s01c01-cross-compile-and-run-the-first-program/</guid>
       <description>&lt;p&gt;项目 &lt;a href=&#34;../2022-10-31-building-a-modern-computer-system-from-scratch-step-by-step&#34;&gt;《从零开始一步一步制作自己的工具、构建现代计算机系统》&lt;/a&gt; 由四个系列文章组成，其中第一个系列是《一步一步深入了解 RISC-V 系统》。&lt;/p&gt;&lt;p&gt;该篇文章是第一个系列的第一篇，作为漫长旅程的第一站，我们应该从哪里开始呢？正如 &lt;a href=&#34;../2022-10-31-building-a-modern-computer-system-from-scratch-step-by-step&#34;&gt;项目介绍&lt;/a&gt; 所提到的，计算机系统技术的知识面很广，同时又相互交叉。无论从哪里开始都会同时涉及多个领域，因此很难把所有知识拉成一条直线然后从头到尾地讲解。不过计算机系统有一个显著的特点，就是层层封装的结构。每一层都会把复杂的事情封装起来，然后向上一层提供相对简单的接口，如此类推直到最上一层 —— 应用程序。这个特点使得人们即使对系统的底层技术不甚了解，也可以编写出各种应用程序程序以完成各种工作。所以 &amp;ldquo;对应用程序的研究和探索&amp;rdquo; 将会是一个理想的学习系统技术的突破口。&lt;/p&gt;&lt;p&gt;第一个系列我们将会了解程序是如何构建、程序文件本身是什么样的结构、程序是如何运行、软件和硬件之间是如何交流，以及汇编语言是怎样被转换为指令，等等有关程序的基本原理。在这个系列的后半阶段，我们会实现一个 RISC-V 汇编器和链接器，以及一门有特色的 RISC-V 汇编语言和链接器脚本语言。有了汇编器和链接器，我们就有能力生成程序（二进制可执行文件），这是我们制作自己的工具的基础。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;在 &lt;em&gt;John R. Levine&lt;/em&gt; 的《Linkers &amp;amp; Loaders》第一章里提到：“大概一个房间就能装得下世上所有编写链接器的人” （原文：&lt;em&gt;all the linker writers in the world could probably fit in one room&lt;/em&gt;）。也许我们学完这个系列之后也可以挤进这个小房间了，哈哈。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;这个系列的汇编器和脚本解析器我会用 &lt;a href=&#34;https://www.rust-lang.org/&#34;&gt;Rust&lt;/a&gt; 来编写。很多跟编译器和系统开发相关的文章、教程和项目都选择 C 语言作为编程语言。我知道在这个时代 C 语言已经无法提起你的兴趣，幸运的是现在有了更好的选择，使用 Rust 并不是为了追赶时髦，而是为了让我们避免低级错误，减少学习和开发过程中的挫折感，这对系统开发的初学者尤其重要。同时 Rust 有便利的工具链（正如很多现代语言那样），这些工具可以让我们专注于开发，减少一些反复的工作；当然在前面讲述基本原理的章节里，我还是会用到 C 语言，毕竟它非常直接明了，能够很好地跟底层技术对应上。&lt;/p&gt;&lt;p&gt;你可能会问：“为什么我们不直接开始动手写一门语言，或者写一个操作系统，或者写一个 CPU？” 虽然我能理解这种急切的心情，不过这种方法是行不通的。这是因为无论是上述的哪一个题目，起步都很高，如果从这些项目直接开始学习或者实践，会同时遇到很多新概念，当你试图弄懂其中的一个概念时，又会引出更多的新概念，最终我们的思路会被太多不能理解的事物所淹没。当然探索和学习的道路肯定不止一条，不过在跌跌撞撞地摸索一翻之后，大概率最终又会返回到当前这个位置，这里是系统开发的新手村。为了避免不必要的弯路，请从这里开始你的探索之旅吧。&lt;/p&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&#34;#1-%E5%89%8D%E8%A8%80&#34;&gt;1. 前言&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#2-%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91&#34;&gt;2. 什么是交叉编译？&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#3-gcc-%E7%BC%96%E8%AF%91%E5%99%A8&#34;&gt;3. GCC 编译器&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#4-%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F&#34;&gt;4. 交叉编译第一个程序&lt;/a&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&#34;#41-%E5%88%9B%E5%BB%BA-hello-world-%E7%A8%8B%E5%BA%8F&#34;&gt;4.1 创建 &amp;ldquo;Hello, World!&amp;rdquo; 程序&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#42-%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91&#34;&gt;4.2 交叉编译&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#43-elf-%E6%A0%BC%E5%BC%8F&#34;&gt;4.3 ELF 格式&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#5-%E8%BF%90%E8%A1%8C&#34;&gt;5. 运行&lt;/a&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&#34;#51-%E5%AE%89%E8%A3%85-qemu&#34;&gt;5.1 安装 QEMU&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#52-%E5%B0%9D%E8%AF%95%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F&#34;&gt;5.2 尝试运行程序&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#53-%E6%8C%87%E5%AE%9A%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%99%A8%E8%B7%AF%E5%BE%84&#34;&gt;5.3 指定动态链接器路径&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#54-%E7%BC%96%E8%AF%91%E4%B8%BA%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%A8%8B%E5%BA%8F&#34;&gt;5.4 编译为静态链接类型的程序&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#55-%E6%8C%87%E5%AE%9A%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%99%A8&#34;&gt;5.5 指定程序的动态链接器&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#6-%E5%88%86%E9%98%B6%E6%AE%B5%E7%BC%96%E8%AF%91&#34;&gt;6. 分阶段编译&lt;/a&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&#34;#61-%E9%A2%84%E5%A4%84%E7%90%86&#34;&gt;6.1 预处理&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#62-%E7%BC%96%E8%AF%91&#34;&gt;6.2 编译&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#63-%E6%B1%87%E7%BC%96&#34;&gt;6.3 汇编&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#64-%E9%93%BE%E6%8E%A5&#34;&gt;6.4 链接&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#7-%E5%B8%B8%E7%94%A8%E7%9A%84%E7%BC%96%E8%AF%91%E5%8F%82%E6%95%B0&#34;&gt;7. 常用的编译参数&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#8-%E6%80%BB%E7%BB%93&#34;&gt;8. 总结&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;!-- raw HTML omitted --&gt;&lt;h2 id=&#34;1-前言&#34;&gt;1. 前言&lt;/h2&gt;&lt;p&gt;为了弄懂程序是如何构建的，我们可以借助一些现有的、被广泛使用的工具，也就是接下来要讲的编译器和调试器。同时为了能在一个人的能力范围之内实现一个相对完整的编译器，这个系列会选择相对简单、门槛较低的 RISC-V 体系结构作为研究和实践对象。当然我们现在所使用的计算机大部分都是 &lt;em&gt;x86_64&lt;/em&gt; 架构或者 &lt;em&gt;ARM&lt;/em&gt; 架构，所以为了构建 RISC-V 程序，就得从 &lt;em&gt;交叉编译&lt;/em&gt; 开始。&lt;/p&gt;&lt;h2 id=&#34;2-什么是交叉编译&#34;&gt;2. 什么是交叉编译？&lt;/h2&gt;&lt;p&gt;在一台电脑里编译生成在手机运行的应用程序，这种编译是 &lt;em&gt;交叉编译&lt;/em&gt;；在 Linux 系统里编译生成 Windows 应用程序，这种编译也是交叉编译；当然，在 &lt;em&gt;x86_64&lt;/em&gt; 架构版本的 Linux 系统里编译生成 &lt;em&gt;RISC-V&lt;/em&gt; 架构版本的 Linux 应用程序这种也是交叉编译。&lt;/p&gt;&lt;p&gt;简单来说，只要 &amp;ldquo;编译器所运行的环境&amp;rdquo; 跟 &amp;ldquo;生成的程序运行的环境&amp;rdquo; 不一样的编译过程叫做 &lt;em&gt;交叉编译&lt;/em&gt;。其中目标运行环境包括 &lt;em&gt;目标架构&lt;/em&gt; 和 &lt;em&gt;目标平台&lt;/em&gt; 两个元素：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;目标架构&lt;/em&gt; 是指目标机器的 CPU 指令集架构（ISA，有时简称为 &lt;em&gt;指令集&lt;/em&gt;），比如常用的 Intel 和 AMD 的 CPU 指令集是 &lt;em&gt;x86_64&lt;/em&gt;，现在流行的手机用的 ARM CPU 指令集是 &lt;em&gt;A64&lt;/em&gt;（我们经常听到的 &lt;em&gt;aarch64&lt;/em&gt; 是指 ARM CPU 的某一个运行状态的名称，当然理解为 &lt;em&gt;一个指令集子集&lt;/em&gt; 也是可以的）。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;目标平台&lt;/em&gt; 是指目标机器运行的操作系统类型，比如 &lt;em&gt;Linux&lt;/em&gt;, &lt;em&gt;Windows&lt;/em&gt; 以及 &lt;em&gt;Darwin/macOS&lt;/em&gt; 等。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;当然在开发程序时，除了需要考虑目标架构和目标平台，可能还得考虑更细致的一些信息，比如当你在开发 Linux 应用程序时，需要考虑不同发行版之间的细微差别。不过对于编译器来说，它的确只关心目标架构和目标平台。&lt;/p&gt;&lt;p&gt;另外还有一些不需要操作系统而能够自己独立运行的程序，这种程序叫做 &lt;em&gt;freestanding 程序&lt;/em&gt; 或者 &lt;em&gt;裸机（bare metal）程序&lt;/em&gt;，比如在微控制器（MCU）里运行的程序（通常也叫做 &lt;em&gt;固件&lt;/em&gt;）和内核程序，在编译这种程序则只需指定 &lt;em&gt;目标架构&lt;/em&gt; 而不需要指定 &lt;em&gt;目标平台&lt;/em&gt;。&lt;/p&gt;&lt;p&gt;交叉编译主要有两个目的：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;一是为了方便生成不同目标环境的程序文件（二进制可执行文件）。假如我们开发了一个应用程序需要发布到多个平台，通过交叉编译，每次更新时只需在开发机器上跑几次交叉编译就可以生成所需的程序文件。如果没有交叉编译，则需要将源代码复制到每一个目标环境然后再编译，这将会非常繁琐且耗时；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;其次，也是最重要的原因，有些目标环境根本无法运行编译器。比如在微控制器里，往往只有几十 KB 的 RAM 和几百 KB 的 Flash（相当于固态硬盘），只能运行一些很小的程序，这种情况下只能借助交叉编译来生成程序。你应该不会指望你家的电饭煲或者智能马桶能运行一整套编译器工具，并且在里面编译程序。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;顺便一提，我们将要实现的编译器的目标指令集是 &lt;em&gt;riscv64gc&lt;/em&gt;，也是一个交叉编译器。下面先学习一下目前主流的编译器，这些编译器都拥有交叉编译的能力。&lt;/p&gt;&lt;h2 id=&#34;3-gcc-编译器&#34;&gt;3. GCC 编译器&lt;/h2&gt;&lt;p&gt;目前主流的编译器有 GCC 和 LLVM，两者都是开源且免费的。因为在后面的讲述软硬件交流原理的章节里会用到微控制器（MCU），而在微控制器领域里 GCC 更常用一些，所以为了简单起见，下面只讲 GCC 编译器。&lt;/p&gt;&lt;p&gt;在开发程序时，除了编译器还会经常用到二进制工具 &lt;em&gt;Binutils&lt;/em&gt;、调试工具 &lt;em&gt;GDB&lt;/em&gt; 以及标准库和内核头文件等，这一套被称为 &lt;em&gt;GNU Toolchain&lt;/em&gt;。在大部分 Linux 发行版里都可以通过包管理器轻松安装 GNU Toolchain。根据编译目标的不同，工具链的软件包的名字也会不同，比如 &lt;a href=&#34;https://github.com/riscv-collab/riscv-gnu-toolchain&#34;&gt;RISC-V GNU Toolchain&lt;/a&gt;，它们的包名（在 &lt;em&gt;Arch Linux&lt;/em&gt; 里）分别是：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;riscv64-linux-gnu-binutils&lt;/li&gt;&lt;li&gt;riscv64-linux-gnu-gcc&lt;/li&gt;&lt;li&gt;riscv64-linux-gnu-gdb&lt;/li&gt;&lt;li&gt;riscv64-linux-gnu-glibc&lt;/li&gt;&lt;li&gt;riscv64-linux-gnu-linux-api-headers&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;另外编译目标为 RISC-V 裸机程序的包有：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;riscv64-elf-binutils&lt;/li&gt;&lt;li&gt;riscv64-elf-gcc&lt;/li&gt;&lt;li&gt;riscv64-elf-gdb&lt;/li&gt;&lt;li&gt;riscv64-elf-newlib&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;在不同的 Linux 发行版里包的名字会有所不同，比如在 &lt;em&gt;Debian&lt;/em&gt;/&lt;em&gt;Ubuntu&lt;/em&gt; 里包名是：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;binutils-riscv64-linux-gnu&lt;/li&gt;&lt;li&gt;gcc-riscv64-linux-gnu&lt;/li&gt;&lt;li&gt;binutils-riscv64-unknown-elf&lt;/li&gt;&lt;li&gt;gcc-riscv64-unknown-elf&lt;/li&gt;&lt;li&gt;gdb-multiarch&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;如果你系统的包仓库里没有 RISC-V GNU Toolchain，则可以 &lt;a href=&#34;https://github.com/riscv-collab/riscv-gnu-toolchain&#34;&gt;下载源代码&lt;/a&gt; 然后通过源代码的方式安装。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;如果没有另外的说明，整个系列文章的操作都是在 Linux 系统环境里完成的，当然你也可以在自己平常使用的系统上操作，不过如果你决心要深入学习系统技术的话，建议还是使用 Linux 系统环境，除了比较方便之外，更重要的是 Linux 系统（特别是内核）就像一个开放的图书馆，里面充满了宝藏，摆在身旁的宝藏都不要那实在太浪费了。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&#34;4-交叉编译第一个程序&#34;&gt;4. 交叉编译第一个程序&lt;/h2&gt;&lt;p&gt;&amp;ldquo;Hello, World!&amp;rdquo; 程序就像编程世界里的史莱姆一般的存在，作为交叉编译的第一个实践对象当然不会放过它。&lt;/p&gt;&lt;h3 id=&#34;41-创建-hello-world-程序&#34;&gt;4.1 创建 &amp;ldquo;Hello, World!&amp;rdquo; 程序&lt;/h3&gt;&lt;p&gt;在任意位置新建一个名为 &lt;code&gt;app.c&lt;/code&gt; 的文件，内容如下：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Hello, World!&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;程序的功能非常简单：向屏幕打印一行文字 &amp;ldquo;Hello, World!&amp;quot;，然后结束程序，程序的返回值为 &lt;code&gt;0&lt;/code&gt;。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;每个程序运行结束后，都会向调用者返回一个整数，此整数称为 &lt;em&gt;返回值&lt;/em&gt;（&lt;em&gt;exit code&lt;/em&gt;）。它是一个 &lt;code&gt;uint32&lt;/code&gt; 数字，需注意的是在 Linux 环境里 &lt;em&gt;返回值&lt;/em&gt; 只有其二进制的最小 8 位是有效的，因此有效值的范围是从 0 到 255。如果返回一个负数，则会以 &lt;a href=&#34;https://en.wikipedia.org/wiki/Two%27s_complement&#34;&gt;补码&lt;/a&gt; 的形式返回，比如 &lt;code&gt;-10&lt;/code&gt;，即二进制 &lt;code&gt;0000,1010&lt;/code&gt; 补码为 &lt;code&gt;1111,0101 + 1&lt;/code&gt; = &lt;code&gt;1111,0110&lt;/code&gt;，对应的十进制为 &lt;code&gt;246&lt;/code&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;在 Linux 环境里约定程序成功退出时返回 0，失败返回非 0，注意这个跟一般编程语言里的 &lt;em&gt;Boolean&lt;/em&gt; 值约定刚好相反，所以在编写 Shell 脚本时要注意，其 &lt;code&gt;true&lt;/code&gt; 的值是 0。在 Shell 里可以通过命令 &lt;code&gt;echo $?&lt;/code&gt; 显示上一个程序的返回值，比如运行命令 &lt;code&gt;true; echo $?&lt;/code&gt; 将会看到数字 0。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;在每篇文章的目录里我都会创建一个名为 &lt;code&gt;resources&lt;/code&gt; 的文件夹，其中存放着该篇文章所有示例的源代码，有需要的可以到 &lt;a href=&#34;https://github.com/hemashushu/hemashushu.github.io/tree/main/src/content/posts&#34;&gt;我 Blog 的 Github 源代码仓库&lt;/a&gt; 下载。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 id=&#34;42-交叉编译&#34;&gt;4.2 交叉编译&lt;/h3&gt;&lt;p&gt;GNU Toolchain 当中的编译、汇编、链接的程序分别是 &lt;code&gt;gcc&lt;/code&gt;，&lt;code&gt;as&lt;/code&gt; 和 &lt;code&gt;ld&lt;/code&gt;，如果需要本地编译，则直接输入这些程序名即可。在交叉编译时，则需要在对应的命令名称添加一个前缀。在当前的例子里，前缀是 &lt;code&gt;riscv64-linux-gnu-&lt;/code&gt;，所以交叉编译的命令如下：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ riscv64-linux-gnu-gcc -g -Wall -o app.elf app.c&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;各个参数的含义如下：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;-g&lt;/code&gt;：用于生成供 GDB 使用的调试信息，调试信息包括源代码当中的变量名称，指令对应的源代码的位置（行数）等。额外的调试信息会保持在输出文件里面。虽然在当前例子里暂时用不上调试信息，不过在平时编译时都加上 &lt;code&gt;-g&lt;/code&gt; 参数可以培养良好的习惯；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;-Wall&lt;/code&gt;：用于报告编译过程中的所有警告信息，比如声明了局部变量却没使用，或者某个变量只赋值却从未被读取等，这些警告信息有助于书写良好的代码。类似的参数还有 &lt;code&gt;-Wextra&lt;/code&gt;，它能打开除了 &lt;code&gt;all&lt;/code&gt; 之外的更多的警告开关，比如将 &lt;code&gt;int&lt;/code&gt; 类型和 &lt;code&gt;unsigned int&lt;/code&gt; 类型的变量进行比较时，&lt;code&gt;-Wextra&lt;/code&gt; 会输出提示。&lt;a href=&#34;https://gcc.gnu.org/onlinedocs/gcc/Warning-Options.html&#34;&gt;详细列表可以参见 GCC 3.8 Options to Request or Suppress Warnings&lt;/a&gt;；&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote&gt;&lt;p&gt;有时编译一些旧代码时会报告一些错误并导致编译中断，但旧版本的编译器却可以顺利完成，这有可能是因为新版本的编译器引入了新的错误检查规则，或者某些规则在旧版本编译器里只是警告而不是错误。如果你没办法修改源代码，则可以通过在编译命令后添加 &lt;code&gt;-Wno-error=...&lt;/code&gt; 参数让编译器暂时忽略指定的规则，比如 &lt;code&gt;-Wno-error=int-conversion&lt;/code&gt; 可以让指针类型的值赋值给整型的变量或者传递给整型的参数。当然这是在没有别的办法的情况下才使用的方法。相反地，可以通过添加 &lt;code&gt;-Werror=...&lt;/code&gt; 参数让某些规则从提示级别上升为错误级别。&lt;/p&gt;&lt;/blockquote&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;-o app.elf&lt;/code&gt;：用于指定输出的文件的名称，如果缺省这个参数，默认的输出文件名为 &lt;code&gt;a.out&lt;/code&gt;。注意 &lt;code&gt;-o app.elf&lt;/code&gt; 是一个完整的参数，而随后的 &lt;code&gt;app.c&lt;/code&gt; 并不属于这个参数的一部分。&lt;/li&gt;&lt;/ul&gt;&lt;blockquote&gt;&lt;p&gt;在 Linux 系统里，可执行文件的的扩展名可以随意，这跟 Windows 系统里可执行文件的扩展名必须是 &lt;code&gt;exe&lt;/code&gt; 的情况不同。&lt;/p&gt;&lt;/blockquote&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;app.c&lt;/code&gt;：是源代码文件的名称。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;编译完成后得到文件 &lt;code&gt;app.elf&lt;/code&gt;。&lt;/p&gt;&lt;h3 id=&#34;43-elf-格式&#34;&gt;4.3 ELF 格式&lt;/h3&gt;&lt;p&gt;ELF 是二进制可执行文件的一种格式，比如上一步得到的 &lt;code&gt;app.elf&lt;/code&gt; 就是 ELF 格式的文件。下面使用 &lt;code&gt;file&lt;/code&gt; 命令查看输出文件 &lt;code&gt;app.elf&lt;/code&gt; 的格式信息：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ file app.elf&lt;/code&gt;&lt;/p&gt;&lt;p&gt;输出结果大致如下：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;app.elf: ELF 64-bit LSB pie executable, UCB RISC-V, RVC, double-float ABI, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux-riscv64-lp64d.so.1, BuildID[sha1]=afe0994d7df77dc817058ae17e814d8f0a4163ed, for GNU/Linux 4.15.0, with debug_info, not stripped&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上面一段文本部分内容的含义是：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;ELF&lt;/code&gt; 和 &lt;code&gt;executable&lt;/code&gt;：表明当前文件是一个 &lt;em&gt;ELF 文件格式&lt;/em&gt; 当中的 &lt;em&gt;可执行文件&lt;/em&gt;。ELF 格式有 3 种类型：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;code&gt;executable&lt;/code&gt;：&lt;em&gt;可执行文件&lt;/em&gt;，这是最常见的一种类型。注意在 Linux 系统里有些可执行文件并不是 ELF 格式，它们只是添加了可执行权限的脚本文件，其内容是文本而不是二进制指令和数据；&lt;/li&gt;&lt;li&gt;&lt;code&gt;shared object&lt;/code&gt;：&lt;em&gt;共享对象文件&lt;/em&gt;，也就是共享库。用于在运行时动态地链接到程序。目录 &lt;code&gt;/lib&lt;/code&gt; 和 &lt;code&gt;/usr/lib&lt;/code&gt; 里面那一堆 &amp;ldquo;*.so&amp;rdquo; 文件就是这种类型。&lt;/li&gt;&lt;li&gt;&lt;code&gt;relocatable&lt;/code&gt;：&lt;em&gt;可重定位文件&lt;/em&gt;，即编译任务中途产生的文件。上面的 GCC 编译命令在背后大致做了两件事：将 C 源代码转换为一系列机器指令并保存在可重定位文件里，这个过程称为 &lt;em&gt;编译&lt;/em&gt;；另一件事是把一个或多个可重定位文件连接成为一个可执行文件或者共享库，这个过程称为 &lt;em&gt;链接&lt;/em&gt;。&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;dynamically linked&lt;/code&gt;, &lt;code&gt;interpreter ...&lt;/code&gt;：表明当前可执行文件是 &lt;em&gt;动态链接&lt;/em&gt; 类型，也就是说它在运行时，需要其它共享库的帮忙才能完成工作。而这些库的加载和初始化任务则由 &lt;code&gt;interpreter&lt;/code&gt; 指定的程序来完成，这个程序也叫 &lt;em&gt;运行时动态链接器&lt;/em&gt;，这个程序通常是 &lt;code&gt;/usr/bin/ld.so&lt;/code&gt;（虽然这个程序的扩展名是 &lt;code&gt;so&lt;/code&gt;，看起来像一个共享库，不过它却是可执行文件，之所以添加了 &lt;code&gt;so&lt;/code&gt; 后缀，估计是为了区分 &lt;em&gt;静态链接&lt;/em&gt; 程序 &lt;code&gt;ld&lt;/code&gt;）。可执行文件还可以是 &lt;em&gt;静态链接（statically linked）&lt;/em&gt; 类型，表示它在运行时不需要其它共享库帮忙，它自己就能完成所有工作。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;pie&lt;/code&gt;：表明当前的可执行文件是 &lt;em&gt;位置无关的可执行文件&lt;/em&gt;（&lt;em&gt;Position Independent Executables&lt;/em&gt;），这部分内容以后会详细讲解。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;64-bit&lt;/code&gt;, &lt;code&gt;RISC-V&lt;/code&gt;, &lt;code&gt;double-float ABI&lt;/code&gt;，&lt;code&gt;GNU/Linux 4.15.0&lt;/code&gt;：这些信息表明当前可执行文件的目标架构、目标平台以及目标平台的一些细致信息。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;LSB&lt;/code&gt;：表明当前文件里的数据是 &lt;em&gt;低端字节&lt;/em&gt; 优先（&lt;em&gt;least-significant byte&lt;/em&gt; first）的，也就是平常说的 &lt;em&gt;低端序&lt;/em&gt;（&lt;em&gt;little-endian&lt;/em&gt;）。跟 &lt;code&gt;LSB&lt;/code&gt; 相反的是 &lt;code&gt;MSB&lt;/code&gt;，即 &lt;em&gt;高端字节&lt;/em&gt; 优先（&lt;em&gt;most-significant byte&lt;/em&gt; first），也就是平常说的 &lt;em&gt;高端序&lt;/em&gt;（&lt;em&gt;big-endian&lt;/em&gt;）。字节顺序决定了一个整数（比如 int32 和 int64 等必须由多个字节组成的整数）在内存或者磁盘中如何储存。比如数字 &lt;code&gt;0x11223344&lt;/code&gt;，如果在内存中使用 &lt;code&gt;LSB&lt;/code&gt; 存储，则各个字节的排列顺序为 &amp;ldquo;44 33 22 11&amp;rdquo;，如果使用 &lt;code&gt;MSB&lt;/code&gt; 存储，则排列顺序为 &amp;ldquo;11 22 33 44&amp;rdquo;。用十六进制查看器查看 &lt;code&gt;LSB&lt;/code&gt; 字节序的可执行文件的内容时，如果看的内容是整数，那么需要在脑海里把整数当中的各个字节顺序反过来再组合才是它的真实值，而如果看的内容是字符串，则可以按看到的顺序阅读。简单来说，看数字需要反转一次，而文本内容（仅限 ASCII 文本）则可以直接阅读，而 &lt;code&gt;MSB&lt;/code&gt; 则刚好相反。不过这都是人类才有的烦恼，对于计算机来说都是一样的。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;with debug_info&lt;/code&gt;, &lt;code&gt;not stripped&lt;/code&gt;：表明当前可执行文件里包含调试信息。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;code&gt;file&lt;/code&gt; 命令只能非常粗略地查看文件的格式和基本信息，如果想查看可执行文件的详细内容，需要 GNU Toolchain 里面一组叫做 &lt;a href=&#34;https://www.gnu.org/software/binutils/&#34;&gt;GNU Binutils&lt;/a&gt; 的工具，后面的章节会详细讲解。&lt;/p&gt;&lt;h2 id=&#34;5-运行&#34;&gt;5. 运行&lt;/h2&gt;&lt;p&gt;如果你尝试直接运行上面编译得到的 &lt;code&gt;app.elf&lt;/code&gt;，就会发现它没法正常运行。这是因为该可执行文件的目标架构是 RISC-V（这里假设你当前的机器不是 RISC-V 架构的），为了运行该程序，比较方便的方法是使用模拟器（emulator）来模拟一个 RISC-V 的机器。&lt;/p&gt;&lt;p&gt;一般大家熟知的 &lt;em&gt;虚拟机软件&lt;/em&gt;（&lt;em&gt;virtualization software&lt;/em&gt;，严格来说应该翻译作 &lt;em&gt;虚拟化软件&lt;/em&gt;），比如 VirtualBox、VMWare 等只能虚拟一台跟主机（host machine）架构一样的机器，也就是说，这些软件所提供的虚拟处理器（CPU）实际上是由主机上 CPU 硬件提供的。如果需要虚拟一台不同架构的机器，则需要使用模拟器，比如 &lt;a href=&#34;https://www.qemu.org/&#34;&gt;QEMU&lt;/a&gt; 来实现。模拟器使用软件来模拟目标 CPU，然后再模拟一些诸如网络接口、图形接口、固态存储驱动器等外设，从而封装形成一台虚拟的机器。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;请注意在编程语言的运行时（runtime）里也时常提到虚拟机（vm，virtual machine）这个名称，这是跟上述的模拟器比较接近的概念。就是运行时模拟了一个比较理想化的处理器（这个处理器跟主机上的处理器在架构上完全没关联），然后让这个处理器来执行特定编程语言编译出来的字节码。跟模拟器不同的是，vm 仅模拟处理器，而对于系统的调用和硬件的调用，都是直接重定向到主机的，所以 vm 并不是完整的一台机器。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 id=&#34;51-安装-qemu&#34;&gt;5.1 安装 QEMU&lt;/h3&gt;&lt;p&gt;QEMU 是一款开源免费的软件，在大部分 Linux 发行版里的包仓库里都包含有 QEMU，所以只需使用系统的包管理器就可以安装 QEMU。在 &lt;em&gt;Arch Linux&lt;/em&gt; 里，软件包是：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;qemu-system-riscv&lt;/li&gt;&lt;li&gt;qemu-user&lt;/li&gt;&lt;li&gt;qemu-user-static&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;在 &lt;em&gt;Debian&lt;/em&gt;/&lt;em&gt;Ubuntu&lt;/em&gt; 里，软件包是：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;qemu-system&lt;/li&gt;&lt;li&gt;qemu-user&lt;/li&gt;&lt;li&gt;qemu-user-static&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;对于包仓库里没有 QEMU 的发行版，可以下载 QEMU 的源代码，然后根据&lt;a href=&#34;https://wiki.qemu.org/Documentation/Platforms/RISCV&#34;&gt;这篇指引&lt;/a&gt;编译安装。&lt;/p&gt;&lt;p&gt;QEMU 可以模拟一整套完整的硬件，包括 CPU、内存、磁盘、网络接口等组件，在这种模式下可以执行所有 CPU 指令，可以运行裸机程序，这种工作模式称为 &lt;em&gt;全系统模式&lt;/em&gt;；除此之外，QEMU 还可以模拟一个独立的 Linux 系统，在这种模式下可以直接运行编译目标架构不同的 Linux 应用程序，这种工作模式称为 &lt;em&gt;用户模式&lt;/em&gt;。在这种模式下，QEMU 会把应用程序当中的指令动态地转换为主机架构的指令，当然同时会转换程序当中的系统调用。&lt;/p&gt;&lt;p&gt;全系统模式使用程序 &lt;code&gt;qemu-system-riscv64&lt;/code&gt; 来启动，通过命令行参数指定机器类型、CPU 核心的数量、内存的容量、虚拟磁盘等配置。用户模式使用程序 &lt;code&gt;qemu-riscv64&lt;/code&gt; 来启动，把我们写的应用程序（可执行文件）的文件路径作为参数传给 &lt;code&gt;qemu-riscv64&lt;/code&gt; 即可。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;QEMU 出自一位颇具传奇色彩的程序员 &lt;a href=&#34;https://bellard.org/&#34;&gt;Fabrice Bellard&lt;/a&gt; 之手，他写的 &lt;a href=&#34;http://ffmpeg.org/&#34;&gt;FFmpeg&lt;/a&gt; 几乎存在每一台计算机里（尽管可能很多人都不知道，但却是真的），大部分媒体播放器软件及视频编辑软件都依赖它，另外他还写了 TCC、QuickJS 等出名的程序。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 id=&#34;52-尝试运行程序&#34;&gt;5.2 尝试运行程序&lt;/h3&gt;&lt;p&gt;如果使用全系统模式运行我们的程序，还需要给虚拟机配置系统引导器、一个包含有 RISC-V 架构版本的 Linux 系统的虚拟磁盘，另外还需要把应用程序复制进虚拟系统等。所以为了快速把上面写的 &amp;ldquo;Hello, World!&amp;rdquo; 程序跑起来，下面使用用户模式来运行：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ qemu-riscv64 app.elf&lt;/code&gt;&lt;/p&gt;&lt;p&gt;运行的结果是：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;qemu-riscv64: Could not open &amp;#39;/lib/ld-linux-riscv64-lp64d.so.1&amp;#39;: No such file or directory&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;显然程序并没有正确地运行。GCC 默认产生动态链接类型的程序，这种程序在运行时需要一个 &lt;em&gt;运行时动态链接器&lt;/em&gt; 来加载程序所需的共享库，以及进行一系列的初始化工作。运行时动态链接器即程序 &lt;code&gt;ld.so&lt;/code&gt;，在当前的例子里，它就是错误信息里显示的那个 &lt;code&gt;/lib/ld-linux-riscv64-lp64d.so.1&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;GCC 默认产生的程序是假定在 &amp;ldquo;普通的 Linux 系统&amp;rdquo; 里运行，而当前我们是在 &lt;em&gt;QEMU 用户模式&lt;/em&gt; 这种特殊的环境里。从 &amp;ldquo;Hello, World!&amp;rdquo; 程序的角度来看，它并不知道自己运行在特殊的环境里，而以为运行在一个 RISC-V 架构的 Linux 系统里，所以就如同往常一样，寻找动态链接器 &lt;code&gt;/lib/ld-linux-riscv64-lp64d.so.1&lt;/code&gt;。而实际上我们当前环境（作者的机器）的是 &lt;em&gt;x86_64&lt;/em&gt; 版的 Linux 系统，动态链接器是 &lt;code&gt;/lib/ld-linux-x86-64.so.2&lt;/code&gt;。QEMU 用户模式仅转换 CPU 指令，而不会转换其它数据比如文件路径，所以程序运行失败。&lt;/p&gt;&lt;h3 id=&#34;53-指定动态链接器路径&#34;&gt;5.3 指定动态链接器路径&lt;/h3&gt;&lt;p&gt;如果你的系统是 &lt;em&gt;Arch Linux&lt;/em&gt;，并且安装了软件包 &lt;code&gt;riscv64-linux-gnu-glibc&lt;/code&gt;，会发现系统里的确存在文件 &lt;code&gt;ld-linux-riscv64-lp64d.so.1&lt;/code&gt;，但它的路径是 &lt;code&gt;/usr/riscv64-linux-gnu/lib/ld-linux-riscv64-lp64d.so.1&lt;/code&gt;。按照 &lt;code&gt;qemu-riscv64&lt;/code&gt; 的说明，通过参数 &lt;code&gt;-L&lt;/code&gt; 或者环境变量 &lt;code&gt;QEMU_LD_PREFIX&lt;/code&gt; 传入一个路径，QEMU 就会把这个路径作为前缀添加到 ELF 的 &lt;code&gt;interpreter&lt;/code&gt; 指定的程序的前面。&lt;/p&gt;&lt;p&gt;因此可以这样运行 &amp;ldquo;app.elf&amp;rdquo; 程序：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;$ qemu-riscv64 -L /usr/riscv64-linux-gnu/ app.elf&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;$ QEMU_LD_PREFIX=/usr/riscv64-linux-gnu/ qemu-riscv64 app.elf&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;如无意外，上面两个命令都能正确运行，能看到程序输出的 &amp;ldquo;Hello, World!&amp;rdquo; 文本。&lt;/p&gt;&lt;p&gt;&lt;img src=&#34;./images/qemu-user.png&#34; alt=&#34;QEMU User Mode&#34;&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;在 Linux 系统里，可以使用 &lt;code&gt;locate&lt;/code&gt; 命令快速定位所需的文件，比如命令 &lt;code&gt;$ locate lp64d.so.1&lt;/code&gt; 可以帮你找到动态链接器的路径。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 id=&#34;54-编译为静态链接类型的程序&#34;&gt;5.4 编译为静态链接类型的程序&lt;/h3&gt;&lt;p&gt;除了通过指定 &lt;em&gt;QEMU 用户模式&lt;/em&gt; 的动态链接器来运行程序之外，还有另外一个方法，就是让 GCC 生成静态链接类型的可执行文件。&lt;/p&gt;&lt;p&gt;所谓静态链接程序，就是把外部函数的二进制代码（即指令序列）在编译时复制到目标可执行文件里，这样程序在运行时就不再需要其它共享库，当然也就不再需要动态链接器 &lt;code&gt;ld.so&lt;/code&gt; 了。在 GCC 编译命令里添加 &lt;code&gt;-static&lt;/code&gt; 参数可指示 GCC 生成静态链接的程序，修改后的编译命令如下：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ riscv64-linux-gnu-gcc -static -o app-static.elf app.c&lt;/code&gt;&lt;/p&gt;&lt;p&gt;先使用 &lt;code&gt;file&lt;/code&gt; 命令查看文件的格式：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ file app-static.elf&lt;/code&gt;&lt;/p&gt;&lt;p&gt;输出的部分结果如下：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;app-static.elf: ... statically linked ...&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可见原先的 &amp;ldquo;dynamically linked&amp;rdquo; 已经变为 &amp;ldquo;statically linked&amp;rdquo;。&lt;/p&gt;&lt;p&gt;然后用 &lt;code&gt;qemu-riscv64&lt;/code&gt; 运行这个程序：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ qemu-riscv64 app-static.elf&lt;/code&gt;&lt;/p&gt;&lt;p&gt;这次不需要参数 &lt;code&gt;-L&lt;/code&gt; 或者环境变量 &lt;code&gt;QEMU_LD_PREFIX&lt;/code&gt; 就能正确运行 &amp;ldquo;Hello, World!&amp;rdquo; 程序了。这是因为，静态链接类型的程序不需要任何外界的共享库，程序自己负责实现所有的功能，自己实现不了的功能则通过 &lt;em&gt;系统调用&lt;/em&gt; 向内核求助。换句话说，对于静态链接类型的程序，除非它需要读写硬盘上的文件，否则它完全无视当前的文件系统。&lt;/p&gt;&lt;p&gt;既然静态类型的程序在使用时这么自由这么方便，为什么不把所有的程序都编译成静态链接类型的呢？让我们比较同一个 &amp;ldquo;Hello, World!&amp;rdquo; 程序的动态链接类型和静态链接类型的文件大小：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ ls -lh&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;total 668K&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-rw-r--r-- 1 yang yang   78 Nov 26 04:00 app.c&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-rwxr-xr-x 1 yang yang 9.8K Nov 27 13:38 app.elf&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-rwxr-xr-x 1 yang yang 645K Nov 27 21:40 app-static.elf&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;结果显示动态类型的程序大小是 &lt;code&gt;9.8K&lt;/code&gt;，而静态类型的程序是 &lt;code&gt;645K&lt;/code&gt;，后者比前者大了许多，那是因为编译器把 &lt;code&gt;printf&lt;/code&gt; 函数所需要的函数的代码（即二进制指令）都复制到目标可执行文件里头了。静态链接类型的程序不止体积大，加载时也会消耗更多的时间，在运行时也会占用更多的内存。而同一个动态共享库在一个系统里只需加载一次，然后通过内存映射的方式共享给所有应用程序使用。因此动态链接类型的程序加载速度快，占用内存少。当一个程序直接或间接引用很多库时，这两者的区别会更大。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;em&gt;动态链接&lt;/em&gt; 对系统来说是个不错的机制，但它带来的问题也相当令人头痛。在日常使用 Linux 经验里，很少有程序能下载即能运行，大部分情况都会出现共享库找不到或者版本不匹配等错误。如果要安装一个在软件包仓库里不存在的程序，则只能通过编译源代码的方式来安装了，这种方式对于普通用户（非专业用户）来说无疑难度太大。作者认为这个问题是因为过度使用共享库引起的，很多细小且不是很通用的库实际上没必要作为共享库。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;我们即将要实现的操作系统，将完全禁止用户向系统添加全局的共享库，全局共享库仅限非常通用且有必要的库，并由内核维护者来维护。而且应用程序也应该相互隔离，即一个程序自带的共享库只能由程序自己或者子程序使用，而不能提供给其它程序使用。以此机制从根本上解决共享库带来的便携性问题，减少应用程序分发、用户安装和使用的麻烦，并且再也不需要第三方维护者，应用程序的更新将会更加有效、及时。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 id=&#34;55-改变程序的动态链接器&#34;&gt;5.5 改变程序的动态链接器&lt;/h3&gt;&lt;p&gt;除了上面的两种方法，还能通过修改程序的动态链接器来让程序运行起来。具体来说就是在编译时传入链接参数 &lt;code&gt;--dynamic-linker&lt;/code&gt; 以更改程序的 &lt;code&gt;interpreter&lt;/code&gt; 值，命令如下：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ riscv64-linux-gnu-gcc -g -Wall -Wl,--dynamic-linker,/usr/riscv64-linux-gnu/lib/ld-linux-riscv64-lp64d.so.1 -o app-inter.elf app.c -L /usr/riscv64-linux-gnu/lib -lc&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;命令当中的参数 &lt;code&gt;-Wl,--dynamic-linker,...&lt;/code&gt; 的作用是向链接器传递参数；参数 &lt;code&gt;-L ...&lt;/code&gt; 用于指定链接器搜索共享库的路径；参数 &lt;code&gt;-lc&lt;/code&gt; 用于指定链接共享库 &lt;code&gt;libc.so&lt;/code&gt;。这些参数在后面的章节还会详细讲解。&lt;/p&gt;&lt;p&gt;编译完毕之后，使用 &lt;code&gt;file&lt;/code&gt; 命令检查程序：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ file app-inter.elf&lt;/code&gt;&lt;/p&gt;&lt;p&gt;输出的部分结果如下：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;app-inter.elf: ... interpreter /usr/riscv64-linux-gnu/lib/ld-linux-riscv64-lp64d.so.1 ...&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可见程序的 &lt;code&gt;interpreter&lt;/code&gt; 已经更改为指定的路径了。然而运行这程序时又有新的错误提示：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ qemu-riscv64 app-inter.elf&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;app-inter.elf: error while loading shared libraries: libc.so.6: cannot open shared object file: No such file or directory&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;看来 RISC-V 版的 &lt;code&gt;ld.so&lt;/code&gt; 已经起作用了，但这个动态链接器找不到 RISC-V 版的共享库 &lt;code&gt;libc.so.6&lt;/code&gt;。这个问题比较好解决，只要通过环境变量 &lt;code&gt;LD_LIBRARY_PATH&lt;/code&gt; 就可以指定程序所依赖的共享库的路径，例如：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ LD_LIBRARY_PATH=/usr/riscv64-linux-gnu/lib qemu-riscv64 app-inter.elf&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&#34;./images/interpreter-path.png&#34; alt=&#34;Interpreter Path&#34;&gt;&lt;/p&gt;&lt;p&gt;程序同样能正确运行。不过这种方法并没有太大用处，因为比前面两种方法复杂太多，而且生成的程序只适合在当前机器上 &lt;em&gt;QEMU 用户模式&lt;/em&gt; 里运行，没法在标准的 RISC-V 架构的 Linux 环境里运行。这里主要是为了演示如何修改程序的 &lt;code&gt;interpreter&lt;/code&gt;。有关动态链接器的详细资料可以通过命令 &lt;code&gt;$ man ld.so&lt;/code&gt; 调出文档查看。&lt;/p&gt;&lt;h2 id=&#34;6-分阶段编译&#34;&gt;6. 分阶段编译&lt;/h2&gt;&lt;p&gt;当执行命令 &lt;code&gt;riscv64-linux-gnu-gcc&lt;/code&gt; 将一个 C 源代码编译为一个可执行文件时，实际上 GCC 是分 4 个阶段（或者说步骤）来完成的：&lt;/p&gt;&lt;p&gt;&lt;img src=&#34;images/gcc-compile-stage.png&#34; alt=&#34;GCC compile stages&#34;&gt;&lt;/p&gt;&lt;h3 id=&#34;61-预处理&#34;&gt;6.1 预处理&lt;/h3&gt;&lt;p&gt;将源代码里 &lt;code&gt;#include ...&lt;/code&gt; 指定的文件复制进来，然后解析其中的条件编译指令（&lt;code&gt;#ifdef&lt;/code&gt;），展开宏（&lt;code&gt;macro&lt;/code&gt;）等。相当于命令：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ riscv64-linux-gnu-cpp app.c &amp;gt; app.i&lt;/code&gt;&lt;/p&gt;&lt;p&gt;或者&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ riscv64-linux-gnu-gcc -E app.c &amp;gt; app.i&lt;/code&gt;&lt;/p&gt;&lt;p&gt;经过预处理的 C 语言源代码文件的扩展名为 &lt;code&gt;*.i&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;注意程序 &lt;code&gt;riscv64-linux-gnu-cpp&lt;/code&gt; 当中的 &amp;ldquo;cpp&amp;rdquo; 是指 &amp;ldquo;C Preprocessor&amp;rdquo;，而不是 &amp;ldquo;C++&amp;rdquo; 的意思。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;通过 GCC 命令的 &lt;code&gt;-D&lt;/code&gt; 参数可以传递选项值到 C 代码里，用于控制代码里的条件编译指令的开关。比如 &lt;code&gt;-D DEBUG&lt;/code&gt;（等同于 &lt;code&gt;-D DEBUG=1&lt;/code&gt;）能让 C 代码里的条件编译指令 &lt;code&gt;#ifdef DEBUG ...&lt;/code&gt; 的条件值为 &lt;code&gt;真&lt;/code&gt;，详细请参阅 &lt;a href=&#34;https://gcc.gnu.org/onlinedocs/gcc/Preprocessor-Options.html&#34;&gt;GCC Preprocessor&lt;/a&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 id=&#34;62-编译&#34;&gt;6.2 编译&lt;/h3&gt;&lt;p&gt;将 C 源代码编译为汇编源代码，相当于命令：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ riscv64-linux-gnu-gcc -S app.i&lt;/code&gt;&lt;/p&gt;&lt;p&gt;生成的汇编源代码文件的扩展名为 &lt;code&gt;*.s&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;注意我们手写汇编源代码的文件扩展名一般是 &lt;code&gt;*.S&lt;/code&gt;（大写 &lt;code&gt;S&lt;/code&gt;），&lt;code&gt;*.S&lt;/code&gt; 文件在汇编时会进行预处理（比如处理 &lt;code&gt;.include&lt;/code&gt; 指令），而扩展名为 &lt;code&gt;*.s&lt;/code&gt;（小写 &lt;code&gt;s&lt;/code&gt;）则不会进行预处理。具体的扩展名和 GCC 参数可以参考&lt;a href=&#34;https://gcc.gnu.org/onlinedocs/gcc/Overall-Options.html&#34;&gt;GCC Options Controlling the Kind of Output&lt;/a&gt;。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;第 1 到第 2 步也可以合并为一步完成：&lt;code&gt;$ riscv64-linux-gnu-gcc -S app.c&lt;/code&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 id=&#34;63-汇编&#34;&gt;6.3 汇编&lt;/h3&gt;&lt;p&gt;将汇编源代码转换为机器指令序列，生成 &lt;em&gt;可重定位文件&lt;/em&gt;，相当于命令：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ riscv64-linux-gnu-as -o app.o app.s&lt;/code&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;第 1 到第 3 步也可以合并为一步完成：&lt;code&gt;$ riscv64-linux-gnu-gcc -c -o app.o app.c&lt;/code&gt;，参数 &lt;code&gt;-c&lt;/code&gt; 表示只编译但不链接。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 id=&#34;64-链接&#34;&gt;6.4 链接&lt;/h3&gt;&lt;p&gt;将一个或多个 &lt;em&gt;可重定位文件&lt;/em&gt; 连接起来，并重新定位其中的全局变量、静态变量和函数的地址，最后生成 ELF 格式的可执行文件，相当于命令：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ riscv64-linux-gnu-ld -o app.elf startup.o app.o&lt;/code&gt;&lt;/p&gt;&lt;p&gt;上面的命令会将 &lt;code&gt;startup.o&lt;/code&gt; 和 &lt;code&gt;app.o&lt;/code&gt; 两个文件链接起来生成可执行文件 &lt;code&gt;app.elf&lt;/code&gt;。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;code&gt;startup.o&lt;/code&gt; 是应用程序启动器，提供应用的入口 &lt;code&gt;_start&lt;/code&gt; 过程以及做一些初始化和清理工作，将会在下一章实现它。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;上面 4 个步骤就是命令 &lt;code&gt;$ riscv64-linux-gnu-gcc -o app.elf app.c&lt;/code&gt; 在背后进行的一系列操作，如果想知道 GCC 在编译过程中的每个步骤以及细节，可以传入 &lt;code&gt;-v&lt;/code&gt; 参数，比如 &lt;code&gt;$ riscv64-linux-gnu-gcc -v -o app.elf app.c&lt;/code&gt;，这样 GCC 会把每一步的操作都显示出来。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;在平常的编译程序任务中，我们并不需要分成 4 步。一般只需分成两个阶段：即从第 1 到第 3 步合并为 &lt;em&gt;编译&lt;/em&gt; 阶段，第 4 步则是 &lt;em&gt;链接&lt;/em&gt; 阶段。而且一般都是借助诸如 &lt;code&gt;make&lt;/code&gt; 等构建工具来完成这两个阶段。但我们仍然需要清楚知道编译过程背后有哪些步骤及其作用，理解这些概念有助于解决在编译过程遇到的各种问题。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&#34;7-常用的编译参数&#34;&gt;7. 常用的编译参数&lt;/h2&gt;&lt;p&gt;GCC 还有一些其它常用的参数：&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;-I&lt;/code&gt; 用于指定编译时的头文件的路径&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;有时头文件（&lt;code&gt;*.h&lt;/code&gt;）分布在多个目录，这时可以用参数 &lt;code&gt;-I&lt;/code&gt; 把额外的头文件的路径包含进来，比如当前的路径为 &lt;code&gt;/home/yang/hello-world/app.c&lt;/code&gt;，假如有额外的头文件位于 &lt;code&gt;/home/yang/hello-world/include/&lt;/code&gt;，则可以这样传入参数：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ riscv64-linux-gnu-gcc -I /home/yang/hello-world/include app.c&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;-L&lt;/code&gt; 和 &lt;code&gt;-l&lt;/code&gt; 分别用于指定链接时额外库的路径和名称&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;接着上一个例子，如果应用程序需要使用到共享库 &lt;code&gt;/usr/lib/hello-world/libmymath.so&lt;/code&gt;，则可以这样传入参数：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ riscv64-linux-gnu-gcc app.c -L /usr/lib/hello-world/ -lmymath&lt;/code&gt;&lt;/p&gt;&lt;p&gt;参数 &lt;code&gt;-lmymath&lt;/code&gt; 表示链接过程会使用到共享库 &lt;code&gt;libmymath.so&lt;/code&gt;。注意参数 &lt;code&gt;-l&lt;/code&gt; 的值不是库的文件名，而是库的 &amp;ldquo;soname&amp;rdquo;。比如上面例子中共享库文件的真实名称是 &lt;code&gt;libmymath.so&lt;/code&gt;，去除了前缀 &lt;code&gt;lib&lt;/code&gt; 和后缀 &lt;code&gt;.so&lt;/code&gt; 之后就是 &amp;ldquo;soname&amp;rdquo; 了。如此类推，&lt;code&gt;-lm&lt;/code&gt; 表示共享库 &lt;code&gt;libm.so&lt;/code&gt;，&lt;code&gt;-lpthread&lt;/code&gt; 表示共享库 &lt;code&gt;libpthread.so&lt;/code&gt;。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;一般把参数 &lt;code&gt;-L ... -l ...&lt;/code&gt; 放在命令的末尾，也就是遵循 &amp;ldquo;被依赖的放在后面&amp;rdquo; 的顺序。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;如果将编译任务分为 &lt;em&gt;编译&lt;/em&gt; 和 &lt;em&gt;链接&lt;/em&gt; 两步，则在编译阶段只需指定 &lt;code&gt;-I&lt;/code&gt; 参数，而链接阶段只需指定 &lt;code&gt;-L&lt;/code&gt; 和 &lt;code&gt;-l&lt;/code&gt; 参数，因为头文件仅供预处理使用的，对链接无意义，而库文件则仅供链接使用，对编译无意义。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;你可能已经发现 GCC 的参数和参数值的写法跟普通的程序不太一样，比如参数 &lt;code&gt;-lmymath&lt;/code&gt;，实际上是 &lt;code&gt;-l mymath&lt;/code&gt; 的简写，即 &lt;code&gt;-l&lt;/code&gt; 是参数名称，&lt;code&gt;mymath&lt;/code&gt; 是参数值。而参数 &lt;code&gt;-static&lt;/code&gt; 按照标准的写法应该是 &lt;code&gt;--static&lt;/code&gt;，这些特殊的写法可能是历史遗留下来的。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&#34;8-总结&#34;&gt;8. 总结&lt;/h2&gt;&lt;p&gt;这章主要讲解什么是交叉编译，以及交叉编译了一个 &amp;ldquo;Hello, World!&amp;rdquo; 程序，然后使用 QEMU 模拟一个不同架构的 Linux 环境来运行交叉编译得到的可执行文件。通过这一章我们知道如何构建一个程序，同时也知道其实交叉编译并没什么特别的地方，操作方法跟普通编译几乎一样，只是编译出来的结果（可执行文件）的运行方式不太一样而已（即我们无法在当前机器上直接运行）。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;这章是我们漫长的几个系列文章当中的第一个系列的第一章，如果你发现这章里有些地方不太明白，这是很正常的。正如 &lt;a href=&#34;../2022-10-31-building-a-modern-computer-system-from-scratch-step-by-step&#34;&gt;项目介绍&lt;/a&gt; 所说，系统技术相互交叉，有些内容必须到了后面的章节才能展开。你可以继续往下阅读，到了某个阶段时再回来这里重温一遍，可能会发现一下子全都懂了。就像看悬疑电影那样，有些伏笔到了最后会自然解开。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;如果你觉得这章的内容太难了，甚至完全不知道在讲什么。可能只是因为你对 C 语言或者说一般的编程技术，以及 Linux 环境不是很熟悉，你可以适当停下来，然后看看一些经典的书籍和教程。注意学习 C 语言一定要 Linux 环境，在其它环境里学习 C 语言你只能学会语法，然后一无所知。另外请记住计算机的每门科目都不需要一下子从头到尾看完，每次看一两章就可以停下来，然后去做点别的事情或者其它科目，让你的大脑在背后慢慢地消化。如此一段时间之后再回来看这系列文章估计就没什么问题了。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;好了，如果觉得没问题那就点击下一章吧。下一章将会构建一个简单的无需操作系统就可以独自运行的程序。&lt;/p&gt;&lt;div&gt;    &lt;img src=&#34;https://hemashushu.github.io/images/subscribe-and-donate.zh.png&#34; class=&#34;block-image image-480px&#34;/&gt;&lt;/div&gt;</description>
     </item>
   
     <item>
       <title>从零开始一步一步制作自己的工具、构建现代计算机系统 - 目录</title>
       <link>https://hemashushu.github.io/zh/posts/2022-11-01-building-a-modern-computer-system-from-scratch-index/</link>
       <pubDate>Tue, 01 Nov 2022 00:00:00 +0000</pubDate>
       
       <guid>https://hemashushu.github.io/zh/posts/2022-11-01-building-a-modern-computer-system-from-scratch-index/</guid>
       <description>&lt;p&gt;这是 &lt;em&gt;从零开始一步一步制作自己的工具、构建现代计算机系统&lt;/em&gt; 系列文章的总目录。&lt;/p&gt;&lt;p&gt;上一篇 &lt;a href=&#34;../2022-10-31-building-a-modern-computer-system-from-scratch-step-by-step&#34;&gt;简介&lt;/a&gt; 提到，该系列文章由四个系列组成，每个系列包含若干部。下面列出每一部的标题以及已完成的文章的链接，当有新文章时，这个目录也会同时更新。&lt;/p&gt;&lt;p&gt;第一个系列属于基础知识，其内容不如另外三个系列那么酷，不过建议不要跳过第一个系列。现代的计算机技术领域非常庞大且复杂，各式各样的框架和工具层出不穷，迭代速度也快到转瞬即逝的地步。如果我们仅停留在各种框架、工具和语言之间徘徊，可能穷其一生都未必能学完。不过如果我们向底层方向研究，就会发现事情会变得越来越单纯和简单，到达终点站之后再回过头来看之前那些让人头眼花缭乱的表层技术，会一下子就变得清晰而简单。第一个系列正是这样的一个 “透过现象看本质” 的过程，通过这个系列，我们就能对系统技术有一个准确的理解。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;很多人都看过 &lt;a href=&#34;https://en.wikipedia.org/wiki/Mandelbrot_set&#34;&gt;&lt;em&gt;曼德博集合&lt;/em&gt;&lt;/a&gt;（Mandelbrot set）的&lt;a href=&#34;https://en.wikipedia.org/wiki/Fractal&#34;&gt;分形图形&lt;/a&gt;，这种图形可以无限地放大和移动，而且总会有千变万化而美丽的图形产生。我们可以像浏览我们宇宙的星系一样，即使花上一整天的时间来遨游也不会觉得枯燥。但让人难以置信的是，这个无比庞大且复杂的宇宙其实只是一条简单的数学函数产生的：$y = x^2 + z$，只需把 $y$ 的值不断代入 $x$，大爆炸就产生了。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&#34;系列-1-一步一步深入-risc-v-系统&#34;&gt;系列 1: 一步一步深入 RISC-V 系统&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;第一部：了解编译器、链接器、调试器以及一些常用二进制工具的使用方法，了解程序的组成，构建最小独立式可执行程序（freestanding，也叫 &lt;em&gt;裸机程序&lt;/em&gt;）等；&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&#34;../2022-11-05-s01c01-cross-compile-and-run-the-first-program&#34;&gt;S01C01 什么是交叉编译？GCC 交叉编译及运行第一个程序&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;../2022-11-06-s01c02-write-a-program-run-alone-without-os&#34;&gt;S01C02 编写一个无需操作系统，可独自运行的 Hello World 程序&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;../2022-11-07-s01c03-uncovering-the-elf-executable-file-making-a-minimal-hello-world-program&#34;&gt;S01C03 揭秘 ELF 可执行文件，制作一个只有 70 字节的最小 Hello World 程序&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;第二部：通过微控制器（MCU）来简单地了解软件和硬件之间的交互原理，通过不使用 SDK 或者硬件抽象库（HAL），而是直接读写寄存器的方式编写裸机程序（固件），控制电信号的输入输出（GPIO），实现串口通信等；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;第三部：了解现代系统的程序加载、动态链接的原理，了解 RISC-V 的函数调用规程以及基本指令，使用汇编语言编写简单的程序；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;第四部：设计一门目标架构为 RISC-V 的汇编语言，实现其汇编器，同时了解简单的语法解析器的原理；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;第五部：设计一门链接脚本语言，实现其链接器，同时了解脚本解析器的原理。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 id=&#34;系列-2-一步一步实现一门现代语言及其编译器&#34;&gt;系列 2: 一步一步实现一门现代语言及其编译器&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;第一部：设计一门中间语言（IR），实现从中间语言到汇编语言的代码生成器（code generator）；&lt;/li&gt;&lt;li&gt;第二部：设计一门现代的静态类型的语言，实现高级语言到中间语言的代码生成器，至此完成了一个 &lt;em&gt;简单的完整的编译系统&lt;/em&gt;；&lt;/li&gt;&lt;li&gt;第三部：实现 &lt;a href=&#34;https://webassembly.org/&#34;&gt;WASM&lt;/a&gt; 虚拟机（VM），然后实现中间语言到 WASM 的代码生成器。实现 WASM VM 的同时可以大致地认识一个处理器是如何工作的，另一方面有了 WASM 代码生成器，意味着我们的语言能在浏览器中运行；&lt;/li&gt;&lt;li&gt;第四部：实现中间语言到 ARM 和 RISC-V 汇编的生成器。&lt;/li&gt;&lt;li&gt;第五部：实现中间语言到 &lt;a href=&#34;https://llvm.org/docs/LangRef.html&#34;&gt;LLVM IR&lt;/a&gt; 的代码生成器。&lt;/li&gt;&lt;li&gt;第六部：实现项目构建器及包管理器。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img src=&#34;images/compilation-system.png&#34; alt=&#34;compilation system&#34;&gt;&lt;/p&gt;&lt;h2 id=&#34;系列-3-一步一步实现一个实用型的-risc-v-cpu&#34;&gt;系列 3: 一步一步实现一个实用型的 RISC-V CPU&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;第一部：设计一个最小的指令集，实现数字累加和内存加载和存储功能；然后通过数字电路仿真软件实现一个最简处理器，该处理器包含了 ROM、RAM、寄存器堆（register file）、译码器、控制器及算术逻辑单元（ALU）等基本处理器要素，能执行我们的指令集。通过这一部来了解处理器的基本运作原理，以及软件如何变成电信号。&lt;/li&gt;&lt;li&gt;第二部：从我们的语言派生出一门 HDL 语言，实现该门语言的数字逻辑电路模拟器以及测试（验证）框架；实现从这门语言到 &lt;a href=&#34;https://en.wikipedia.org/wiki/SystemVerilog&#34;&gt;SystemVerilog&lt;/a&gt; 的代码生成器，然后用这门语言重新实现上一部的基础组件以及处理器，并下载到 FPGA 硬件上通电测试；&lt;/li&gt;&lt;li&gt;第三部：使用自己的 HDL 语言实现一个多时钟周期的 RV64I 处理器，并下载到 FPGA 硬件上通电测试；&lt;/li&gt;&lt;li&gt;第四部：实现常见的通信协议（比如 UART、$I^2C$、SPI），书写常见的外设（比如 GPIO 接口、SPI Flash、SD 卡、SSD 1306 显示屏等）的驱动。整合我们的处理器，实现一个完整的硬件系统；&lt;/li&gt;&lt;li&gt;第五部：将处理器微架构升级为多级流水线设计。&lt;/li&gt;&lt;/ul&gt;&lt;h2 id=&#34;系列-4-一步一步实现一个实用的微内核操作系统&#34;&gt;系列 4: 一步一步实现一个实用的微内核操作系统&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;第一部：为处理器添加内存管理单元（MMU）以及特权相关的模块；&lt;/li&gt;&lt;li&gt;第二部：实现最小的内核，即实现基本的串口输入输出，多级页表内存管理，程序的加载及进程的简单切换，以及消息机制等；&lt;/li&gt;&lt;li&gt;第三部：实现一个简单的文件系统；&lt;/li&gt;&lt;li&gt;第四部：实现简单的用户交互界面（shell）；&lt;/li&gt;&lt;li&gt;第五部：实现简单的网络接口；&lt;/li&gt;&lt;li&gt;第六部：实现一个包管理器；&lt;/li&gt;&lt;li&gt;第七部：为处理器添加浮点运算模块，以及一个矩阵计算协处理器（coprocessor）；&lt;/li&gt;&lt;li&gt;第八部：实现一个简单的机器学习库，实现手写数字识别程序；&lt;/li&gt;&lt;li&gt;第九部：实现一个简单的图形加速协处理器；&lt;/li&gt;&lt;li&gt;第十部：实现一个简单的图形库，一个简单的物理引擎，实现一个复古风格的横向卷轴动作游戏。&lt;/li&gt;&lt;/ul&gt;&lt;div&gt;    &lt;img src=&#34;https://hemashushu.github.io/images/subscribe-and-donate.zh.png&#34; class=&#34;block-image image-480px&#34;/&gt;&lt;/div&gt;</description>
     </item>
   
     <item>
       <title>从零开始一步一步制作自己的工具、构建现代计算机系统 - 简介</title>
       <link>https://hemashushu.github.io/zh/posts/2022-10-31-building-a-modern-computer-system-from-scratch-step-by-step/</link>
       <pubDate>Mon, 31 Oct 2022 14:34:52 +0800</pubDate>
       
       <guid>https://hemashushu.github.io/zh/posts/2022-10-31-building-a-modern-computer-system-from-scratch-step-by-step/</guid>
       <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&lt;p&gt;RISC-V 是最近几年热门的计算机指令集，相信已经有不少朋友已经尝试过编译 RISC-V 版的 Linux 内核，或者跟着教程编写 RISC-V 版的玩具操作系统、玩具编程语言和编译器，甚至用 HDL（硬件描述语言）编写自己的玩具 RISC-V CPU。&lt;/p&gt;&lt;p&gt;无论是哪种，刚开始时你肯定既激动又兴奋，就像要在一个异世界开始一段新冒险的勇者那样。不过当你翻到教程的第二章，你可能就开始眉头紧锁，然后咬着牙又翻了几章，经过一番挣扎最后只能放弃。这时候你可能很疑惑：“明明写了几年的程序，各种算法题早已不放在眼里，为什么还是看不懂这些教程呢？！&amp;quot;&lt;/p&gt;&lt;p&gt;显然这是因为缺少对完整的 &lt;em&gt;系统技术&lt;/em&gt;（有时也叫 &lt;em&gt;计算机基础&lt;/em&gt;，&lt;em&gt;底层技术&lt;/em&gt; 或者 &lt;em&gt;核心技术&lt;/em&gt;，下面统一称为 &lt;em&gt;系统技术&lt;/em&gt;）的了解，你可能会反驳：”系统技术嘛，在计算机基础课程里我早就学过了，考试也通过了！“。是的，在计算机专业的课程里都设置有诸如 &lt;em&gt;组成原理&lt;/em&gt;、&lt;em&gt;编译原理&lt;/em&gt;、&lt;em&gt;操作系统&lt;/em&gt; 等课程，还因担心你一下子吸收不了而一门一门地分好几个学期教学。不过&lt;strong&gt;把这些科目分开学习是错误的&lt;/strong&gt;，因为系统技术是相互交叉的。&lt;/p&gt;&lt;p&gt;&lt;img src=&#34;images/path.zh.png&#34; alt=&#34;path&#34;&gt;&lt;em&gt;螺旋式的学习路径&lt;/em&gt;&lt;/p&gt;&lt;p&gt;计算机系统包括了 &lt;em&gt;语言&lt;/em&gt;、&lt;em&gt;处理器&lt;/em&gt; 和 &lt;em&gt;操作系统&lt;/em&gt; 三个基本组成部分。如果从远距离来看，处理器和操作系统会是同一回事，它们共同构建了一种人类历史上最复杂的机器 ———— 计算机。处理器负责实现不变的逻辑运算，而操作系统则是处理器的自然延伸，负责实现需要变化的部分。至于语言则用于表达、封装和抽象机器的功能，使得机器和人类之间的交流成为可能。可见它们是同一个目的 ———— 让机器解决问题的不同侧面，分开学习自然无法理解其中的联系和缘由。不妨把每一个领域想象成一根根立起来的柱子，正确的学习路径是围绕着这些柱子&lt;strong&gt;螺旋式地逐渐地往上爬&lt;/strong&gt;，而不是一口气爬完一根柱子，然后滑下来再爬另一根柱子。&lt;/p&gt;&lt;p&gt;其次学习方法也存在问题，系统技术大多是工程师们在不断地解决问题之后得出的经验总结及其知识积累，也就是说，理论并不是起主导作用，更多是通过各种尝试后得出的 &lt;em&gt;最佳实践&lt;/em&gt;。因此较好的的学习方法应该是先从探索和尝试开始入手，然后&lt;strong&gt;边实践边试错、边领会边总结&lt;/strong&gt;，而不是先学一大堆原理，再做完一堆习题，最后才开始实践。&lt;/p&gt;&lt;p&gt;&lt;img src=&#34;images/way.zh.png&#34; alt=&#34;way&#34;&gt;&lt;/p&gt;&lt;p&gt;总的来说，虽然我们几乎都学过跟系统技术相关的科目，但因为我们的学习过程跟系统的构建方式和过程都相差甚远，所以实际上并没有真正掌握到这些技术。不妨试试在没有网络的帮助下，看看能否自己设计一套最简的指令集，然后动手画画微架构（microarchitecture）的大致数据通路（data path）；或者给定一个目标硬件平台，编写一个冷启动的引导程序；又或者不依赖任何库，从零开始手写一个简单的语法解析器。你会发现即使这些内容都是刚刚学完的但实现起来却很困难。&lt;/p&gt;&lt;h2 id=&#34;特点&#34;&gt;特点&lt;/h2&gt;&lt;p&gt;实际上我们在平时的学习和工作当中已经积累了一定的系统知识，只是它们是松散的或者不完整的，我希望能通过一系列文章，把这些知识有序地连接起来，从而成为你真正掌握的知识和技术。这系列文章有如下特点：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;不再是 “先讲原理然后做项目”，而是从探索和尝试入手，在实践和试错过程中再穿插原理（有时我还会穿插一些小典故）。而且跟很多实践型教程不一样，这系列不单单讲 &lt;strong&gt;如何做&lt;/strong&gt;，还会讲解 &lt;strong&gt;为什么要这样做&lt;/strong&gt;。很多实践型教程往往忽视了第二点，它们一般是哗啦啦地把每个操作步骤、包括屏幕截图和输入的每个参数等罗列出来，或者给你看一段很长配上旁白的操作过程视频，你必须严格跟着指引一步一步走才能最后成功。虽然跟着这些教程你也能做出 “作品”，不过对其中的缘由你肯定非常模糊。而且这些操作指引对环境和工具非常依赖，常常因为软硬件环境的变化或者工具的版本的更新，导致其中某些步骤有细微变化而跟教程不一致，最后无法成功。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;不再分学科，而是根据系统的构建过程以及我们能理解的程度，把整个系列切分为多个小阶段，每个小阶都会同时涉及多个学科的知识。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;不需要任何专门的软件和硬件&lt;/strong&gt;，很多专业的系统技术教程或者培训需要各种高大上的昂贵的专业软件和硬件，而这个系列只使用几个通用的开源免费的软件，和几个最广泛使用的最廉价的不超过一两百元的必要硬件模块，即可以完成到最后一章。（当然这系列的文章是免费的，文章当中也不会有任何广告或者推广链接 😄）。除了节省金钱，最重要的是这个系列不是为了让你成为某个软件或者硬件的操作工和使用者，而是让你自己创造工具构建系统。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;不需要任何专门的 IDE、SDK 或者库&lt;/strong&gt;，全部从零开始构建。开始阶段只需几个通用的开源免费的编译器和工具，后面则会使用自己的工具。因为连工具都是自己构建的，因此可以彻底弄明白每一个技术细节而不会留有死角。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;不是科普，不是走马观花式的观摩，而是真正深入地对计算机系统的完整实践。通过这一系列文章，你会对系统有正确的认识和理解，可以不被那些流传广泛而实则错误的各种时髦 “知识” 所迷惑。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;这一系列文章会以 RISC-V 作为学习和实现的目标架构，之所以选择 RISC-V 原因有：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;它的指令集相对比较简单，这使得我们自己动手实现 &amp;ldquo;最小的能工作的&amp;rdquo; 编译器及处理器成为可能；&lt;/li&gt;&lt;li&gt;有大量相关的开源免费的工具和文档，可以享用现有的工具来检查和验证我们的 &amp;ldquo;作品&amp;rdquo; 是否正确，这对摸索和学习过程非常重要；&lt;/li&gt;&lt;li&gt;最后如果我们做出了产品，也无需顾虑授权问题。&lt;/li&gt;&lt;/ul&gt;&lt;h2 id=&#34;内容概况&#34;&gt;内容概况&lt;/h2&gt;&lt;p&gt;无可否认系统技术的内容非常之多，它是几十年以来成千上万个全球最顶尖工程师的总结和积累，无论是广度还是深度都几乎逼近人脑的极限，甚至可以说它是远超越我们当前时代的一群人的作品。河马蜀黍知道无法简单地通过几篇文章就能讲完，所以准备了四个系列（series），每个系列分为若干部（part），每部含若干篇文章（chapter）。好吧，一共也就百来篇长文。用一句话描述这一系列文章的主要内容就是：&lt;strong&gt;学习现有的工具和系统，制作自己的工具，打造新的系统&lt;/strong&gt;。你可能已经阅读过类似 “从零开始构建系统” 的书籍或文章，不过当前这个系列不但要构建系统，还会制作构建系统的工具，相信仍会让你感到耳目一新 😁。&lt;/p&gt;&lt;p&gt;&lt;img src=&#34;images/content.zh.png&#34; alt=&#34;content&#34;&gt;&lt;/p&gt;&lt;p&gt;虽然内容非常多，不过你不用担心难度过高而无法完成，因为每一个部分虽然名堂很大，但都是仅实现 &amp;ldquo;刚好能用&amp;rdquo; 的程度即止。最主要的是，系统技术的每一个小环节只要单独拿出来分析和实践都会出乎意料地简单，所以只需一步步跟着来，就不会发生在中途就被卡住的情况。当然我也会在 “简陋” 和 “实用” 之间平衡，让每一个 “作品” 都有实用价值。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;有时并不是系统技术本身真的很难，而是你遇到了糟糕的教材，或者没有遇到好老师。我发现编写优秀的经典的教材虽然不少，而且也很容易获得，只是往往会被巨量而劣质的信息所掩盖。选择对的教材很重要。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;现代主流的系统技术都有沉重的历史包袱，比如 GCC 已有三十多年的历史，Linux 内核也持续开发三十年，对于新手来说，无论是阅读理解、修改、扩充都非常困难，而且很多新观念无法整合。而我们的系统因为是从零开始，完全没有包袱，所以实现起来相对会简单轻松，有些顽固问题也可以从根本上解决；新理念（严格来说并不是新的，只是鲜有人知而已）也能无所顾忌地加入，比如：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;一门语言可以同时用于硬件开发、底层开发、应用开发和前端开发；&lt;/li&gt;&lt;li&gt;一门阅读友好的汇编语言；&lt;/li&gt;&lt;li&gt;一门函数型的脚本语言，既可作为 Shell 脚本，也可作为链接脚本；&lt;/li&gt;&lt;li&gt;一个使用微内核的系统，方便开发、调试、安装和发布（驱动程序也能像普通程序一样轻松开发），系统更新无需重启且可回滚；&lt;/li&gt;&lt;li&gt;基于能力（capability）而不是 &lt;em&gt;用户和组&lt;/em&gt; 的系统安全模型；&lt;/li&gt;&lt;li&gt;数据结构化的 Shell；&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;当然还有很多特性，在具体章节里会再详细列举。&lt;/p&gt;&lt;h2 id=&#34;点赞转发打赏&#34;&gt;点赞、转发、打赏&lt;/h2&gt;&lt;p&gt;虽然这系列文章的大部分内容我都已经实践过，不过我发现要把它们从头到尾讲解起来相当有挑战性：庞大而交叉的内容如何组织，如何挑选实践的内容，如何做到篇章之间的自然过渡和衔接，如何确保知识的准确，如何让读者看得轻松有趣等等，单单第一个系列的前 8 篇文章，经过反复琢磨和修改，前后居然花了四个多月的时间。我不知道还要多少时间才能把最后一章写完 😵‍💫。&lt;/p&gt;&lt;p&gt;而另一方面，虽然从宏观上来说系统技术承载着科学技术的传承和创新等重任，也是现代工业的基础，但对于个人来说，却很 &amp;ldquo;现实地&amp;rdquo; 没有多少用处（💰），毕竟几乎所有企业都从事应用层面的开发，系统技术无论是对普通人还是对开发人员都太过遥远了。&lt;/p&gt;&lt;p&gt;虽然我会努力地写好每一篇文章，但显然，阅读的人肯定是寥寥可数的，这其中又只有极其少数人才会感兴趣。因此，如果你碰巧看到这一系列文章，如果觉得有收获，请毫不犹豫地打赏我吧！你的一瓶可乐一杯咖啡的打赏就是我下一篇文章的写作动力啦 😄。&lt;/p&gt;&lt;p&gt;最后，虽然系统技术 &amp;ldquo;几乎没用&amp;rdquo;，但它却能可以很好地满足你的 “好奇、探索，创造” 原始天性。试想一下，还有什么比 “独自一人徒手征服人类史上最复杂的机器” 更酷的事情呢？！当你完成最后一章时，相信会看到一个不同的世界。点击 &lt;a href=&#34;../2022-11-01-building-a-modern-computer-system-from-scratch-index&#34;&gt;文章目录&lt;/a&gt; 开始异世界之旅吧！&lt;/p&gt;&lt;div&gt;    &lt;img src=&#34;https://hemashushu.github.io/images/subscribe-and-donate.zh.png&#34; class=&#34;block-image image-480px&#34;/&gt;&lt;/div&gt;</description>
     </item>
   
 </channel>
</rss>
