
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
 <channel>
   <title>tutorial on 河马蜀黍真是的</title>
   <link>https://hemashushu.github.io/categories/tutorial/</link>
   <description>Recent content in tutorial on 河马蜀黍真是的</description>
   <generator>Hugo -- gohugo.io</generator>
   <language>en-us</language>
   <copyright>Copyright &amp;copy; 2022 - Hippospark</copyright>
   <lastBuildDate>Mon, 31 Oct 2022 14:34:52 +0800</lastBuildDate>
   
       <atom:link href="https://hemashushu.github.io/categories/tutorial/index.xml" rel="self" type="application/rss+xml" />
   
   
     <item>
       <title>从零开始一步一步构建现代计算机系统 - 刨根问底的开始</title>
       <link>https://hemashushu.github.io/posts/2022-10-31-building-a-modern-computer-system-from-scratch-step-by-step/</link>
       <pubDate>Mon, 31 Oct 2022 14:34:52 +0800</pubDate>
       
       <guid>https://hemashushu.github.io/posts/2022-10-31-building-a-modern-computer-system-from-scratch-step-by-step/</guid>
       <description>&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&lt;p&gt;RISC-V 是最近几年热门的计算机指令集，相信已经有不少朋友已经尝试过编译 RISC-V 版的 Linux 内核，或者跟着教程编写玩具操作系统、玩具编程语言，甚至还有很冲动地买了一大堆 FPGA 开发板和电子零件，然后跟着教程用 HDL（硬件描述语言）编写自己的玩具 RISC-V CPU。&lt;/p&gt;&lt;p&gt;无论你是哪种，刚开始时肯定既激动又兴奋，就像一个在新的异世界开始冒险的勇者那样。不过估计翻到教程的第二章，大部分朋友就开始眉头紧锁，然后咬着牙又翻了几章，经过一翻挣扎最后还是只能放弃。这时候你可能很疑惑：“明明我已经写了几年的程序，各种算法题早已不放在眼里，怎么就不明白这些教程到底在说什么呢？！&amp;quot;&lt;/p&gt;&lt;p&gt;显然这是因为缺少对系统的 &lt;em&gt;底层技术&lt;/em&gt;（或者说 &lt;em&gt;计算机基础技术&lt;/em&gt;，不过这个名称容易引起专业外的人误解，至于另一个名称 &lt;em&gt;核心技术&lt;/em&gt; 又显得太营销，所以后面还是使用 &lt;em&gt;底层技术&lt;/em&gt; 这个名称）的了解，你可能会反驳：”我在计算机基础课程里早就学过了，考试也通过了！“。是的，在计算机专业的课程里都设置了诸如 &lt;em&gt;组成原理&lt;/em&gt;、&lt;em&gt;编译原理&lt;/em&gt;、&lt;em&gt;操作系统&lt;/em&gt; 等课程，而且还循序渐进地一门一门地学。不过&lt;strong&gt;把这些科目分开学习是错误的&lt;/strong&gt;，计算机的底层技术实际上是相互交叉的。也就是说，这些科目是在系统搭建起来之后，后来的人对各种技术进行分门别类和归纳总结，逐渐形成各个领域，而在系统搭建的起初，它们并没有区分得那么清楚。不妨把每一个领域想象成一根根立起来的柱子，正确的学习路径是围绕着这些柱子&lt;strong&gt;螺旋式地逐渐往上爬&lt;/strong&gt;，而不是一口气爬完一根柱子，然后滑下来再爬另一根柱子。&lt;/p&gt;&lt;p&gt;TODO image&lt;/p&gt;&lt;p&gt;计算机系统包括了 &lt;em&gt;语言&lt;/em&gt;、&lt;em&gt;处理器&lt;/em&gt; 和 &lt;em&gt;操作系统&lt;/em&gt; 三个基本组成部分。如果从远距离来看，处理器和操作系统是同一回事，它们共同构建了一种人类文明当中最复杂的机器 ———— 计算机，处理器负责实现功能不变的部分，操作系统是处理器的自然延伸，负责实现功能需要变化的部分。而语言一方面用于描述这种机器的运作逻辑，另一方面用于表达、封装和抽象机器的功能，使得机器和人类之间能交流。可见计算机系统的基本组成部分是 &lt;strong&gt;同一个目的 ———— 让机器解决问题&lt;/strong&gt; 的不同侧面，分开学习自然无法理解其中的联系和缘由。&lt;/p&gt;&lt;p&gt;其次学习方式也存在问题，计算机系统的底层技术大部分是工程师们在不断地解决问题之后得出的总结和积累，也就是说，这些技术当中理论并不是占主导作用，更多的是通过尝试后得出的 &lt;em&gt;最佳实践&lt;/em&gt;。因此较好的的学习方式应该是先从探索和实践开始入手，然后&lt;strong&gt;边实践边试错、边领会边总结&lt;/strong&gt;，而不是先学一大堆原理，做完一堆习题，再来实践。&lt;/p&gt;&lt;p&gt;总的来说，虽然我们几乎都学过跟计算机底层技术相关的基础科目，但因为跟系统的构建方式和过程都相差甚远，所以实际上并没有真正掌握到这些技术。不妨试试在没有网络搜索引擎的帮助下，能否自己设计一套最简的指令集，然后手画微体系结构的大致的数据通路（data path）；或者给定一个目标架构，编写一个冷启动的引导程序；又或者尝试从零开始手写一个简单的语法解析器。&lt;/p&gt;&lt;p&gt;TODO image&lt;/p&gt;&lt;h2 id=&#34;特点&#34;&gt;特点&lt;/h2&gt;&lt;p&gt;我们在平时的工作和学习当中实际上已经积累了一定的底层技术的知识，只是它们在脑海里可能是松散的游离的状态，我希望能通过一系列文章，把它们有序地连接起来，从而真正掌握底层技术。这系列文章有如下特点：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;不再一味讲原理然后做项目，而是从探索和实践入手，在实践和试错过程中再穿插原理（有时还会穿插一些小典故小故事以加深印象）。&lt;/li&gt;&lt;li&gt;不再根据领域/学科分类，而是根据系统的构建过程以及内容的深浅程度切分为多个小阶段，每个小阶会同时涉及多个领域的技术，每个领域都是够用为止，不会过度深入，完成一个小阶段再进入下一个阶段。&lt;/li&gt;&lt;li&gt;从零开始构建，不需要任何专门的 IDE、SDK 或者库，开始阶段只需几个通用的开源免费的编译器和工具，后面则使用自己的工具，因此可以彻底弄明白每一个技术细节（因为工具都是自己构建的）。&lt;/li&gt;&lt;li&gt;无需昂贵的硬件，只使用几个最广泛使用的（久经考验的）最廉价的硬件模块，即可以完成到最后一章。整个系列只有硬件模块需要开销，不过一共只需一两百来块钱。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;这一系列文章会以 RISC-V 作为学习和实现的架构，之所以选择 RISC-V 原因有：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;它的指令集相对比较简单，这使得我们完全可以自己动手实现 &amp;ldquo;最小的能工作的&amp;rdquo; 汇编器及处理器；&lt;/li&gt;&lt;li&gt;相关工具大部分是开源免费的，基本的生态环境已形成，可以利用现有的工具来检查和验证我们的 &amp;ldquo;作品&amp;rdquo; 是否正确，这对摸索过程非常重要；&lt;/li&gt;&lt;li&gt;最后如果我们做出了产品，也无需顾忌授权问题。&lt;/li&gt;&lt;/ul&gt;&lt;h2 id=&#34;内容简介&#34;&gt;内容简介&lt;/h2&gt;&lt;p&gt;无可否认计算机底层技术的内容非常之多，它是几十年以来成千上万全球最顶尖工程师的总结和积累，无论是知识面广度和复杂程度都几乎逼近人脑的极限。河马蜀黍知道无法简单地通过几篇文章就能讲完，所以准备了四个系列（series），每个系列分为若干部（part），每部含若干篇文章（chapter）。下面简单介绍一下：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;一步一步深入 RISC-V 系统&lt;/em&gt;。这个系列分为五部：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;第一部：了解编译器、链接器、调试器以及一些常用二进制工具的使用方法，了解程序的组成，以及实现最小独立式可执行程序（freestand）的构建等；&lt;/li&gt;&lt;li&gt;第二部：通过微控制器（MCU）来浅度了解软件和硬件之间的交互原理，编写裸机版（即不使用 SDK 或者硬件抽象库，而是直接读写寄存器）的程序（固件）控制电信号的输入输出（GPIO），实现串口通信等；&lt;/li&gt;&lt;li&gt;第三部：了解程序加载、运行、动态链接的原理，了解 RISC-V 的函数调用规程以及基本指令，使用汇编编写简单的程序；&lt;/li&gt;&lt;li&gt;第四部：实现一门目标架构为 RISC-V 的汇编语言及其汇编器，了解最简单的语法解析器的原理；&lt;/li&gt;&lt;li&gt;第五部：实现一门链接脚本及其链接器，了解脚本解析器的原理。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;一步一步实现一门静态类型编译型语言&lt;/em&gt;。这个系列分六部：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;第一部：实现一门中间语言（IR），以及中间语言到汇编语言的代码生成器（code generator）；&lt;/li&gt;&lt;li&gt;第二部：实现一门现代语言，以及高级语言到中间语言的代码生成器，至此完成了一个 &lt;em&gt;完整的编译系统&lt;/em&gt;；&lt;/li&gt;&lt;li&gt;第三部：实现 &lt;a href=&#34;https://webassembly.org/&#34;&gt;WASM&lt;/a&gt; 虚拟机（VM），然后实现中间语言到 WASM 的代码生成器。实现 WASM VM 的同时可以从抽象层面感受一个处理器是如何执行指令的，另一方面有了 WASM 代码生成器，意味着我们的语言能在浏览器中运行；&lt;/li&gt;&lt;li&gt;第四部：实现中间语言到 &lt;a href=&#34;https://llvm.org/docs/LangRef.html&#34;&gt;LLVM IR&lt;/a&gt; 的代码生成器，让我们的语言能生成目标架构为 &lt;code&gt;x86&lt;/code&gt; 和 &lt;code&gt;arm&lt;/code&gt; 的程序。这一部主要是为了解决 “我们精力有限” 和 “语言的实用性” 之间的矛盾。&lt;/li&gt;&lt;li&gt;第五部：实现项目构建器及包管理器，这是任意现代语言都必备的。&lt;/li&gt;&lt;li&gt;第六部：用当前语言重写编译器，实现语言自托管（self-hosting），即编译器可以编译自己的源代码，从此我们可以使用自己的工具来构建系统。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;一步一步实现一个实用型的 RISC-V CPU&lt;/em&gt;。这个系列分五部：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;第一部：设计一个最小的指令集，只实现数字累加功能；然后通过数字电路仿真软件实现一个最简化处理器，该处理器包含了 ROM、RAM、寄存器堆、译码器、控制器及算术逻辑单元等基本处理器要素，能执行我们的指令集。通过这一部来了解处理器的基本运作原理，以及软件如何变成电信号。&lt;/li&gt;&lt;li&gt;第二部：从我们的语言派生出一门 HDL 语言，实现该门语言的数字逻辑电路模拟器以及测试（验证）框架；实现从这门语言到 &lt;a href=&#34;https://en.wikipedia.org/wiki/SystemVerilog&#34;&gt;SystemVerilog&lt;/a&gt; 的代码生成器，然后用这门语言重新实现上一部的基础组件以及处理器，并下载到 FPGA 硬件上通电测试；&lt;/li&gt;&lt;li&gt;第三部：使用自己的 HDL 语言实现一个多时钟周期的 RV64I 处理器，并下载到 FPGA 硬件上通电测试；&lt;/li&gt;&lt;li&gt;第四部：实现常见的通信协议（比如 UART、$I^2C$、SPI），书写常见的外设（比如 GPIO 接口、SPI Flash、SD 卡、SSD 1306 显示屏等）的驱动。整合我们的处理器，实现一个完整的硬件系统；&lt;/li&gt;&lt;li&gt;第五部：将处理器升级为多级流水线设计。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;一步一步实现一个简单的微内核操作系统&lt;/em&gt;。这个系列分六部：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;第一部：为我们的处理器添加内存管理单元（MMU）以及特权相关的模块；&lt;/li&gt;&lt;li&gt;第二部：实现最小的内核，即实现基本的串口输入输出，多级页表内存管理，程序的加载及进程的简单分时切换，以及消息机制等；&lt;/li&gt;&lt;li&gt;第三部：实现简化版的 &lt;code&gt;ext4&lt;/code&gt; 文件系统以及内存管理；&lt;/li&gt;&lt;li&gt;第四部：实现简单的用户交互界面（shell）以及一个包管理器；&lt;/li&gt;&lt;li&gt;第五部：实现一个简单的图形加速协处理器（coprocessor）；&lt;/li&gt;&lt;li&gt;第六部：实现一个简单的图形库，实现一个复古风格的横向卷轴动作游戏。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;由上可见，这一系列的文章最终目的是从零开始实现一个完整的现代计算机系统，其中的内容非常多，不过你不用担心难度过高而无法完成，因为每一个部分虽然名堂很大，但都是仅实现最基本的程度，也就是 &amp;ldquo;刚好能用&amp;rdquo; 即止，所以只需一步步跟着来，就不会发生在中途就被卡住的情况。&lt;/p&gt;&lt;p&gt;不过我也会在 “简陋” 和 “实用” 之间平衡，让每一部的 “作品” 都有相当的特点和优点。实际上现代主流的计算机系统（包括语言、编译器、操作系统）都有沉重的历史包袱，比如 GCC 已有三十多年的历史，导致无论是理解还是实现都非常复杂，而且很多新观念无法整合。而我们的系统因为是从零开始，所以完全没有包袱，实现起来相对会简单轻松，而且有些问题可以 &lt;strong&gt;从根本解决&lt;/strong&gt;（比如内存安全问题）；新理念（严格来说并不是新的，只是因为无法融入现有系统而感到陌生）也能无所顾忌地加入，比如使用同一门语言实现硬件开发、底层开发、前端开发；使用微内核，系统永不需关机和重启，更新升级可回滚；系统基于能力（capability）而不是 &lt;em&gt;用户和组&lt;/em&gt; 的安全模型等等。所以我们这套系统是相当有实用价值的。&lt;/p&gt;&lt;p&gt;最后，因为我们的系统（即编译器、处理器、操作系统）是用自己的语言和工具来实现的，所以即使你能看到类似 “从零开始构建系统” 的书籍或文章，但我这个仍然是最彻底、最有特色的😁。&lt;/p&gt;&lt;h2 id=&#34;点赞转发打赏&#34;&gt;点赞、转发、打赏&lt;/h2&gt;&lt;p&gt;虽然这系列文章的大部分内容我都已经实践过，不过我发现要把它们从头到尾讲解起来是相当有挑战性的：庞大而交叉的内容如何组织才能做到由易到难，如何挑选实践的内容，如何做到篇章之间的内容自然过渡和衔接，如何确保内容的准确，如何保证读者看得明白不卡顿等等，单单第一个系列的前两部共 8 篇文章，前前后后反复琢磨和修改，居然用了四个多月的时间。&lt;/p&gt;&lt;p&gt;而另一方面，虽然从宏观上来说计算机底层技术承载着科学技术的传承和创新等重要意义，但对于个人却很现实地 &amp;ldquo;几乎没有任何用处💰&amp;rdquo;，毕竟几乎所有企业都从事应用层面的开发，底层技术无论是对普通人还是对开发人员都太过遥远了。虽然作者很努力地写好每一篇文章，但阅读的人必然是寥寥可数的。因此，如果你碰巧看到这一系列文章，如果觉得有收获，请毫不犹豫地打赏作者吧😄！&lt;/p&gt;&lt;p&gt;最后，虽然底层技术在现实中用不上，但它可以很好地满足人类原始的 “好奇、探索、创造” 的本能。试想一下，还有什么比 “徒手独自一人征服人类文明史上最复杂的机器” 更酷的事情呢？！相信你完成最后一章时，会看到一个不同的世界。&lt;/p&gt;&lt;div&gt;    &lt;img src=&#34;https://hemashushu.github.io/images/subscribe-and-donate.png&#34; class=&#34;block-image image-480px&#34;/&gt;&lt;/div&gt;</description>
     </item>
   
 </channel>
</rss>
