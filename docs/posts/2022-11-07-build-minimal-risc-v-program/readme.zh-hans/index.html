<!doctype html>

<html lang="en-us">

<head>
  <title>河马蜀黍真是的</title>
  <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="description" content="记录一些计算机基础知识、编程技术、学习心得，发布一些自己制作的小软件" />
<meta name="author" content="hemashushu" /><meta property="og:title" content="" />
<meta property="og:description" content="构建最小的 RISC-V 程序 在上一篇文章我们简单地了解了交叉编译工具 RISC-V GCC 的基本使用方法。这篇文章将会以纯汇编构建两个程序：一个最小的裸机程序和一个最小的 Linux 应用程序。一般情况下我们不需要直接使用汇编写程序，但通过这种方式可以排除不相关的内容，以了解一个 RISC-V 程序的最根本的组成和运行的原理。 最小的裸机程序 源代码 汇编 目标文件 文件类型 符号列表 段 段的大小 反汇编 链接 可执行文件 文件类型 符号列表 段 Program Headers 段大小 第一次运行 链接脚本 第二次运行 给程序减肥 第三次运行 最小的 Linux 程序 系统调用 系统调用的实现 程序的源代码 编译 运行 最小的裸机程序 本章演示的是一个" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://hemashushu.github.io/posts/2022-11-07-build-minimal-risc-v-program/readme.zh-hans/" /><meta property="article:section" content="posts" />




<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content=""/>
<meta name="twitter:description" content="构建最小的 RISC-V 程序 在上一篇文章我们简单地了解了交叉编译工具 RISC-V GCC 的基本使用方法。这篇文章将会以纯汇编构建两个程序：一个最小的裸机程序和一个最小的 Linux 应用程序。一般情况下我们不需要直接使用汇编写程序，但通过这种方式可以排除不相关的内容，以了解一个 RISC-V 程序的最根本的组成和运行的原理。 最小的裸机程序 源代码 汇编 目标文件 文件类型 符号列表 段 段的大小 反汇编 链接 可执行文件 文件类型 符号列表 段 Program Headers 段大小 第一次运行 链接脚本 第二次运行 给程序减肥 第三次运行 最小的 Linux 程序 系统调用 系统调用的实现 程序的源代码 编译 运行 最小的裸机程序 本章演示的是一个"/>

<meta name="generator" content="Hugo 0.102.0-DEV" />
    

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css" integrity="sha256-l85OmPOjvil/SOvVt3HnSSjzF1TUMyT9eV0c2BzEGzU=" crossorigin="anonymous" />
  <link rel="stylesheet" href="https://hemashushu.github.io/fontawesome/css/all.min.css" />
  

  
  
  <link rel="stylesheet" type="text/css" href="/css/styles.css" /><link rel='stylesheet' href='https://hemashushu.github.io/css/custom.css'></head>

<body>
  <div id="container">
    <header>
      
      <h1>
        <a href="/">河马蜀黍真是的</a>
      </h1>

      <ul id="social-media">
             <li>
               <a href="https://github.com/hemashushu" title="GitHub">
               <i class="fab fa-github fa-lg"></i>
               </a>
             </li>
             <li>
               <a href="https://twitter.com/hemashushu" title="Twitter">
               <i class="fab fa-twitter fa-lg"></i>
               </a>
             </li>
      </ul>
      
      <p><em>一起发现那些好玩有趣的计算机知识</em></p>
      
    </header>

    
<nav>
    <ul>
        
        <li>
            <a class="active" href="/posts/">
                <i class="fa-li fa  fa-lg"></i><span>Posts</span>
            </a>
        </li>
        
        <li>
            <a class="" href="/about/">
                <i class="fa-li fa  fa-lg"></i><span>About</span>
            </a>
        </li>
        
    </ul>
</nav>


    <main>




<article>

    <h1></h1>

    
      <aside>
    <ul>
        <li>
            <time class="post-date" datetime="0001-01-01T00:00:00Z">Jan 1, 0001</time>
        </li>
        
        

        

        <li>19 minute read</li>
    </ul>
</aside>

    

    
      

    

    <h1 id="构建最小的-risc-v-程序">构建最小的 RISC-V 程序</h1>
<p>在<a href="../risc-v-gcc-quick-start/README.zh-Hans.md">上一篇文章</a>我们简单地了解了交叉编译工具 RISC-V GCC 的基本使用方法。这篇文章将会以纯汇编构建两个程序：一个最小的裸机程序和一个最小的 Linux 应用程序。一般情况下我们不需要直接使用汇编写程序，但通过这种方式可以排除不相关的内容，以了解一个 RISC-V 程序的最根本的组成和运行的原理。</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<ul>
<li><a href="#%E6%9C%80%E5%B0%8F%E7%9A%84%E8%A3%B8%E6%9C%BA%E7%A8%8B%E5%BA%8F">最小的裸机程序</a>
<ul>
<li><a href="#%E6%BA%90%E4%BB%A3%E7%A0%81">源代码</a></li>
<li><a href="#%E6%B1%87%E7%BC%96">汇编</a></li>
<li><a href="#%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6">目标文件</a>
<ul>
<li><a href="#%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B">文件类型</a></li>
<li><a href="#%E7%AC%A6%E5%8F%B7%E5%88%97%E8%A1%A8">符号列表</a></li>
<li><a href="#%E6%AE%B5">段</a></li>
<li><a href="#%E6%AE%B5%E7%9A%84%E5%A4%A7%E5%B0%8F">段的大小</a></li>
</ul>
</li>
<li><a href="#%E5%8F%8D%E6%B1%87%E7%BC%96">反汇编</a></li>
<li><a href="#%E9%93%BE%E6%8E%A5">链接</a></li>
<li><a href="#%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6">可执行文件</a>
<ul>
<li><a href="#%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B-1">文件类型</a></li>
<li><a href="#%E7%AC%A6%E5%8F%B7%E5%88%97%E8%A1%A8-1">符号列表</a></li>
<li><a href="#%E6%AE%B5-1">段</a></li>
<li><a href="#program-headers">Program Headers</a></li>
<li><a href="#%E6%AE%B5%E5%A4%A7%E5%B0%8F">段大小</a></li>
</ul>
</li>
<li><a href="#%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%BF%90%E8%A1%8C">第一次运行</a></li>
<li><a href="#%E9%93%BE%E6%8E%A5%E8%84%9A%E6%9C%AC">链接脚本</a></li>
<li><a href="#%E7%AC%AC%E4%BA%8C%E6%AC%A1%E8%BF%90%E8%A1%8C">第二次运行</a></li>
<li><a href="#%E7%BB%99%E7%A8%8B%E5%BA%8F%E5%87%8F%E8%82%A5">给程序减肥</a></li>
<li><a href="#%E7%AC%AC%E4%B8%89%E6%AC%A1%E8%BF%90%E8%A1%8C">第三次运行</a></li>
</ul>
</li>
<li><a href="#%E6%9C%80%E5%B0%8F%E7%9A%84-linux-%E7%A8%8B%E5%BA%8F">最小的 Linux 程序</a>
<ul>
<li><a href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8">系统调用</a></li>
<li><a href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E5%AE%9E%E7%8E%B0">系统调用的实现</a></li>
<li><a href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%BA%90%E4%BB%A3%E7%A0%81">程序的源代码</a></li>
<li><a href="#%E7%BC%96%E8%AF%91">编译</a></li>
<li><a href="#%E8%BF%90%E8%A1%8C">运行</a></li>
</ul>
</li>
</ul>
<!-- raw HTML omitted -->
<h2 id="最小的裸机程序">最小的裸机程序</h2>
<p>本章演示的是一个最终只有大约 30 个字节的 RISC-V 裸机程序，该程序用纯汇编写，功能也非常简单，就是向串口打印一个大写的字母 &ldquo;A&rdquo;，然后进入一个无限循环。</p>
<h3 id="源代码">源代码</h3>
<p>源代码位于目录 <a href="./resources/minimal-bare-metal/">resouces/minimal-bare-metal</a> 之下的文件 <code>app.S</code>（注意扩展名为大写的字母 <code>S</code>，跟小写 <code>s</code> 的区别在于大写 <code>S</code> 表示需要预处理，一般我们手写的汇编源代码文件的扩展名建议使用大写字母 <code>S</code>），其内容如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-s" data-lang="s"><span style="display:flex;"><span>.equ VIRT_UART0, <span style="color:#ae81ff">0x10000000</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>.section .text.entry
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>.globl _start
</span></span><span style="display:flex;"><span>.globl _print_a
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>_start<span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    call _print_a
</span></span><span style="display:flex;"><span>_loop<span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    nop
</span></span><span style="display:flex;"><span>    j _loop
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>_print_a<span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    li s1, VIRT_UART0   <span style="color:#75715e"># set s1 = 0x1000_0000</span>
</span></span><span style="display:flex;"><span>    li s2, <span style="color:#ae81ff">0x41</span>         <span style="color:#75715e"># set s2 = 0x41</span>
</span></span><span style="display:flex;"><span>    sb s2, <span style="color:#ae81ff">0</span>(s1)        <span style="color:#75715e"># store s2 (as byte) to memory[s1+0]</span>
</span></span><span style="display:flex;"><span>                        <span style="color:#75715e"># address 0x1000_0000 is mapped to UART0</span>
</span></span><span style="display:flex;"><span>                        <span style="color:#75715e"># checkout QEMU source https://github.com/qemu/qemu/blob/master/hw/riscv/virt.c</span>
</span></span><span style="display:flex;"><span>    ret
</span></span></code></pre></div><ol>
<li>程序的第 1 行用于指定接下来的汇编的结果放在目标文件的哪个段。</li>
</ol>
<p>汇编代码经过汇编之后会生成一系列平铺的、无结构的二进制数据，具体来说就是类似 &ldquo;101000110010&hellip;&rdquo; 这样长长的一串二进制数字，为了便于阅读，有时也会以十六进制表示，比如 &ldquo;A3 20 65 66 &hellip;&quot;，无论哪种表示形式，本质都是一样的。而汇编代码则大约相当于这些二进制数据的文本格式，很多汇编语句跟机器指令是一对一的关系，汇编器的任务大致上是将 &ldquo;文本格式的指令和数据&rdquo; 翻译成 &ldquo;二进制格式的指令和数据&rdquo;。</p>
<p><img src="images/assembler.png" alt="assembler"></p>
<p>这些数据中有些是（二进制形式）机器指令，有些是程序中的诸如整数常量、字符串常量等，汇编器根据数据的性质分段储存在汇编器的输出文件（称为 <em>目标文件</em>）当中。一个典型的目标文件有 <code>.text</code>, <code>.rodata</code>, <code>.data</code>, <code>.bss</code> 等段，它们分别是指令序列、只读数据（比如数字和字符串常量）、数据（全局变量）、未初始化的全局变量（或者初始值为 0 的全局变量）。</p>
<p><img src="images/object-file.png" alt="object file"></p>
<p>为了细化管理，每个段又可以细分为多个子段，子段的名字可以随意命名，不过有些是约定俗称的（以后的文章会讲解）。</p>
<p>上面示例程序中的 <code>.text.entry</code> 表示 <code>.text</code> 段里面的一个叫做 <code>.entry</code> 的子段，该名字是我随意起的。</p>
<ol start="2">
<li>
<p>接下来的两句 <code>.globl</code> 表示导出两个 <em>符号</em>，<code>.globl</code> 关键字后面跟着的是标签的名称，下面会讲解。</p>
</li>
<li>
<p><code>_start</code> 是一个标签，标签实质上是一个地址值。</p>
</li>
</ol>
<p>正如上面的第 1 段所说，目标文件是一连串二进制数据，虽然人类无法直接阅读，但我们知道其实每个数字都有具体含义的，因此我们以 <em>字节</em> 为单位，给段里面的数据加上一连串假想的序号，这个序号就是 <em>地址</em>，这样一来就可以用地址来定位每一个数据了。</p>
<p>但有时直接用数字地址不够直观，所以又有了 <em>标签</em>。我们给某些特殊的地址加上标签，比如在上面的程序当中，给 <code>0x0008</code> 加上名为 <code>_loop</code> 的标签，给 <code>0x0010</code> 加上名为 <code>_print_a</code> 标签，这样每当程序需求跳转到这两个位置时，就不用写 <code>0x0008</code> 和 <code>0x0010</code>，而是写成 <code>_loop</code> 和 <code>_print_a</code>，显然用标签来表示一个地址更直观。</p>
<p>最重要的是，我们在书写汇编文本时，其实还不知道每个指令最后被编译之后的地址，所以需要用标签来代表程序当中的一个位置。</p>
<p>具体来说，有两种情况需要用到标签：</p>
<p>a. 用于构建一个函数，通常一个函数由 &ldquo;一个标签&rdquo; + &ldquo;一系列指令&rdquo; + &ldquo;一个返回指令&rdquo; 组成，此时标签的名称就是函数的名称。
b. 用于构建流程控制结构，比如条件语句、循环语句等，其实都是通过 &ldquo;标签&rdquo; + &ldquo;跳转指令&rdquo; 组成。</p>
<ol start="4">
<li><code>_loop</code> 标签以及它后面的两个指令用于形成了一个无限循环。</li>
</ol>
<p>为什么需要一个无限循环呢？这需要从机器是如何执行指令序列说起。从处理器的角度来看，机器指令序列是没有函数概念，运行程序的本质是将程序的一条长长的二进制指令序列加载进内存，然后从第一个指令开始执行，执行完一个指令就指向下一个指令，假如程序当中没有跳转指令的话，则会一直执行到最后一个指令。假如最后一个指令后面还有内存空间，则会一直执行到内存的尽头（尽管这些空间里不是有效的指令，只要不出错则处理器仍然会执行）。处理器就像一个蒙着眼睛捂着耳朵的固执司机，只要路和汽油还有，只要没撞上障碍物，他就一直驱使着车前进。</p>
<p>显然从处理器或者指令序列的角度来看，结构之间、函数之间根本没有边界。所以我们需要约定：一个函数以某个地址开始，这个地址需要加上标签（一般标签名就是函数名），然后以一个返回指令（<code>ret</code> 指令）以此表示函数结束。</p>
<p>然后回过头来看函数 <code>_start</code>，它的工作是调用另一个函数 <code>_print_a</code>，调用完毕之后，程序的所有任务就全部完成了。不过 <code>_start</code> 函数是程序的入口，是一切的开端，显然它没有调用者，所以我们没法在该函数的工作完成之后使用 <code>ret</code> 指令返回。为了防止处理器在执行完 <code>_start</code> 函数之后继续往下执行，只好在函数的末尾处设了一个无限循环，让处理器在这里原地打转（虽然这个方法似乎不怎么优雅）。</p>
<ol start="5">
<li><code>_print_a</code> 是一个标签，同时也是一个完整的函数的名称，该函数的作用是把 byte 类型的整数 <code>0x41</code>（即大写字母 <code>A</code> 对应的 ASCII 号码）写入内存地址 <code>0x1000_0000</code>，这个内存地址被映射到 UART 端口（类似串口控制台，即 Serial Console），QEMU 的 UART 被重定向到虚拟终端，所以实际上就是向虚拟终端输出了一个大写字母 <code>A</code>，<code>_print_a</code> 函数的最后一句是 <code>ret</code> 指令，也就是返回到调用函数指令的下一条指令。</li>
</ol>
<blockquote>
<p>汇编源代码当中 <code>#</code> 符号以及它后面的文本表示注释。</p>
</blockquote>
<h3 id="汇编">汇编</h3>
<p>下面使用 RISC-V GCC 汇编器 <code>riscv64-elf-as</code> 生成目标文件：</p>
<p><code>$ riscv64-elf-as -g -o app.o app.S</code></p>
<ul>
<li>参数 <code>-g</code> 表示同时生成供 GDB 使用的额外调试信息调试信息。</li>
<li>参数 <code>-o app.o</code> 用于指定输出文件的名称（注意，在阅读和理解这条命令时，需要把这个参数和值的组合视为一个整体，后面的 <code>a.S</code> 不属于这个参数的一部分）。</li>
<li>参数 <code>a.S</code> 表示源文件的名称路径。</li>
</ul>
<blockquote>
<p>因 Linux 发行版的不同，RISC-V GCC 工具链当中的各个工具的名称前缀可能会有所不同，比如 <code>riscv64-elf-*</code> 会被命名为 <code>riscv64-unknown-elf-*</code>。另外注意区分 <code>riscv64-elf-*</code> 和 <code>riscv64-linux-gnu-*</code>，前者用于编译 &ldquo;裸机&rdquo; 程序，后者用于编译在 Linux 环境中运行的程序。</p>
</blockquote>
<p>然后将会得到文件 <code>app.o</code>。</p>
<h3 id="目标文件">目标文件</h3>
<p>下面检查目标文件的一些基本信息。</p>
<h4 id="文件类型">文件类型</h4>
<p>先检查文件类型：</p>
<p><code>$ file app.o</code></p>
<p>输出内容如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>app.o: ELF 64-bit LSB relocatable, UCB RISC-V, double-float ABI, version 1 (SYSV), with debug_info, not stripped
</span></span></code></pre></div><p>可见汇编器输出的是一个 ELF 格式的 <em>可重定位文件</em>，也就是平常说的 <em>目标文件</em>，它还不是可执行文件。有关 ELF 格式的 3 中类型，可以参阅上一篇文章 <a href="../risc-v-gcc-base/README.zh-Hans.md">RISC-V GCC 基础</a>。</p>
<h4 id="符号列表">符号列表</h4>
<p>正如前面章节所述，汇编代码里会有表示地址的标签，这些标签经过 <code>.globl</code> 导出，就形成可以供外部查看的 <code>符号</code>（不过并非所有符号都是标签），可以粗略地把符号理解为函数名称或者全局变量名称。</p>
<p>使用工具 <code>riscv64-elf-nm</code> 可以查看目标文件的导出符号列表：</p>
<p><code>$ riscv64-elf-nm app.o</code></p>
<p>输出的内容如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>0000000000000008 t _loop
</span></span><span style="display:flex;"><span>0000000000000010 T _print_a
</span></span><span style="display:flex;"><span>0000000000000000 T _start
</span></span></code></pre></div><p>左边一列是各个符号的虚拟地址，右边一列是符号的名称，中间一列是符号类型的代号，部分代号的含义如下：</p>
<ul>
<li>A: Global absolute symbol.</li>
<li>a: Local absolute symbol.</li>
<li>B: Global bss symbol.</li>
<li>b: Local bss symbol.</li>
<li>D: Global data symbol.</li>
<li>d: Local data symbol.</li>
<li>T: Global text symbol.</li>
<li>t: Local text symbol.</li>
<li>U: Undefined symbol.</li>
</ul>
<p>符号类型代号当中，大写的表示是导出的（供外部使用的），小写的表示局部的（供内部使用的）。详细的列表可参阅 <a href="https://sourceware.org/binutils/docs/binutils/index.html">GNU Binary Utilities Document</a> 当中的 <a href="https://sourceware.org/binutils/docs/binutils/nm.html">nm</a> 一章。</p>
<p>类型 <code>U</code> 比较特殊，表示未定义的符号。比如在一个源代码文件里，调用了一个外部函数，那么这个外部函数的名称就是一个未定义的符号。可见这里的 &ldquo;未定义&rdquo; 是相对当前源代码文件而言的。</p>
<blockquote>
<p>GCC 工具链里很多程序会提供相似的功能，比如列符号表的程序 <code>nm app.o</code>，其实也可以使用 <code>objdump -t app.o</code> 列出，还可以使用 <code>readelf --syms app.o</code> 列出。后面还会看到更多这样的情况，我们根据自己的喜好和习惯选择即可。</p>
</blockquote>
<h4 id="段">段</h4>
<p>使用 <code>riscv64-elf-objdump -h</code> 可以查看目标文件的段信息：</p>
<p><code>$ riscv64-elf-objdump -h app.o</code></p>
<p>输出的（部分）内容如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>Idx Name          Size      VMA               LMA               File off  Algn
</span></span><span style="display:flex;"><span>  0 .text         00000020  0000000000000000  0000000000000000  00000040  2**2
</span></span><span style="display:flex;"><span>                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
</span></span><span style="display:flex;"><span>  1 .data         00000000  0000000000000000  0000000000000000  00000060  2**0
</span></span><span style="display:flex;"><span>                  CONTENTS, ALLOC, LOAD, DATA
</span></span><span style="display:flex;"><span>  2 .bss          00000000  0000000000000000  0000000000000000  00000060  2**0
</span></span><span style="display:flex;"><span>                  ALLOC
</span></span></code></pre></div><blockquote>
<p>如果使用 <code>-x</code> 参数，将会看到所有的段，包括调试信息的段，不过一般不需要关心这些段的内容。</p>
</blockquote>
<p><code>.text</code>, <code>.data</code> 和 <code>.bss</code> 是段的名称，<code>VMA</code> 和 <code>LMA</code> 分别表示虚拟内存地址和加载地址，<code>ALLOC, LOAD, READONLY, CODE</code> 等是段的标记，程序加载器会根据该标记来决定处理该段的方式。</p>
<p>比如 <code>ALLOC</code> 表示程序加载器需要分配空间给该段，<code>LOAD</code> 表示该段需要从文件加载进内存，<code>READONLY</code> 表示该段的内容不能被子进程修改，<code>CODE</code> 表示该段是可执行代码，<code>DATA</code> 表示该段是数据段。完整的标记列表可以参阅 <a href="https://sourceware.org/gdb/onlinedocs/gdb/Files.html">GDB - section-flag</a>。</p>
<blockquote>
<p>除了 <code>riscv64-elf-objdump -h</code>，也可以使用 <code>riscv64-elf-readelf -S app.o</code> 列出目标文件的段信息。</p>
</blockquote>
<p>ELF 的段（section）有两个视图：一个是从汇编器和链接器等工具看到的 section 视图（上面看到的都是这种视图），另一个是从程序加载器看到的 segment 视图（也称为 program 视图）。</p>
<p>section 视图在 &ldquo;section headers&rdquo; 里列出，segment 视图在 &ldquo;program headers&rdquo; 里列出；section 视图跟 section 基本上是一一对应，而 segment 视图则跟 section 存在一对多的映射关系，比如 <code>.text</code> 和 <code>.data</code> 段常常对被映射到同一个 segment。</p>
<p>使用命令 <code>riscv64-elf-readelf -l app.o</code> 即可列出 &ldquo;program headers&rdquo;，不过由于目前的 <code>app.o</code> 还不是可执行文件，所以它的 &ldquo;program headers&rdquo; 是空的。完整的 ELF 文件的结构信息可以参阅 <a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format">ELF Format wiki</a>。</p>
<h4 id="段的大小">段的大小</h4>
<p>使用 <code>riscv64-elf-size</code> 可以查看各个段的大小：</p>
<p><code>$ riscv64-elf-size app.o</code></p>
<p>输出的结果如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>   text    data     bss     dec     hex filename
</span></span><span style="display:flex;"><span>     32       0       0      32      20 app.o
</span></span></code></pre></div><h3 id="反汇编">反汇编</h3>
<p>你可能会疑问，我们刚刚进行了汇编，为什么还要反汇编？反汇编的结果不就是我们手写的汇编代码吗？</p>
<p>是的，对目标文件进行 <em>反汇编</em> 将会得到汇编代码，不过经过反汇编得出的汇编代码跟我们手写的不完全一样，那是因为手写的汇编代码有一部分是 <code>伪指令</code>（即由多个真实指令组成的虚拟指令），通过反汇编能得到真实的指令；另外还有一部分是汇编指令，也就是针对汇编器的指令，这部分指令可能会改变汇编的行为，也可能会产生相当多的数据。</p>
<p>再者反汇编工具一般还会显示各个指令的地址，这有帮助我们分析和调试程序。</p>
<p><code>$ riscv64-elf-objdump -d app.o</code></p>
<p>输出的结果如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>Disassembly of section .text:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>0000000000000000 &lt;_start&gt;:
</span></span><span style="display:flex;"><span>   0:   00000097                auipc   ra,0x0
</span></span><span style="display:flex;"><span>   4:   000080e7                jalr    ra # 0 &lt;_start&gt;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>0000000000000008 &lt;_loop&gt;:
</span></span><span style="display:flex;"><span>   8:   00000013                nop
</span></span><span style="display:flex;"><span>   c:   ffdff06f                j       8 &lt;_loop&gt;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>0000000000000010 &lt;_print_a&gt;:
</span></span><span style="display:flex;"><span>  10:   100004b7                lui     s1,0x10000
</span></span><span style="display:flex;"><span>  14:   04100913                li      s2,65
</span></span><span style="display:flex;"><span>  18:   01248023                sb      s2,0(s1) # 10000000 &lt;_print_a+0xffffff0&gt;
</span></span><span style="display:flex;"><span>  1c:   00008067                ret
</span></span></code></pre></div><p>注意参数 <code>-d</code> 仅反汇编 <code>.text</code> 段，如果你想查看所有段的内容，可以使用 <code>-D</code> 参数代替 <code>-d</code>，不过一般不用关心其它段的内容。</p>
<p>下面分析其中的第 2 个指令 <code>0000_80e7</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>000000000000  00001 000 00001 1100111
</span></span><span style="display:flex;"><span>____________  _____     _____ _______
</span></span><span style="display:flex;"><span>|offset[11:0] rs=1      rd=1  jalr
</span></span></code></pre></div><p>解码得出：<code>jalr ra, 0(ra)</code>，结合上一条指令 <code>auipc ra,0x0</code> 来看，这两条指令并不能实现跳转到 <code>_print_a</code> 函数，所以这里的 <code>0</code> 是一个占位符。这时 GCC 编译器，也是目前大部分编译器的原理，即在编译阶段，所有涉及函数地址、全局变量地址的地方，都用 <code>0</code> 代替，同时会做一张需要重定位的符号列表。仅在链接阶段，才会把真实的地址填上。（具体步骤和原理在后续的文章里会讲解）</p>
<h3 id="链接">链接</h3>
<p>由上一节可知，因为目标文件当中的所有符号的地址都是用 <code>0</code> 顶替的，所以 <em>目标文件</em> 是没法运行的，还需要把符号的真实地址填上，应用程序才能运行，而这这正是链接器的工作。</p>
<p>链接器还有另外一项工作，就是如果存在多个 <em>目标文件</em>，那么它还需要把这些文件合并在一起。那么它是怎样合并的呢？</p>
<p>我们知道目标文件里存在多个 “段”，在合并时默认会将相同名称的段合并成一个段。比如假设现有两个目标文件 <code>a.o</code> 和 <code>b.o</code>。在链接时，<code>a.o</code> 的 <code>.text</code> 段将会和 <code>b.o</code> 的 <code>.text</code> 段合并，<code>a.o</code> 的 <code>.data</code> 段和 <code>b.o</code> 的 <code>.data</code> 段合并，最后再将合并后的各个段连接起来。</p>
<p>具体的合并方案是由一个链接器的脚本控制的，这个默认脚本可以通过命令 <code>$ riscv64-elf-ld --verbose</code> 查看，脚本的具体含义可以参考 <a href="https://sourceware.org/binutils/docs/ld/index.html">LD 的文档</a> 当中的 <a href="https://sourceware.org/binutils/docs/ld/Scripts.html">3 Linker Scripts</a> 一章，这里有一个 <a href="https://blog.csdn.net/m0_47799526/article/details/108765403">中文翻译版</a> 也可以参考一下。</p>
<p>有时目标文件可能是第三方提供的库，比如 C 的数学库 <code>/usr/lib/libm.so</code>，所以链接时又有静态链接和动态链接之分，后续的文章会详细讲解。</p>
<p>下面是链接命令：</p>
<p><code>$ riscv64-elf-ld -o app.out app.o</code></p>
<p>上面程序运行之后得到文件 <code>app.out</code>。</p>
<h3 id="可执行文件">可执行文件</h3>
<p>链接器的输出结果是一个可执行文件，下面查看可执行文件的信息。</p>
<h4 id="文件类型-1">文件类型</h4>
<p>使用 <code>file</code> 工具查看文件的类型：</p>
<p><code>$ file app.out</code></p>
<p>输出如下信息：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>app.out: ELF 64-bit LSB executable, UCB RISC-V, double-float ABI, version 1 (SYSV), statically linked, with debug_info, not stripped
</span></span></code></pre></div><p>对比之前的 <code>app.o</code> 的会发现文件类型已经由 <code>ELF relocatable</code> 变成 <code>ELF executable</code>。使用 <code>riscv64-elf-readelf -h</code> 同样可以查看 ELF 格式的头信息：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ riscv64-elf-readelf -h app.o
</span></span><span style="display:flex;"><span>$ riscv64-elf-readelf -h app.out
</span></span></code></pre></div><p>输出的结果如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>&lt; Type:                              REL (Relocatable file)
</span></span><span style="display:flex;"><span>&lt; Entry point address:               0x0
</span></span><span style="display:flex;"><span>&lt; Start of program headers:          0 (bytes into file)
</span></span><span style="display:flex;"><span>&lt; Number of program headers:         0
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>&gt; Type:                              EXEC (Executable file)
</span></span><span style="display:flex;"><span>&gt; Entry point address:               0x100b0
</span></span><span style="display:flex;"><span>&gt; Start of program headers:          64 (bytes into file)
</span></span><span style="display:flex;"><span>&gt; Number of program headers:         2
</span></span></code></pre></div><h4 id="符号列表-1">符号列表</h4>
<p>然后再看看导出符号表：</p>
<p><code>$ riscv64-elf-nm app.out</code></p>
<p>输出的内容如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>00000000000110d0 T __BSS_END__
</span></span><span style="display:flex;"><span>00000000000110cc T __bss_start
</span></span><span style="display:flex;"><span>00000000000110cc T __DATA_BEGIN__
</span></span><span style="display:flex;"><span>00000000000110cc T _edata
</span></span><span style="display:flex;"><span>00000000000110d0 T _end
</span></span><span style="display:flex;"><span>00000000000118cc A __global_pointer$
</span></span><span style="display:flex;"><span>00000000000100b4 t _loop
</span></span><span style="display:flex;"><span>00000000000100bc T _print_a
</span></span><span style="display:flex;"><span>00000000000110cc T __SDATA_BEGIN__
</span></span><span style="display:flex;"><span>00000000000100b0 T _start
</span></span></code></pre></div><p>发现多出了几个符号，比如 <code>__DATA_BEGIN</code>，<code>__bss_start</code> 等，这些符号来自链接脚本。</p>
<h4 id="段-1">段</h4>
<p>然后再看段信息：</p>
<p><code>$ riscv64-elf-objdump -h app.out</code></p>
<p>输出的内容如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>Idx Name          Size      VMA               LMA               File off  Algn
</span></span><span style="display:flex;"><span>  0 .text         0000001c  00000000000100b0  00000000000100b0  000000b0  2**2
</span></span><span style="display:flex;"><span>                  CONTENTS, ALLOC, LOAD, READONLY, CODE
</span></span></code></pre></div><p>发现 <code>.data</code> 和 <code>.bss</code> 段不见了，那是因为它们原本就是无内容的，长度为 0，所以在最后输出文件里被 &ldquo;优化&rdquo;（即被移除）了。</p>
<p><code>.text</code> 的长度不变，而 <code>VMA</code> （虚拟内存地址）和 <code>LMA</code> （加载内存地址）的值都变为 <code>0x1_00b0</code>。</p>
<h4 id="program-headers">Program Headers</h4>
<p>因为 <code>app.out</code> 已经是可执行文件，所以现在可以查看 &ldquo;program headers&rdquo; 了：</p>
<p><code>$ riscv64-elf-readelf -l app.out</code></p>
<p>输出的结果如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>Elf file type is EXEC (Executable file)
</span></span><span style="display:flex;"><span>Entry point 0x100b0
</span></span><span style="display:flex;"><span>There are 2 program headers, starting at offset 64
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Program Headers:
</span></span><span style="display:flex;"><span>  Type           Offset             VirtAddr           PhysAddr
</span></span><span style="display:flex;"><span>                 FileSiz            MemSiz              Flags  Align
</span></span><span style="display:flex;"><span>  RISCV_ATTRIBUT 0x00000000000000cc 0x0000000000000000 0x0000000000000000
</span></span><span style="display:flex;"><span>                 0x0000000000000043 0x0000000000000000  R      0x1
</span></span><span style="display:flex;"><span>  LOAD           0x0000000000000000 0x0000000000010000 0x0000000000010000
</span></span><span style="display:flex;"><span>                 0x00000000000000cc 0x00000000000000cc  R E    0x1000
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> Section to Segment mapping:
</span></span><span style="display:flex;"><span>  Segment Sections...
</span></span><span style="display:flex;"><span>   00     .riscv.attributes
</span></span><span style="display:flex;"><span>   01     .text
</span></span></code></pre></div><p>&ldquo;program headers&rdquo; 主要用于指示程序加载器如何加载程序（到内存），由上面的结果可见程序会被加载到 <code>0x1_0000</code>，总共加载 <code>0xcc</code> 个字节。又因为程序的入口位于地址 <code>0x1_00b0</code>，所以实际指令的大小为 <code>0xcc - 0xb0 = 0x1c</code>，这个大小跟 &ldquo;section headers&rdquo; 列出的 <code>.text</code> 段的大小是一致的。</p>
<h4 id="段大小">段大小</h4>
<p>然后再次查看各个段的大小：</p>
<p><code>$ riscv64-elf-size app.out</code></p>
<p>输出的内容如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>   text    data     bss     dec     hex filename
</span></span><span style="display:flex;"><span>     28       0       0      28      1c app.out
</span></span></code></pre></div><p>对比链接之前的 <code>app.o</code>，发现代码段（即 <code>.text</code>）居然减少了 4 个字节，下面通过反汇编便知道其中的原因：</p>
<p><code>$ riscv64-elf-objdump -d app.out</code></p>
<p>输出的结果如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>Disassembly of section .text:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>00000000000100b0 &lt;_start&gt;:
</span></span><span style="display:flex;"><span>   100b0:       00c000ef                jal     ra,100bc &lt;_print_a&gt;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>00000000000100b4 &lt;_loop&gt;:
</span></span><span style="display:flex;"><span>   100b4:       00000013                nop
</span></span><span style="display:flex;"><span>   100b8:       ffdff06f                j       100b4 &lt;_loop&gt;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>00000000000100bc &lt;_print_a&gt;:
</span></span><span style="display:flex;"><span>   100bc:       100004b7                lui     s1,0x10000
</span></span><span style="display:flex;"><span>   100c0:       04100913                li      s2,65
</span></span><span style="display:flex;"><span>   100c4:       01248023                sb      s2,0(s1) # 10000000 &lt;__global_pointer$+0xffee734&gt;
</span></span><span style="display:flex;"><span>   100c8:       00008067                ret
</span></span></code></pre></div><p>从反汇编的结果发现两处不同：</p>
<ol>
<li>指令的地址从 0x1_00b0 开始（原先从 0 开始）；</li>
<li><code>call _print_a</code> 语句由 2 个指令 <code>auipc</code> 和 <code>jalr</code> 转换为 1 个指令 <code>jal</code>，且目标地址被填上真实的地址，RISC-V 一条指令（不管是 32 位还是 64 位）的长度为 4 个字节，所以少了一条指令刚好就少了 4 个字节。</li>
</ol>
<p>现在分析指令 <code>00c000ef</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>0    0000000110 0    00000000 00001 1101111
</span></span><span style="display:flex;"><span>---- ---------- ---- -------- ----- -------
</span></span><span style="display:flex;"><span>[20] [10:1]     [11] [19:12]  rd=1  jal
</span></span></code></pre></div><p>解码得出：<code>jal ra, 0b1100</code>，其中 <code>0b1100</code> 是地址偏移值，下面来算算它表示的绝对地址：当前指令地址为 <code>0x1_00b0</code>，即在运行的时候，<code>PC</code> 寄存器的值为 <code>0x1_00b0</code>，加上偏移值 <code>0b1100</code> 得出 <code>0x100bc</code>，这正好是函数 <code>_print_a</code> 的地址。</p>
<blockquote>
<p>在数字电路里寄存器 <code>PC</code> 的值主要有 3 个来源：一个是指令被获取（即 fetch）之后，PC 的当前值加上了数值 <code>4</code> 之后的数值；另一个是当前的 PC 值加上跳转指令当中的立即数；最后一个是（jalr 指令）当前 PC 值加上跳转指令的立即数，再加上目标寄存器的值。PC 的下一个值会根据指令的不同而由 <em>复用器</em> 采用这 3 个来源当中的一个。对于上面的 <code>jal</code> 指令，采用的是第 2 种来源。</p>
</blockquote>
<h3 id="第一次运行">第一次运行</h3>
<p>上一步得到 <code>app.out</code> 是一个 ELF 格式的可执行文件，不过如果你当前操作的计算机是 x86（现在一般指 AMD64 或者 x86-64）或者 ARM 架构的，是无法直接执行这个文件的，因为这个可执行文件的目标平台是 RISC-V 架构。河马蜀黍当前的计算机是 x86 架构，直接执行之后出现了如下提示信息：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>$ ./app.out
</span></span><span style="display:flex;"><span>Segmentation fault (core dumped)
</span></span></code></pre></div><p>我不知道在你的计算机上运行之后会出现什么信息，不过很明显 x86 CPU 无法正确理解 RISC-V 的指令，经过一番挣扎之后估计都会以失败告终（比如上面显示的是 <em>段失败</em> 错误）。</p>
<p>下面使用模拟器 QEMU RISC-V 来运行可执行文件 <code>app.out</code>，</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ qemu-system-riscv64 <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    -machine virt <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    -nographic <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    -bios none <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    -kernel app.out
</span></span></code></pre></div><p>这次不会显示 <em>段失败</em> 错误了，但是等了半天都没等到程序结束，也没看到大写字母 “A”，显然应用程序仍然没有被正确执行。</p>
<blockquote>
<p>按 <code>Ctrl+a, x</code>（即先按下 <code>Ctrl+a</code>，然后再单独按下 <code>x</code> 键）可结束 QEMU，这个组合键我会反复提示，免得你跟第一次退出 VIM 一样手忙脚乱。</p>
</blockquote>
<p>通过后续的文章的 GDB 调试可知，QEMU RISC-V virt 会假设内核程序的开始位置在内存的 <code>0x8000_0000</code>，而我们的程序被加载到 <code>0x0001_00b0</code>，因此程序根本没有被执行。</p>
<p>这里的 <code>0x8000_0000</code> 是一个映射地址，并不是说虚拟机真的有这么大的内存（实际上默认 QEMU RISC-V 虚拟机只有 128MB 内存），这个地址被映射到内存 RAM 的开始位置，可以从 <a href="https://github.com/qemu/qemu/blob/master/hw/riscv/virt.c">QEMU RISC-V virt 的源代码</a> 找到映射关系：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">const</span> MemMapEntry virt_memmap[] <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    [VIRT_MROM] <span style="color:#f92672">=</span>         {     <span style="color:#ae81ff">0x1000</span>,        <span style="color:#ae81ff">0xf000</span> },
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    [VIRT_UART0] <span style="color:#f92672">=</span>        { <span style="color:#ae81ff">0x10000000</span>,         <span style="color:#ae81ff">0x100</span> },
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    [VIRT_FLASH] <span style="color:#f92672">=</span>        { <span style="color:#ae81ff">0x20000000</span>,     <span style="color:#ae81ff">0x4000000</span> },
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    [VIRT_DRAM] <span style="color:#f92672">=</span>         { <span style="color:#ae81ff">0x80000000</span>,           <span style="color:#ae81ff">0x0</span> },
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><blockquote>
<p>有关 QEMU RISC-V 的使用及程序调试方法，会在后续的文章中讲解。</p>
</blockquote>
<h3 id="链接脚本">链接脚本</h3>
<p>那么怎样才能把程序加载到指定的位置呢？这时候就需要定制的 <em>链接脚本</em> 了。链接脚本可以让链接器按照我们的需求产生输出文件，当然也就可以指定程序的加载到内存后的位置。</p>
<p>目录 <a href="./resources/">resources</a> 里有一个链接器脚本文件 <code>app.lds</code>，其内容如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>OUTPUT_ARCH(riscv)
</span></span><span style="display:flex;"><span>ENTRY(_start)
</span></span><span style="display:flex;"><span>BASE_ADDRESS = 0x80000000;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>SECTIONS
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  . = BASE_ADDRESS;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  .text : {
</span></span><span style="display:flex;"><span>    *(.text.entry)
</span></span><span style="display:flex;"><span>    *(.text .text.*)
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  .rodata : {
</span></span><span style="display:flex;"><span>    *(.rodata .rodata.*)
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  .data : {
</span></span><span style="display:flex;"><span>    *(.sdata .sdata.*)
</span></span><span style="display:flex;"><span>    *(.data .data.*)
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  .bss :{
</span></span><span style="display:flex;"><span>    *(.sbss .sbss.*)
</span></span><span style="display:flex;"><span>    *(.bss .bss.*)
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>然后在链接时指定链接脚本：</p>
<p><code>$ riscv64-elf-ld -T app.lds -o app.out app.o</code></p>
<p>其中参数 <code>-T app.lds</code> 用于指定链接脚本。</p>
<p>现在得到了新的文件 <code>app.out</code>，使用命令 <code>$ riscv64-elf-objdump -h app.out</code> 查看段信息，输出内容如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>Idx Name          Size      VMA               LMA               File off  Algn
</span></span><span style="display:flex;"><span>  0 .text         0000001c  0000000080000000  0000000080000000  00001000  2**2
</span></span><span style="display:flex;"><span>                  CONTENTS, ALLOC, LOAD, READONLY, CODE
</span></span></code></pre></div><p>可见代码段 <code>.text</code> 的加载地址已经变为 <code>0x8000_0000</code>。</p>
<p>再看看 &ldquo;program headers&rdquo;：</p>
<p><code>$ riscv64-elf-readelf -l app.out</code></p>
<p>输出的结果如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>Elf file type is EXEC (Executable file)
</span></span><span style="display:flex;"><span>Entry point 0x80000000
</span></span><span style="display:flex;"><span>There are 2 program headers, starting at offset 64
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Program Headers:
</span></span><span style="display:flex;"><span>  Type           Offset             VirtAddr           PhysAddr
</span></span><span style="display:flex;"><span>                 FileSiz            MemSiz              Flags  Align
</span></span><span style="display:flex;"><span>  RISCV_ATTRIBUT 0x000000000000101c 0x0000000000000000 0x0000000000000000
</span></span><span style="display:flex;"><span>                 0x0000000000000043 0x0000000000000000  R      0x1
</span></span><span style="display:flex;"><span>  LOAD           0x0000000000001000 0x0000000080000000 0x0000000080000000
</span></span><span style="display:flex;"><span>                 0x000000000000001c 0x000000000000001c  R E    0x1000
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> Section to Segment mapping:
</span></span><span style="display:flex;"><span>  Segment Sections...
</span></span><span style="display:flex;"><span>   00     .riscv.attributes
</span></span><span style="display:flex;"><span>   01     .text
</span></span></code></pre></div><p>从上面的信息可见程序的入口以及虚拟内存地址均为 <code>0x80000000</code>，加载的大小为 <code>0x1c</code> 字节，刚好就是代码段的大小。</p>
<h3 id="第二次运行">第二次运行</h3>
<p>下面执行新生成的可执行文件 <code>app.out</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ qemu-system-riscv64 <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    -machine virt <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    -nographic <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    -bios none <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    -kernel app.out
</span></span></code></pre></div><p>如无意外，应该可以看到在终端输出大写字母 “A”。再友情提示一下，按 <code>Ctrl+x, a</code> 终止 QEMU。</p>
<h3 id="给程序减肥">给程序减肥</h3>
<p>现在纯汇编写的 RISC-V 程序就已经完成了，先看看程序的大小：</p>
<p><code>$ ls -lh</code></p>
<p>输出的结果如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>-rw-r--r-- 1 yang yang  311 Oct 21 15:27 app.lds
</span></span><span style="display:flex;"><span>-rw-r--r-- 1 yang yang 3.2K Oct 21 11:05 app.o
</span></span><span style="display:flex;"><span>-rwxr-xr-x 1 yang yang 5.6K Oct 21 15:27 app.out
</span></span><span style="display:flex;"><span>-rw-r--r-- 1 yang yang  442 Oct 21 06:57 app.S
</span></span></code></pre></div><p>发现了吗？可执行文件 <code>app.out</code> 居然有 <code>5.6KB</code>，它是如此巨大！不是说只有 30 左右字节的吗？下面我们来给程序减减肥吧。</p>
<p>首先需要知道为什么 <code>app.out</code> 文件会那么大，明明当前的应用程序非常简单，编译之后的指令序列只有 <code>0x1c</code>（即十进制的 <code>28</code>） 个字节。那是因为 ELF 文件格式有固定的结构，这些结构会占用一定的空间，另外 ELF 文件里还包含用于程序调试的信息。使用工具 <code>riscv64-elf-objcopy</code> 可以把这些信息通通去掉，只剩下跟链接脚本描述一致的二进制数据（也就是说 <code>.text</code>，<code>.rodata</code> 和 <code>.data</code> 等段的信息会被保留）：</p>
<p><code>$ riscv64-elf-objcopy -S -O binary app.out app.bin</code></p>
<p>参数 <code>-S</code> 表示移除所有多余的信息（包括调试信息），<code>-O binary</code> 表示输出文件的格式， <code>app.out</code> 和 <code>app.bin</code> 分别表示输入和输出的文件名。</p>
<p>指令执行完毕之后会产生一个名为 <code>app.bin</code> 的文件，下面检查它的大小：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>$ ls -l app.bin
</span></span><span style="display:flex;"><span>-rwxr-xr-x 1 yang yang 28 Oct 21 15:34 app.bin
</span></span></code></pre></div><p>果然只剩下 <code>28</code> 个字节，使用 <code>xxd</code> 工具可以肉眼查看它的内容：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>$ xxd app.bin
</span></span><span style="display:flex;"><span>00000000: ef00 c000 1300 0000 6ff0 dfff b704 0010  ........o.......
</span></span><span style="display:flex;"><span>00000010: 1309 1004 2380 2401 6780 0000            ....#.$.g...
</span></span></code></pre></div><p>如果你的记忆好的话，可能会对上面一段数字有一种似曾相识的感觉，它正是上面章节反汇编可执行文件 <code>app.out</code> 代码段时的内容，比如开头的 4 个字节 <code>ef 00 c0 00</code>，因为磁盘储存采用 <em>小端序</em> 的缘故，我们需要将字节的顺序反转，得到 <code>00 c0 00 ef</code>，这正是第一条指令 <code>jal ra,100bc</code> 的机器码 <code>0x00c000ef</code>。</p>
<h3 id="第三次运行">第三次运行</h3>
<p>下面尝试用 QEMU 运行它，不过因为 <code>app.bin</code> 除了机器指令，其余的所有信息都被移除了，所以需要手动指定程序加载到内存的位置，也就是说再也不能直接把 <code>app.bin</code> 作为 <code>-kernel</code> 参数传给 QEMU，转而需要使用参数 <code>-device loader,file=FILENAME,addr=ADDRESS</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ qemu-system-riscv64 <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    -machine virt <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    -nographic <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    -bios none <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    -device loader,file<span style="color:#f92672">=</span>app.bin,addr<span style="color:#f92672">=</span>0x80000000
</span></span></code></pre></div><p>如无意外，上面的命令也能输出正确的结果，同样按 <code>Ctrl+a, x</code> 退出 QEMU。</p>
<h2 id="最小的-linux-程序">最小的 Linux 程序</h2>
<p>本章要实现一个最小的 Linux 程序，它的功能是向控制台打印一行 &ldquo;Hello world!\n&rdquo; 文本。跟之前的 &ldquo;Hello world&rdquo; 程序不同的是，它不需要标准库的支持，而是直接进行系统调用，其次它用汇编书写</p>
<h3 id="系统调用">系统调用</h3>
<p>Linux 程序也就是平常我们所接触到的普通程序，跟上面的裸机程序不同的是，普通程序运行于计算机的 <code>用户模式</code>，在这种模式下应用程序是无法直接跟硬件打交道的，包括无法访问任意位置的内存，无法访问 CPU 当中部分需要特权的寄存器，也无法执行需要特权的指令（裸机程序通常运行于 <code>机器模式</code> 或者 <code>监管模式</code>，它可以直接访问计算机的所有资源）。所以即使是向串口控制台打印一行 &ldquo;Hello World!&rdquo; 字符串也是办不到的。</p>
<p>普通的应用程序只能将自己的需求向操作系统倾诉，操作系统负责具体的工作，然后再把结果返回给应用程序，这个过程称为 <em>系统调用</em>。如果从应用程序角度来看操作系统的话，它既是应用程序的管理者，同时也是应用程序的打工人（是的，在计算机的世界里就是存在这种奇怪的角色）。</p>
<p>不过平常我们写应用程序很少会直接进行 <em>系统调用</em>（<em>系统调用</em> 的具体表现形式也是 <em>函数调用</em>），因为这些函数比较原始，调用起来不够方便，再者，不同的操作系统的系统调用是不同的。因此标准库（libc）把系统调用进行封装，同时为不同的平台提供不同的实现，最后打包成各种方便的函数以供我们使用。</p>
<h3 id="系统调用的实现">系统调用的实现</h3>
<p>RISC-V Linux 的系统调用实现很简单，大概以下几个步骤：</p>
<ol>
<li>每个系统调用（你可以粗略理解为 <em>函数</em>）都有一个编号，比如 <code>write</code> 函数的编号是 <code>0x40</code>，<code>exit</code> 函数的编号是 <code>0x5d</code>，把这个编号储存在寄存器 <code>a7</code> 里。</li>
</ol>
<blockquote>
<p>系统调用的编号可以查阅 <a href="https://github.com/riscv-collab/riscv-gnu-toolchain/blob/master/linux-headers/include/asm-generic/unistd.h">RISC-V GCC Linux headers - unistd.h</a></p>
</blockquote>
<ol start="2">
<li>
<p>把函数的参数的值分别储存在寄存器 <code>a0</code>、<code>a1</code> &hellip; 里。</p>
<p>每个系统调用的参数情况可以查看它的函数签名，比如 <code>write</code> 函数的签名是：</p>
<p><code>ssize_t write(int fd, const void *buf, size_t count);</code></p>
<p>从签名可知它有 3 个参数，分别是文件描述符（编号）、内容（即缓存）的开始位置、内容的长度（单位为字节），把这三个参数值分别储存在寄存器 <code>a0</code>, <code>a1</code> 和 <code>a3</code> 里。</p>
</li>
</ol>
<blockquote>
<p>系统调用的签名可以使用命令 <code>$ man 2 SYSCALL_NAME</code> 查看，注意需要在 <code>man</code> 后面添加数字 <code>2</code>，表示查看系统调用的说明。不添加或者添加数字 <code>1</code> 的话显示的是 <code>write</code> 命令的说明。顺便一提，数字 <code>3</code> 表示查看标准库的函数 <code>write</code>。</p>
</blockquote>
<ol start="3">
<li>执行 <code>ecall</code> 指令。该指令会引起一个中断，计算机的控制权由应用程序转给操作系统，操作系统捕获到这个中断并理解其目的，最后把结果储存到寄存器 <code>a0</code>，然后把计算机控制权交给应用程序。</li>
</ol>
<h3 id="程序的源代码">程序的源代码</h3>
<p>源代码位于目录 <a href="./resources/minimal-hello-world/">resouces/minimal-hello-world</a> 之下的文件 <code>app.S</code>，其内容如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-s" data-lang="s"><span style="display:flex;"><span>.equ SYSCALL_WRITE, <span style="color:#ae81ff">64</span>
</span></span><span style="display:flex;"><span>.equ SYSCALL_EXIT, <span style="color:#ae81ff">93</span>
</span></span><span style="display:flex;"><span>.equ STDOUT_FD, <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>.section .text
</span></span><span style="display:flex;"><span>.globl _start
</span></span><span style="display:flex;"><span>_start<span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># ssize_t write(int fd, const void *buf, size_t count);</span>
</span></span><span style="display:flex;"><span>    addi a7, zero, SYSCALL_WRITE
</span></span><span style="display:flex;"><span>    addi a0, zero, STDOUT_FD
</span></span><span style="display:flex;"><span>    la a1, hello_world
</span></span><span style="display:flex;"><span>    addi a2, zero, <span style="color:#ae81ff">13</span>  <span style="color:#75715e"># the length of &#34;Hello world!\n&#34;</span>
</span></span><span style="display:flex;"><span>    ecall
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># void exit(int status)</span>
</span></span><span style="display:flex;"><span>    addi a7, zero, SYSCALL_EXIT
</span></span><span style="display:flex;"><span>    addi a0, zero, <span style="color:#ae81ff">10</span>
</span></span><span style="display:flex;"><span>    ecall
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>.section .rodata
</span></span><span style="display:flex;"><span>hello_world<span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    .ascii <span style="color:#e6db74">&#34;Hello world!\n&#34;</span>
</span></span></code></pre></div><p>上面的汇编代码相当于如下的 C 代码（源代码文件 <code>app.c</code>）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;unistd.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>buf <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Hello world!</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>    write(<span style="color:#ae81ff">1</span>, buf, <span style="color:#ae81ff">13</span>);
</span></span><span style="display:flex;"><span>    exit(<span style="color:#ae81ff">10</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="编译">编译</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ riscv64-linux-gnu-as -o app.o app.S
</span></span><span style="display:flex;"><span>$ riscv64-linux-gnu-gcc -nostdlib -static -o app.out app.o
</span></span></code></pre></div><p>上面的链接命令中的参数 <code>-nostdlib</code> 表示不需要标准库。作为对比，下面也编译 C 版本的程序：</p>
<p><code>$ riscv64-linux-gnu-gcc -static -o app-std.out app.c</code></p>
<p>然后对比文件 <code>app.out</code> 和 <code>app-std.out</code> 的大小：</p>
<p><code>$ ls -lh</code></p>
<p>输出的结果如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>-rwxr-xr-x 1 yang yang 1.6K Oct 25 05:30 app.out
</span></span><span style="display:flex;"><span>-rwxr-xr-x 1 yang yang 644K Oct 25 05:34 app-std.out
</span></span></code></pre></div><p>可见汇编版本的只有 2KB 不到，而标准版本的有 644KB（当然使用静态链接也是导致体积较大的原因之一）</p>
<h3 id="运行">运行</h3>
<p><code>$ qemu-riscv64 app.out</code></p>
<p>输入的结果是一行文本 &ldquo;Hello world!&quot;。</p>
<p>下一篇文章 <a href="../qemu-and-opensbi-and-debug/README.zh-Hans.md">QEMU、OpenSBI 及裸机程序的调试</a> 我们将会详细讲解 QEMU 的使用方法，OpenSBI 的作用以及调试裸机程序的方法。</p>


</article>


<section class="post-nav">
    <ul>
        <li>
        
            <a href="https://hemashushu.github.io/posts/2022-11-08-qemu-and-debug/readme.zh-hans/"><i class="fa fa-chevron-circle-left"></i> </a>
        
        </li>
        <li>
        
            <a href="https://hemashushu.github.io/posts/2022-11-07-build-minimal-risc-v-program/readme/"> <i class="fa fa-chevron-circle-right"></i> </a>
        
        </li>
    </ul>
</section>
  
    
    
  





</main>
    <footer>
        <ul>
            <li>
                <h6>Copyright © 2022 - Hippospark | 
                    <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh"><img alt="cc by-nc-nd" class="license" src="/images/cc-by-nc-nd.png" /></a> |
                    Rendered by <a href="https://gohugo.io" title="Hugo">Hugo</a> |
                    Theme <a href="https://github.com/funkydan2/hugo-kiera" title="Kiera">Kiera</a> |
                    <a href="https://hemashushu.github.io/index.xml">Subscribe </a></h6>
            </li>
            
            
        </ul>
    </footer>
</div>
<script src="/js/scripts.js"></script>


</body>

</html>

