<!doctype html>

<html lang="en-us">

<head>
  <title>Hemashushu Blog</title>
  <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="description" content="Share some low level computer technology, programming skills, learning notes, and some softwares" />
<meta name="author" content="hemashushu" /><meta property="og:title" content="" />
<meta property="og:description" content="RISC-V GCC 快速入门 XiaoXuan Assembler 需要其它编译器的编译结果作为参照物，而 RISC-V GCC 是比较完善和成熟的 RISC-V 编译器，因此 XiaoXuan Assembler 默认选用它对编译、汇编和链接的结果进行参考、验证和测试。 本篇文章将会构建两个非常简单的程序：一个 &ldquo;Hello World!&rdquo; 程序和一个裸机程序，通过构建的过程以简单了解 RISC-V GCC 的基本使用方法。 RISC-V GCC 介绍 QEMU 模拟器 第一个程序 编译 可执行文件 二进制工具 size readelf objdump 运行 分阶段编译 常用的编译参数 裸机程序 程序的组成 基础库 计算库 主程序 启动器 编译 打包目标文件 链接 运行 RISC-V GCC 介绍 假设我们工作环境的架构是 x86_64，现在需要把程序（的源代码）编译成可以在 RISC-V 架构上运行的程序" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://hemashushu.github.io/posts/2022-11-06-risc-v-gcc-quick-start/readme.zh-hans/" /><meta property="article:section" content="posts" />

<meta property="og:site_name" content="Hemashushu Blog" />


<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content=""/>
<meta name="twitter:description" content="RISC-V GCC 快速入门 XiaoXuan Assembler 需要其它编译器的编译结果作为参照物，而 RISC-V GCC 是比较完善和成熟的 RISC-V 编译器，因此 XiaoXuan Assembler 默认选用它对编译、汇编和链接的结果进行参考、验证和测试。 本篇文章将会构建两个非常简单的程序：一个 &ldquo;Hello World!&rdquo; 程序和一个裸机程序，通过构建的过程以简单了解 RISC-V GCC 的基本使用方法。 RISC-V GCC 介绍 QEMU 模拟器 第一个程序 编译 可执行文件 二进制工具 size readelf objdump 运行 分阶段编译 常用的编译参数 裸机程序 程序的组成 基础库 计算库 主程序 启动器 编译 打包目标文件 链接 运行 RISC-V GCC 介绍 假设我们工作环境的架构是 x86_64，现在需要把程序（的源代码）编译成可以在 RISC-V 架构上运行的程序"/>

<meta name="generator" content="Hugo 0.102.0-DEV" />
    

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css" integrity="sha256-l85OmPOjvil/SOvVt3HnSSjzF1TUMyT9eV0c2BzEGzU=" crossorigin="anonymous" />
  <link rel="stylesheet" href="https://hemashushu.github.io/fontawesome/css/all.min.css" />
  

  
  
  <link rel="stylesheet" type="text/css" href="/css/styles.css" /><link rel='stylesheet' href='https://hemashushu.github.io/css/custom.css'></head>

<body>
  <div id="container">
    <header>
      
      <h1>
        <a href="/">Hemashushu Blog</a>
      </h1>

      <ul id="social-media">
        
             <li>
               <a href="https://github.com/hemashushu" title="GitHub">
               <i class="fab fa-github fa-lg"></i>
               </a>
             </li>
             <li>
               <a href="https://twitter.com/hemashushu" title="Twitter">
               <i class="fab fa-twitter fa-lg"></i>
               </a>
             </li>
      </ul>
      
      <p><em>Fun and interesting computer technology</em></p>
      
    </header>

    
<nav>
    <ul>
        
        <li>
            <a class="active" href="/posts/">
                <i class="fa-li fa  fa-lg"></i><span>Posts</span>
            </a>
        </li>
        
        <li>
            <a class="" href="/about/">
                <i class="fa-li fa  fa-lg"></i><span>About</span>
            </a>
        </li>
        
    </ul>
</nav>


    <main>




<article>

    <h1></h1>

    
      <aside>
    <ul>
        <li>
            <time class="post-date" datetime="0001-01-01T00:00:00Z">Jan 1, 0001</time>
        </li>
        
        

        

        <li>21 minute read</li>
    </ul>
</aside>

    

    
      

    

    <h1 id="risc-v-gcc-快速入门">RISC-V GCC 快速入门</h1>
<p>XiaoXuan Assembler 需要其它编译器的编译结果作为参照物，而 <a href="https://github.com/riscv-collab/riscv-gnu-toolchain">RISC-V GCC</a> 是比较完善和成熟的 RISC-V 编译器，因此 XiaoXuan Assembler 默认选用它对编译、汇编和链接的结果进行参考、验证和测试。</p>
<p>本篇文章将会构建两个非常简单的程序：一个 &ldquo;Hello World!&rdquo; 程序和一个裸机程序，通过构建的过程以简单了解 RISC-V GCC 的基本使用方法。</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<ul>
<li><a href="#risc-v-gcc-%E4%BB%8B%E7%BB%8D">RISC-V GCC 介绍</a></li>
<li><a href="#qemu-%E6%A8%A1%E6%8B%9F%E5%99%A8">QEMU 模拟器</a></li>
<li><a href="#%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F">第一个程序</a>
<ul>
<li><a href="#%E7%BC%96%E8%AF%91">编译</a></li>
<li><a href="#%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6">可执行文件</a></li>
<li><a href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%B7%A5%E5%85%B7">二进制工具</a>
<ul>
<li><a href="#size"><code>size</code></a></li>
<li><a href="#readelf"><code>readelf</code></a></li>
<li><a href="#objdump"><code>objdump</code></a></li>
</ul>
</li>
<li><a href="#%E8%BF%90%E8%A1%8C">运行</a></li>
<li><a href="#%E5%88%86%E9%98%B6%E6%AE%B5%E7%BC%96%E8%AF%91">分阶段编译</a></li>
<li><a href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E7%BC%96%E8%AF%91%E5%8F%82%E6%95%B0">常用的编译参数</a></li>
</ul>
</li>
<li><a href="#%E8%A3%B8%E6%9C%BA%E7%A8%8B%E5%BA%8F">裸机程序</a>
<ul>
<li><a href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BB%84%E6%88%90">程序的组成</a>
<ul>
<li><a href="#%E5%9F%BA%E7%A1%80%E5%BA%93">基础库</a></li>
<li><a href="#%E8%AE%A1%E7%AE%97%E5%BA%93">计算库</a></li>
<li><a href="#%E4%B8%BB%E7%A8%8B%E5%BA%8F">主程序</a></li>
<li><a href="#%E5%90%AF%E5%8A%A8%E5%99%A8">启动器</a></li>
</ul>
</li>
<li><a href="#%E7%BC%96%E8%AF%91-1">编译</a></li>
<li><a href="#%E6%89%93%E5%8C%85%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6">打包目标文件</a></li>
<li><a href="#%E9%93%BE%E6%8E%A5">链接</a></li>
<li><a href="#%E8%BF%90%E8%A1%8C-1">运行</a></li>
</ul>
</li>
</ul>
<!-- raw HTML omitted -->
<h2 id="risc-v-gcc-介绍">RISC-V GCC 介绍</h2>
<p>假设我们工作环境的架构是 <em>x86_64</em>，现在需要把程序（的源代码）编译成可以在 RISC-V 架构上运行的程序，这种编译叫做 <em>交叉编译</em>。相对地，在 “当前架构” 里编译出给 &ldquo;当前架构&rdquo; 运行的程序，这种编译叫 <em>本地编译</em>，或者简称编译。交叉编译本质上是 &ldquo;根据源代码生成目标架构的一系列指令&rdquo;，交叉编译器在的实现方法跟普通的编译器是一样的，只是生成的指令不是当前架构，而是目标架构的指令。</p>
<p>在进行交叉编译时，通常需要确定 <em>目标架构</em> 和 <em>目标平台</em>。</p>
<ul>
<li><em>目标架构</em> 是指目标机器的 CPU 指令集架构（ISA，有时简称为 <em>指令集</em> 也是可以的），比如常用的 Intel 和 AMD CPU 的指令集是 <em>x86_64</em>，移动电话用的 ARM CPU 指令集是 <em>aarch64</em>，以及项目 XiaoXuan Assembly - RISCV 的目标 CPU 的指令集是 <em>rv64g</em> 等等。</li>
<li><em>目标平台</em> 是指 <em>目标操作系统</em>，当然在开发程序时，可能还得考虑目标平台更细化的一些信息，比如目标平台是哪个 Linux 发行版，因为不同的发行版的文件系统层次结构（FHS，Filesystem Hierarchy Standard）往往有细微的差别，这会导致诸如共享库等文件的所在位置有所不同。但对于编译器来说，它只需确定目标架构和目标平台即可。</li>
</ul>
<p>对于 <em>裸机程序</em>，即在 &ldquo;无操作系统&rdquo; 的环境里运行的程序，比如在微控制器（MCU）里运行的程序，或者内核程序，在编译时则只需确认 <em>目标架构</em> 即可。</p>
<p>GCC 是一套常用编译工具（另一个是 LLVM），而 RISC-V GCC 则是基于 GCC 且目标架构设定为 RISC-V 的交叉编译工具。在大部分 Linux 发行版里都可以通过包管理器找到它并安装它。注意在通过包管理器安装 RISC-V GCC 的时候，可能会发现有两套名称相近的工具，比如在 <em>Arch Linux</em> 里，有 <code>riscv64-elf-gcc</code>、<code>riscv64-elf-gdb</code>、<code>riscv64-elf-binutils</code> 和 <code>riscv64-linux-gnu-gcc</code>、<code>riscv64-linux-gnu-gdb</code>、<code>riscv64-linux-gnu-binutils</code>（在 <em>Ubuntu</em> 里，它们分别叫 <code>gcc-riscv64-unknown-elf</code>、<code>gcc-riscv64-linux-gnu</code> 和 <code>gdb-multiarch</code>）。前者用于编译 &ldquo;裸机&rdquo; 程序，后者用于编译在 Linux 环境中运行的程序，也就是我们平常所接触到的程序。条件允许的话，建议两套工具都安装。如果你系统的包仓库里没有 RISC-V GCC，则可以从 <a href="https://github.com/riscv-collab/riscv-gcc">官方的仓库</a> 下载源码并通过源码的方式安装。</p>
<h2 id="qemu-模拟器">QEMU 模拟器</h2>
<p>对于 RISC-V GCC 生成的程序，当然需要在 RISC-V 架构的机器上运行，不过至书写本文的时间（2022 年）为止，尚未有成熟且经济的 RISC-V 硬件，大部分 RISC-V 计算机仍以开发板的形式提供。所以为了便于测试程序，XiaoXuan Assembler 是通过 <a href="https://www.qemu.org/">QEMU</a> 模拟器来运行和测试 RISC-V 程序的。</p>
<p>大部分 Linux 发行版里的包仓库里都包含有 QEMU，所以只需使用系统的包管理器就可以安装 QEMU，比如在 <em>Arch Linux</em> 里，需要安装包 <code>qemu-system-riscv</code>、<code>qemu-user</code> 和 <code>qemu-user-static</code>（在 <em>Ubuntu</em> 里，包名分别为 <code>qemu-system</code>，<code>qemu-user</code> 和 <code>qemu-user-static</code>）。对于包仓库里没有 QEMU 的发行版，可以下载 QEMU 的源码，然后根据<a href="https://wiki.qemu.org/Documentation/Platforms/RISCV">这篇指引</a>编译安装。</p>
<p>QEMU 可以模拟一整套完整的硬件，包括 CPU、内存、磁盘、网络接口、USB 接口等组件，除此之外，QEMU 还可以模拟一个 Linux 系统。也就是说，QEMU 有两种工作模式，前者称为 <em>全系统模式</em>，在这种模式下可以执行所有 CPU 指令，可以运行裸机程序。后者称为 <em>用户模式</em>，可以直接运行编译目标平台为 Linux 的程序。</p>
<p>全系统模式使用程序 <code>qemu-system-riscv64</code> 来启动，可以通过参数指定机器类型、CPU 核心的数量、内存的容量、虚拟磁盘等。用户模式使用程序 <code>qemu-riscv64</code> 来启动，把我们写的应用程序（可执行文件）的文件路径作为参数传给这个程序即可，在这种模式下，QEMU 会把应用程序转换为主机平台支持的程序，所以如果要写了一个向控制台打印一行字符的 &ldquo;Hello world&rdquo; 程序，让它跑起来的最快方法是使用 <code>riscv64-linux-gnu-gcc</code> 编译，然后使用 <code>qemu-riscv64</code> 来运行。</p>
<h2 id="第一个程序">第一个程序</h2>
<p>第一个程序是一个非常简单的程序，其功能是向屏幕打印一行文字 &ldquo;Hello world!&quot;。下面快速地过一遍编译、链接、运行的过程。</p>
<p>第一个程序的源代码文件位于目录 <a href="./resources/hello-world/">resources/hello-world</a> 里，文件名为 <code>app.c</code>，其内容如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    printf(<span style="color:#e6db74">&#34;Hello world!</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="编译">编译</h3>
<p>首先切换到文本所在的目录的子目录 <a href="./resources/hello-world/">resources/hello-world</a>：</p>
<p><code>$ cd resources/hello-world</code></p>
<p>因为这不是 &ldquo;裸机&rdquo; 程序，因此需要使用 <code>riscv64-linux-gnu-gcc</code> 来编译：</p>
<p><code>$ riscv64-linux-gnu-gcc -g -Wall -o app.out app.c</code></p>
<ul>
<li>参数 <code>-g</code> 用于生成额外的调试信息（可供 GDB 使用）；</li>
<li>参数 <code>-Wall</code> 用于报告编译过程中的所有警告和错误信息；</li>
<li>参数 <code>-o app.out</code> 用于指定输出的文件的名称，如果缺省这个参数，默认的输出文件名为 <code>a.out</code>。</li>
</ul>
<p>编译完成后得到文件 <code>app.out</code>。</p>
<h3 id="可执行文件">可执行文件</h3>
<p>使用 <code>file</code> 命令可以查看该文件的格式：</p>
<p><code>$ file app.out</code></p>
<p>输出结果如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>app.out: ELF 64-bit LSB pie executable, UCB RISC-V, RVC, double-float ABI, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux-riscv64-lp64d.so.1, BuildID[sha1]=eb3dabb395852de771d6ac7129d1da24ca574350, for GNU/Linux 4.15.0, with debug_info, not stripped
</span></span></code></pre></div><ul>
<li>
<p><code>ELF</code> 和 <code>executable</code>，表明当前文件是一个 ELF 格式当中的 <em>可执行文件</em>。ELF 格式的文件主要有 3 种类型：</p>
<ol>
<li><code>executable</code> 是 <em>可执行文件</em>；</li>
<li><code>shared object</code> 是 <em>共享对象文件</em>，也就是共享库，用于在运行时动态地被可执行文件链接（或者说 <em>调用</em>）。</li>
<li><code>relocatable</code> 是 <em>可重定向文件</em>，即编译任务中途产生的 <em>目标文件</em>，当只编译而不链接一个 C 源代码文件时，产生的正是这种类型的文件。这种 &ldquo;中间阶段产生&rdquo; 的文件主要用来链接，以产生最后的结果 ———— 可执行文件或者共享库。</li>
</ol>
</li>
<li>
<p><code>dynamically linked</code>, <code>interpreter ...</code>，表明当前可执行文件是 <em>动态链接</em> 类型，也就是说它在运行时，要需要其它共享库的帮忙才能完成所有工作。而这些库的加载任务则由 <code>interpreter</code> 指定的程序来完成，或者说 <code>interpreter</code> 指定的是一个 <em>运行时动态链接器</em>，或者简单理解为 <em>应用程序初始化器，共享库加载器</em>。可执行文件还可以是 <em>静态链接</em> 类型，表示它在运行时不需要其它共享库帮忙，只需操作系统的支持，其它的工作全部自己完成。</p>
</li>
<li>
<p><code>pie</code>，表明当前的可执行文件是 <code>位置无关的可执行文件</code>（<code>Position Independent Executables</code>），这部分内容将会在本项目的其它文章里讲解。</p>
</li>
<li>
<p><code>64-bit</code>, <code>RISC-V</code>, <code>double-float ABI</code>，<code>GNU/Linux 4.15.0</code>，这些零散的信息表明当前可执行文件的目标架构、目标平台以及目标平台的一些细化信息，这些内容将会在本项目的其它文章里讲解。</p>
</li>
<li>
<p><code>LSB</code>，表明当前可执行文件里的数据是 &ldquo;低端字节优先&rdquo;（&ldquo;least-significant byte first&rdquo;）的，相当于平常说的 &ldquo;低端序&rdquo;（&ldquo;little-endian&rdquo;）。相对的，还有 <code>MSB</code>，即 &ldquo;高端字节优先&rdquo;（&ldquo;most-significant byte&rdquo;），相当于 &ldquo;高端序&rdquo;（&ldquo;big-endian&rdquo;）。这决定了一个整数在内存或者磁盘种如何储存，比如数字 <code>0x11223344</code>，在内存中如果使用 <code>LSB</code>，则被储存为 &ldquo;(低地址) 44 33 22 11 （高地址）&quot;，如果使用 <code>MSB</code>，则会被储存为 &ldquo;(低地址) 11 22 33 44（高地址）&quot;。用十六进制查看器查看 <code>LSB</code> 类型的可执行文件的内容时，如果看的内容是数字，那么需要在脑海里把数字反过来再组合才是它的真实值，而如果看的内容是字符串，则可以很自然地顺序阅读。简单来说，看数字很头痛，看文本很舒畅，而 <code>MSB</code> 则刚好相反。不过这都是人类才有的烦恼，对于计算机来说都是一样的哦。</p>
</li>
<li>
<p><code>with debug_info</code>, <code>not stripped</code>，表明当前可执行文件里包含调试信息。</p>
</li>
</ul>
<p><code>file</code> 命令只能非常粗略地查看文件的格式和类型，如果想详细了解 <code>ELF</code> 的内容，还需要下面的二进制工具。</p>
<h3 id="二进制工具">二进制工具</h3>
<p>在安装 RISC-V GCC 时，还同时安装了 RISC-V Binutils，这套工具链提供了跟 <a href="https://www.gnu.org/software/binutils/">GNU Binutils</a> 对应的工具。</p>
<h4 id="size"><code>size</code></h4>
<p>首先是查看程序大小的工具 <code>size</code>：</p>
<p><code>$ riscv64-linux-gnu-size app.out</code></p>
<p>输出结果如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>   text    data     bss     dec     hex filename
</span></span><span style="display:flex;"><span>   1123     584       8    1715     6b3 app.out
</span></span></code></pre></div><ul>
<li><code>text</code> 表示程序的指令序列；</li>
<li><code>data</code> 表示程序的初始数据；</li>
<li><code>bss</code> 表示未初始化的（或者初始值为 <code>0</code> 的）全局变量。</li>
<li><code>dec</code> 和 <code>hex</code> 是前面三项内容的大小（单位为字节）的总和的十进制和十六进制。</li>
</ul>
<p>需要注意的是 <code>bss</code> 的数值用于在内存里提前分配空间，除了一个整数之外，本身不占文件任何空间，但在统计时，仍然把它也加上了。</p>
<p>根据上面显示的数值可知，编译器在我们写的应用程序里塞入了不少的额外的内容，毕竟当前程序只有一个只包含一条 <code>printf</code> 语句的函数，这样的一条语句不太可能对应 1000 多个字节的指令，而且文本内容 &ldquo;Hello world!\n&rdquo; 也没有 500 多字节。</p>
<h4 id="readelf"><code>readelf</code></h4>
<p>工具 <code>readelf</code> 可以查看该 ELF 文件的详细信息：</p>
<p><code>$ riscv64-linux-gnu-readelf -l app.out</code></p>
<p>输出的（部分）结果如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>Elf file type is DYN (Position-Independent Executable file)
</span></span><span style="display:flex;"><span>Entry point 0x5b0
</span></span><span style="display:flex;"><span>There are 10 program headers, starting at offset 64
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Program Headers:
</span></span><span style="display:flex;"><span>  Type           Offset             VirtAddr           PhysAddr
</span></span><span style="display:flex;"><span>                 FileSiz            MemSiz              Flags  Align
</span></span><span style="display:flex;"><span>  LOAD           0x0000000000000000 0x0000000000000000 0x0000000000000000
</span></span><span style="display:flex;"><span>                 0x00000000000006e4 0x00000000000006e4  R E    0x1000
</span></span><span style="display:flex;"><span>  LOAD           0x0000000000000e08 0x0000000000001e08 0x0000000000001e08
</span></span><span style="display:flex;"><span>                 0x0000000000000248 0x0000000000000250  RW     0x1000
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> Section to Segment mapping:
</span></span><span style="display:flex;"><span>  Segment Sections...
</span></span><span style="display:flex;"><span>   03     .interp .note.gnu.build-id .note.ABI-tag .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn .rela.plt .plt .text .rodata .eh_frame_hdr .eh_frame
</span></span><span style="display:flex;"><span>   04     .preinit_array .init_array .fini_array .dynamic .data .got .bss
</span></span></code></pre></div><p>下面简单讲解上面的内容：</p>
<ul>
<li>
<p><code>LOAD</code> 表示将会被加载进内存的 segment（因为 <code>segment</code> 和 <code>section</code> 在中文里都叫作 <code>段</code>，所以这里直接使用英文名称。一般情况下 <code>段</code> 是指 <code>section</code>），下方的 <code>Section to Segment mapping</code> 列举了每个 segment 由哪些 section 组成。</p>
<p>ELF 文件的主要内容由多个段（section）组成，这些段可以形成两个视图：从程序加载器的角度看，有一个叫 <code>segments</code> 的视图；从编译器、链接器角度看有一个叫 <code>sections</code> 的视图。</p>
</li>
<li>
<p><code>LOAD</code> 项目显示了 segment 的文件偏移地址、虚拟地址、物理地址、在文件中的大小、在内存中的大小、标记等信息（这些内容会在本项目的其它文章种讲解）。这些信息会决定程序加载器如何处理 segment，比如 <code>RE</code> 标记表示这段内容在内存中具有 &ldquo;read, execute&rdquo; 权限，<code>RW</code> 标记表示这段内容在内存中具有 &ldquo;read, write&rdquo; 权限。</p>
</li>
</ul>
<blockquote>
<p>在现代的 CPU 内存管理单元里，物理内存被虚拟化，并以固定的大小（比如 4KB）划分为一个个区块（叫作 <em>页面</em>），每个内存页面都可以有不同的权限，比如有些内存页面只可读、有些可读写、有些可执行。</p>
</blockquote>
<ul>
<li><code>Entry point 0x5b0</code> 表示程序的入口，即程序第一个会被执行的指令，位于地址 <code>0x5b0</code>，。</li>
</ul>
<h4 id="objdump"><code>objdump</code></h4>
<p>工具 <code>objdump</code> 可以反汇编可执行文件当中的代码段，查看位置 <code>0x5b0</code> 的内容：</p>
<p><code>$ riscv64-linux-gnu-objdump -d app.out</code></p>
<p>输出（部分）结果如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>Disassembly of section .text:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>00000000000005b0 &lt;_start&gt;:
</span></span><span style="display:flex;"><span> 5b0:   022000ef                jal     ra,5d2 &lt;load_gp&gt;
</span></span><span style="display:flex;"><span> 5b4:   87aa                    mv      a5,a0
</span></span><span style="display:flex;"><span> 5b6:   00002517                auipc   a0,0x2
</span></span><span style="display:flex;"><span> 5ba:   a8253503                ld      a0,-1406(a0) # 2038 &lt;_GLOBAL_OFFSET_TABLE_+0x10&gt;
</span></span><span style="display:flex;"><span> 5be:   6582                    ld      a1,0(sp)
</span></span><span style="display:flex;"><span> 5c0:   0030                    addi    a2,sp,8
</span></span><span style="display:flex;"><span> 5c2:   ff017113                andi    sp,sp,-16
</span></span><span style="display:flex;"><span> 5c6:   4681                    li      a3,0
</span></span><span style="display:flex;"><span> 5c8:   4701                    li      a4,0
</span></span><span style="display:flex;"><span> 5ca:   880a                    mv      a6,sp
</span></span><span style="display:flex;"><span> 5cc:   fc5ff0ef                jal     ra,590 &lt;__libc_start_main@plt&gt;
</span></span><span style="display:flex;"><span> 5d0:   9002                    ebreak
</span></span></code></pre></div><p>看到这里你可能感到很惊讶，原来程序的入口（即最先开始执行的指令）并不是 <code>main</code> 函数，而是一个名为 <code>_start</code> 的过程（大部分 C 语言的教科书或者教程都跟我们说：程序的入口是 <code>main</code> 函数，这是一个善意的谎言）。<code>_start</code> 过程会做一系列的初始化工作，然后才会调用 <code>main</code> 函数，在 <code>main</code> 函数执行完毕之后，它还会做一些清理工作。</p>
<p>在上一个输出的结果里往下翻，就可以找到函数 <code>main</code> 的内容：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>0000000000000668 &lt;main&gt;:
</span></span><span style="display:flex;"><span> 668:   1141                    addi    sp,sp,-16
</span></span><span style="display:flex;"><span> 66a:   e406                    sd      ra,8(sp)
</span></span><span style="display:flex;"><span> 66c:   e022                    sd      s0,0(sp)
</span></span><span style="display:flex;"><span> 66e:   0800                    addi    s0,sp,16
</span></span><span style="display:flex;"><span> 670:   00000517                auipc   a0,0x0
</span></span><span style="display:flex;"><span> 674:   02050513                addi    a0,a0,32 # 690 &lt;_IO_stdin_used+0x8&gt;
</span></span><span style="display:flex;"><span> 678:   f29ff0ef                jal     ra,5a0 &lt;puts@plt&gt;
</span></span><span style="display:flex;"><span> 67c:   0001                    nop
</span></span><span style="display:flex;"><span> 67e:   60a2                    ld      ra,8(sp)
</span></span><span style="display:flex;"><span> 680:   6402                    ld      s0,0(sp)
</span></span><span style="display:flex;"><span> 682:   0141                    addi    sp,sp,16
</span></span><span style="display:flex;"><span> 684:   8082                    ret
</span></span></code></pre></div><p>该段指令包含了普通函数的 <em>开场白</em> 和 <em>收场白</em> 模板代码，以及一句对函数 <code>puts</code> 的调用。</p>
<h3 id="运行">运行</h3>
<p>因为 <code>app.out</code> 不是 &ldquo;裸机&rdquo; 程序，它依赖平台（即操作系统，平台提供了包括程序加载、内存分配和系统调用等功能）才能运行，为了简单起见，可以使用 QEMU 模拟器的 <em>用户模式</em> 程序 <code>qemu-riscv64</code> 来运行：</p>
<p><code>$ qemu-riscv64 app.out</code></p>
<p>运行的结果是：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>qemu-riscv64: Could not open &#39;/lib/ld-linux-riscv64-lp64d.so.1&#39;: No such file or directory
</span></span></code></pre></div><p>显然程序并没有正确地运行，这是因为当前应用程序调用了 <code>printf</code> 函数，而这个函数实际上是调用了标准库的函数 <code>puts</code>。</p>
<p>RISC-V GCC 默认产生动态链接类型的程序，在运行这种程序时需要一个 <em>运行时动态链接器</em>（在当前的例子里，它就是 <code>ld-*.so</code>）加载程序所需的共享库，以及进行一系列的初始化工作（比如寻找标准库当中函数 <code>puts</code> 的地址）。然而不幸的是 <code>qemu-riscv64</code> 好像不能正确地定位 <code>ld-*.so</code>。</p>
<blockquote>
<p>虽然 <em>动态链接</em> 概念对操作系统来说是不错的主意，但对于普通用户来说，应用程序的动态链接导致的问题令人相当头痛。</p>
</blockquote>
<p>河马蜀黍暂时没找到优雅地解决该问题的方法，因此下面换一种方式：生成静态链接类型的可执行文件。即在用 GCC 编译时传入 <code>-static</code> 参数，用于指示 GCC 生成静态链接的程序，也就是说，GCC 会把被调用的外部函数的二进制代码（即指令序列）复制进我们的可执行文件里，这样程序在运行时就不需要其它共享库了，自然也不需要 <code>ld.so</code> 了，它直接跟操作系统打交道：</p>
<p><code>$ riscv64-linux-gnu-gcc -static -o app.static.out app.c</code></p>
<p>先看看文件格式：</p>
<p><code>$ file app.static.out</code></p>
<p>输出结果：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>app.static.out: ELF 64-bit LSB executable, UCB RISC-V, RVC, double-float ABI, version 1 (SYSV), statically linked, BuildID[sha1]=e5483614d4b600c22bdada95913a953eae577965, for GNU/Linux 4.15.0, with debug_info, not stripped
</span></span></code></pre></div><p>原先的 &ldquo;dynamically linked&rdquo; 已经变为 &ldquo;statically linked&rdquo;。再看看文件的大小：</p>
<p><code>$ riscv64-linux-gnu-size app.static.out</code></p>
<p>输出结果如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>   text    data     bss     dec     hex filename
</span></span><span style="display:flex;"><span> 387532   22024   21760  431316   694d4 app.static.out
</span></span></code></pre></div><p>代码段的大小从 1KB 多增长到近 400KB，这是因为链接器把所用到的函数的二进制代码都复制过来了，如果反汇编 <code>app.static.out</code> 将会得到超长的文本，因此这里就略过了，下面运行这个静态链接的可执行文件：</p>
<p><code>$ qemu-riscv64 app.static.out</code></p>
<p>这次得到了预期的结果：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>Hello world!
</span></span></code></pre></div><p>那么究竟有没办法用 <code>qemu-riscv64</code> 运行动态链接的程序呢？方法当然是有的，只需让 <code>qemu-riscv64</code> 找到 <code>ld.so</code> 的正确路径就可以了！</p>
<p>如果你的系统是 <em>Arch Linux</em>，会发现文件 <code>ld-linux-riscv64-lp64d.so.1</code> 的正确目录是 <code>/usr/riscv64-linux-gnu/lib</code>，按照 <code>qemu-riscv64</code> 的说明，只要把这个路径通过参数 <code>-L /path/to/ld.so</code> 或者环境变量 <code>QEMU_LD_PREFIX</code> 传入即可，然而河马蜀黍并没有成功（原因未知）。下面演示另一种解决方法，即指定程序的 <em>运行时动态链接器</em>，操作步骤如下：</p>
<ol>
<li>
<p>在链接时传入参数 <code>--dynamic-linker /path/to/ld.so</code> 更改程序的 <code>interpreter</code>，命令如下：</p>
<p><code>$ riscv64-linux-gnu-gcc -g -Wall -Wl,--dynamic-linker,/usr/riscv64-linux-gnu/lib/ld-linux-riscv64-lp64d.so.1 -o app.out app.c -L /usr/riscv64-linux-gnu/lib -lc</code></p>
<p>编译完毕之后，可以使用 <code>file</code> 命令检查程序：</p>
<p><code>$ file app.out</code></p>
<p>输出结果如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>app.out: ELF 64-bit LSB pie executable, UCB RISC-V, RVC, double-float ABI, version 1 (SYSV), dynamically linked, interpreter /usr/riscv64-linux-gnu/lib/ld-linux-riscv64-lp64d.so.1, BuildID[sha1]=973ca74e3c1f08bde10d29d173aa6370ab947b2b, for GNU/Linux 4.15.0, with debug_info, not stripped
</span></span></code></pre></div><p>可见 <code>interpreter</code> 已经成功更改为指定的路径。</p>
</li>
<li>
<p>在运行程序的时候，添加 RISC-V Linux GNU 共享库的位置：</p>
<p><code>$ LD_LIBRARY_PATH=/usr/riscv64-linux-gnu/lib qemu-riscv64 app.out</code></p>
</li>
</ol>
<p>如此一来就能正确运行程序了。</p>
<p>上面的命令的参数非常多，具体的含义，以及优雅的编译和运行动态链接程序的方法，请看本项目的另一篇文章 <a href="../dynamic-linking/README.zh-Hans.md">动态链接的原理</a>。</p>
<h3 id="分阶段编译">分阶段编译</h3>
<p>当执行命令 <code>riscv64-linux-gnu-gcc</code> 将一个 C 源代码编译为一个可执行文件时，实际上 GCC 是分 4 个阶段（或者说步骤）来完成的：</p>
<p><img src="images/gcc-compile-stage.png" alt="GCC compile stages"></p>
<ol>
<li>
<p>预处理</p>
<p>将源代码里的 <code>include</code> 文件包含进来，解析其中的条件编译指令（<code>#ifdef</code>），展开宏（<code>macro</code>）等。相当于命令：</p>
<p><code>$ riscv64-linux-gnu-cpp app.c &gt; app.i</code></p>
<p>或者</p>
<p><code>$ riscv64-linux-gnu-gcc -E app.c &gt; app.i</code></p>
<p>注意上面程序 <code>riscv64-linux-gnu-cpp</code> 当中的 &ldquo;cpp&rdquo; 是指 &ldquo;C Preprocessor&rdquo;，而不是 &ldquo;C++&rdquo; 的意思。经过预处理的 C 语言源代码文件的扩展名为 <code>*.i</code>。</p>
</li>
<li>
<p>编译</p>
<p>将 C 代码编译为汇编代码，相当于命令：</p>
<p><code>$ riscv64-linux-gnu-gcc -S app.i</code></p>
<p>第 1 到第 2 步也可以一步完成：</p>
<p><code>$ riscv64-linux-gnu-gcc -S app.c</code></p>
<p>生成的汇编源代码文件的扩展名为 <code>*.s</code>，注意这跟我们手写的汇编源代码文件扩展名 <code>*.S</code> 不同。大写 <code>S</code> 表示会经过预处理（比如处理 <code>.include</code> 指令）在进入下一步的汇编处理，而小写的 <code>s</code> 表示不会进行预处理。具体的扩展名和 GCC 参数可以参考<a href="https://gcc.gnu.org/onlinedocs/gcc/Overall-Options.html">这篇文章</a>。</p>
</li>
<li>
<p>汇编</p>
<p>将汇编代码转换为机器指令序列，并生成目标文件，相当于命令：</p>
<p><code>$ riscv64-linux-gnu-as -o app.o app.s</code></p>
<p>第 1 到第 3 步也可以一步完成：</p>
<p><code>$ riscv64-linux-gnu-gcc -c -o app.o app.c</code></p>
<p>参数 <code>-c</code> 表示只编译但不链接。</p>
</li>
<li>
<p>链接</p>
<p>将多个目标文件链接起来，并重新定位其中的全局变量和函数的地址，最后生成 ELF 格式的可执行文件，相当于命令：</p>
<p><code>$ riscv64-linux-gnu-ld -o app.out app_startup.o app.o</code></p>
<p>上面的命令会将 <code>app_startup.o</code> 和 <code>app.o</code> 两个目标文件链接起来并生成（动态链接类型的）可执行文件 <code>app.out</code>。</p>
<p>注意，上面的 <code>app_startup.o</code> 是一个假象的应用程序启动器（提供应用的入口 <code>_start</code> 过程以及做一些初始化和清理工作），在当前示例的源代码目录里并不存在，所以上面的命令并不能成功地运行。</p>
<p>上面的第 1 到 第 4 个步骤可以一步完成：</p>
<p><code>$ riscv64-linux-gnu-gcc -o app.out app.c</code></p>
<p>如果你想知道 GCC 在编译过程中的每个步骤以及细节，可以传入 <code>-v</code> 参数，比如 <code>$ riscv64-linux-gnu-gcc -v -o app.out app.c</code>。</p>
</li>
</ol>
<blockquote>
<p>在平常的编译程序任务中，我们并不需要分成 4 步，一般只需分成 <em>编译</em> 和 <em>链接</em> 2 步，而且一般都是借助诸如 <code>make</code> 等构建工具来完成。但我们仍然需要清楚知道编译器的各个阶段的作用，理解这些概念有助于解决在编译过程遇到的各种问题。</p>
</blockquote>
<h3 id="常用的编译参数">常用的编译参数</h3>
<p>除了上面已经演示过的，GCC 还有一些其它常用的参数：</p>
<ul>
<li>
<p><code>-I</code> 用于指定头文件的路径</p>
<p>有时头文件（<code>*.h</code>）分布在多个目录，这时可以用参数 <code>-I</code> 把额外的头文件的路径包含进来，比如当前的路径为 <code>/home/yang/hello-world/app.c</code>，假如有额外的头文件位于 <code>/home/yang/hello-world/include/</code>，则可以这样传入参数：</p>
<p><code>$ riscv64-linux-gnu-gcc -I /home/yang/hello-world/include app.c</code></p>
</li>
<li>
<p><code>-L</code> 和 <code>-l</code> 用于指定额外库的路径和名称</p>
<p>接着上一个例子，如果应用程序需要使用到库 <code>/home/yang/hello-world/lib/libmymath.a</code>，则可以这样传入参数：</p>
<p><code>$ riscv64-linux-gnu-gcc app.c -L /home/yang/hello-world/lib -lmymath</code></p>
<p>其中参数 <code>-lmymath</code> 的 <code>-l</code> 是参数名称，<code>mymath</code> 是参数值，等效于 <code>-l mymath</code>。这个参数表示编译过程会使用到库文件 <code>libmymath.a</code>。</p>
<p>注意参数 <code>-l</code> 的值是库的 <code>soname</code>，比如上例种库文件的真实名称是 <code>libmymath.a</code>，去除了前缀 <code>lib</code> 和后缀 <code>.a</code>（或者 <code>.so</code>）之后就是 <code>soname</code> 了。更多的例子，比如 <code>libm.so</code> 的 <code>soname</code> 是单独一个字母 <code>m</code>，<code>libpthread.so</code> 的是 <code>pthread</code>。</p>
</li>
</ul>
<blockquote>
<p>注意：一般需要把参数 <code>-L ... -l ...</code> 放在命令的末尾，也就是依赖项的顺序必须遵循 &ldquo;被依赖的放在后面&rdquo; 的原则，如果顺序不对有可能导致链接失败。</p>
</blockquote>
<p>GCC 的编译过程是松散的，它由上一节所述的 4 个相对独立的阶段组成，显然头文件是在预处理阶段使用，而库文件则是在链接阶段使用，当使用一个 GCC 命令编译一个程序时，参数 <code>-I -L -l</code> 需要全部填上。</p>
<h2 id="裸机程序">裸机程序</h2>
<p>裸机程序是指在 &ldquo;无操作系统&rdquo; 的环境中运行的程序，听起来可能会觉得很神奇：一个机器不用安装操作系统也能运行应用程序？是的，很显然诸如操作系统的引导器，以及操作系统本身就是裸机程序。</p>
<p>裸机程序跟普通应用程序并没有太大的区别，其中的数值计算、流程控制、程序的结构等跟普通应用程序是一摸一样的，只是在进行一些特权或者 I/O 操作时，需要直接跟硬件（包括 CPU 和外设）打交道，而不能让操作系统代劳（一般的程序是通过调用标准库，标准库再向操作系统发起 <em>系统调用</em> 等一系列过程实现）。</p>
<p>幸好跟硬件打交道都不算太复杂，有些硬件在电路里被映射到某段内存地址，比如串口控制台，你只需把它们当作内存来读写，再稍微经过位运算等处理，即可获取这些硬件的状态数据或者更改它们的状态；有些硬件有专门的 CPU 指令来操作，裸机程序只需编写相应的汇编代码即可。</p>
<p>下面是一个 &ldquo;裸机&rdquo; 版的 &ldquo;Hello world!&rdquo; 程序，该程序实现 3 个功能：</p>
<ol>
<li>向串口控制台打印一行 &ldquo;Hello world!&rdquo; 文本；</li>
<li>计算两个整数的和并显示其结果；</li>
<li>计算一个整数加上 10 之后的值，并显示其结果。</li>
</ol>
<p>该程序的源文件数量比较多，涉及的新鲜概念也比较多，在这篇文章里暂时不会作细致的分析，如果对其中的细节或者原理有疑惑，可以暂时忽略。后续的文章会有详细的讲解，你可以在阅读完后续的文章之后再回来看该程序的内容。</p>
<p>这个章节仅为了简单介绍用 GCC 编译裸机程序的过程。</p>
<h3 id="程序的组成">程序的组成</h3>
<p>程序由下列几个部分组成：</p>
<ul>
<li>基础库 <code>put_char.S</code> 和 <code>libprint.c</code></li>
<li>计算库 <code>liba.c</code> 和 <code>libb.c</code></li>
<li>主程序 <code>app.c</code></li>
<li>启动器 <code>app_startup.S</code></li>
</ul>
<h4 id="基础库">基础库</h4>
<p>因为没有操作系统的支持，显然无法直接使用 <code>printf</code> 函数，但我们可以编写一个功能相近的简单函数。</p>
<p>具体来说，该应用程序准备在虚拟机 RISC-V QEMU 中运行，通过查看 <a href="https://github.com/qemu/qemu/blob/master/hw/riscv/virt.c">QEMU RISC-V virt 的源代码</a> 可以找到一些基本硬件的内存映射关系：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">const</span> MemMapEntry virt_memmap[] <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    [VIRT_MROM] <span style="color:#f92672">=</span>         {     <span style="color:#ae81ff">0x1000</span>,        <span style="color:#ae81ff">0xf000</span> },
</span></span><span style="display:flex;"><span>    [VIRT_UART0] <span style="color:#f92672">=</span>        { <span style="color:#ae81ff">0x10000000</span>,         <span style="color:#ae81ff">0x100</span> },
</span></span><span style="display:flex;"><span>    [VIRT_FLASH] <span style="color:#f92672">=</span>        { <span style="color:#ae81ff">0x20000000</span>,     <span style="color:#ae81ff">0x4000000</span> },
</span></span><span style="display:flex;"><span>    [VIRT_DRAM] <span style="color:#f92672">=</span>         { <span style="color:#ae81ff">0x80000000</span>,           <span style="color:#ae81ff">0x0</span> },
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>其中串口通信 UART 被映射到 <code>0x1000_0000</code>，这表明只需向该内存地址写入一个 byte 类型整数，该整数对应的 ASCII 字符就会被重定向到虚拟终端。</p>
<blockquote>
<p>并非所有的硬件读写都是这种方式，后续的文章会详细讲解如何用汇编写驱动，比如 GPIO，I2C 等控制。</p>
</blockquote>
<p>所以要实现打印单个字符的函数是很简单的，在目录 <a href="./resources/bare-metal/">resources/bare-metal</a> 里有源代码文件 <code>put_char.S</code>，其内容如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-S" data-lang="S"><span style="display:flex;"><span>.equ VIRT_UART0, <span style="color:#ae81ff">0x10000000</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>.section .text.put_char
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>.globl put_char
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>put_char<span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    li s1, VIRT_UART0
</span></span><span style="display:flex;"><span>    mv s2, a0
</span></span><span style="display:flex;"><span>    sb s2, <span style="color:#ae81ff">0</span>(s1)
</span></span><span style="display:flex;"><span>    ret
</span></span></code></pre></div><blockquote>
<p>因为这段程序在虚拟机上运行，所以这里忽略了 UART 发送所需的延迟。如果是在真实硬件上编写发送字符的程序，应该检查 UART TX FIFO 的值，仅当上一个字符发送完毕之后（即 TX 空闲之后）再发送下一个字符，毕竟 CPU 的工作频率比 UART 的高很多。</p>
</blockquote>
<p>打印字符函数也可以用 C 语言实现，源代码文件是 <code>put_char.c</code>，其内容如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#define VIRT_UART0 0x10000000
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">volatile</span> <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">const</span> VIRT_UART0_PTR <span style="color:#f92672">=</span> (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>)VIRT_UART0;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">put_char</span>(<span style="color:#66d9ef">int</span> c)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>VIRT_UART0_PTR <span style="color:#f92672">=</span> c;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>因为这段 C 代码所表达的意思不够汇编的那么明确，所以选用了汇编版本。</p>
<p>在此基础之上，可以用 C 语言实现 <code>print_char</code>，<code>print_string</code> 和 <code>print_int</code> 等函数，以方便后续的调用。源代码文件为 <code>libprint.c</code>，其内容如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;put_char.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">print_char</span>(<span style="color:#66d9ef">char</span> c)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    put_char((<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span>)c);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">print_string</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>str)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (<span style="color:#f92672">*</span>str <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#39;\0&#39;</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        print_char(<span style="color:#f92672">*</span>str);
</span></span><span style="display:flex;"><span>        str<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">print_int</span>(<span style="color:#66d9ef">int</span> i)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> s[<span style="color:#ae81ff">21</span>];
</span></span><span style="display:flex;"><span>    itoa(i, s, <span style="color:#ae81ff">21</span>);
</span></span><span style="display:flex;"><span>    print_string(s);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>至此，应用程序已经有打印字符、字符串和数字的能力了。</p>
<h4 id="计算库">计算库</h4>
<p>接下来实现整数相加等数学函数，源代码文件分别为 <code>liba.c</code> 和 <code>libb.c</code>，其内容如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// liba.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">add</span>(<span style="color:#66d9ef">int</span> a, <span style="color:#66d9ef">int</span> b)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> a <span style="color:#f92672">+</span> b;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// libb.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;liba.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">add10</span>(<span style="color:#66d9ef">int</span> i)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> add(i, <span style="color:#ae81ff">10</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p>之所以把函数划分到两个文件，是因为接下来的章节会讲述 <em>打包目标文件</em> 的功能，即把 <code>liba.o</code> 和 <code>libb.o</code> 打包为 <code>libmath.a</code></p>
</blockquote>
<h4 id="主程序">主程序</h4>
<p>然后再看看主程序，源代码文件 <code>app.c</code>，其内容如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;libmath.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;libprint.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">bare_main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> b <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> m <span style="color:#f92672">=</span> add(a, b);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> add10(a);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    print_string(<span style="color:#e6db74">&#34;Hello world!</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    print_int(m);
</span></span><span style="display:flex;"><span>    print_char(<span style="color:#e6db74">&#39;\n&#39;</span>);
</span></span><span style="display:flex;"><span>    print_int(n);
</span></span><span style="display:flex;"><span>    print_char(<span style="color:#e6db74">&#39;\n&#39;</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>因为这个是 &ldquo;裸机&rdquo; 程序，为了跟标准程序区分，这里把主函数 <code>main</code> 命名为 <code>bare_main</code>（随意的名称）。</p>
<h4 id="启动器">启动器</h4>
<p>由上一节知道，可执行文件的入口（即最先开始执行的指令）是由编译器自动生成的 <code>_start</code> 过程，经过一系列初始化之后才调用函数 <code>main</code>。但这些事情仅在编译为标准 Linux 程序时才会发生，现在编译裸机程序，编译器是不会自作主张地添加这些过程的，所以还得写一个 &ldquo;程序的启动程序&rdquo;，源代码文件为 <code>app_startup.S</code>，其内容如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-S" data-lang="S"><span style="display:flex;"><span>.section .text.entry
</span></span><span style="display:flex;"><span>.globl _start
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>_start<span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    la sp, stack_top
</span></span><span style="display:flex;"><span>    call bare_main
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>_loop<span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    nop
</span></span><span style="display:flex;"><span>    j _loop
</span></span></code></pre></div><p>上面的程序的功能很简单：</p>
<ol>
<li>因为程序有嵌套的函数调用，所以需要用到 <em>栈</em>。通过向 &ldquo;stack pointer&rdquo; 寄存器写入一个地址即可设置栈底（高地址），这样一来 <em>栈</em> 就搭建好了。（代码中的 <code>stack_top</code> 是链接脚本 <code>app.lds</code> 导出的符号）</li>
<li>调用主程序的主函数 <code>bare_main</code>。</li>
</ol>
<h3 id="编译-1">编译</h3>
<p>编译各个源文件，但暂时不需要链接：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ riscv64-elf-as -o app_startup.o app_startup.S
</span></span><span style="display:flex;"><span>$ riscv64-elf-gcc -I . -Wall -fPIC -c -o app.o app.c
</span></span><span style="display:flex;"><span>$ riscv64-elf-gcc -I . -Wall -fPIC -c -o liba.o liba.c
</span></span><span style="display:flex;"><span>$ riscv64-elf-gcc -I . -Wall -fPIC -c -o libb.o libb.c
</span></span><span style="display:flex;"><span>$ riscv64-elf-gcc -I . -Wall -fPIC -c -o libprint.o libprint.c
</span></span><span style="display:flex;"><span>$ riscv64-elf-as -o put_char.o put_char.S
</span></span></code></pre></div><p>现在看第二条命令，即编译 <code>app.c</code> 的那条命令，你可能会感到疑惑，在 <code>app.c</code> 里既调用了函数 <code>add</code>、<code>add10</code>，还调用了 <code>print_*</code>，但这些函数都还没编译，而且在 <code>app.c</code> 里也找不到任何跟 <code>liba.c</code> 和 <code>libb.c</code> 联系的代码，那么为什么还能成功编译呢？</p>
<p>这正是 GCC 编译的工作原理，在编译一个源文件时，如果代码里有调用外部函数，编译器实际上不管这个外部函数是否存在（是否已经编译），也不管它在哪里，你只需提供这个函数的签名即可（函数签名位于 <code>libmath.h</code> 和 <code>libprint.h</code>），这也是为什么各个源文件可以各自单独编译，甚至多个源文件可以并行编译的原因（想一想平时输入的类似 <code>$ make -j $(nproc)</code> 这样的命令，它表示有多条进程并行编译哦）。</p>
<h3 id="打包目标文件">打包目标文件</h3>
<p>可以打包多个 <em>目标文件</em> 以形成一个 <em>库</em> 文件，这样可以方便以后使用。</p>
<p>下面的命令将 <code>liba.o</code> 和 <code>libb.o</code> 打包为 <code>libmath.a</code>：</p>
<p><code>$ riscv64-elf-ar rs libmath.a liba.o libb.o</code></p>
<p><code>ar</code> 命令后面跟着 <em>一个操作码</em> 以及 <em>零或多个修饰符</em>：</p>
<ul>
<li>操作码 <code>r</code> 表示插入新的源目标文件，或者替换静态库中已存在的源目标文件。</li>
<li>修饰符 <code>s</code> 表示为静态库创建索引，相当于创建完静态库之后执行了一次 <code>$ riscv64-elf-ranlib libmath.a</code> 命令。</li>
</ul>
<p>命令运行之后将得到包文件 <code>libmath.a</code>（一般称为 <em>静态库</em>）。程序 <code>riscv64-elf-ar</code> 除了可以创建包文件，还可以查看或者修改包文件，比如下面的命令用于查看包文件里含有哪些目标文件：</p>
<p><code>$ riscv64-elf-ar t libmath.a</code></p>
<p>输出结果如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>liba.o
</span></span><span style="display:flex;"><span>libb.o
</span></span></code></pre></div><p>包文件也能够使用 <code>riscv64-elf-nm</code> 程序列出符号列表：</p>
<p><code>$ riscv64-elf-nm libmath.a</code></p>
<p>输出结果如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>liba.o:
</span></span><span style="display:flex;"><span>0000000000000000 T add
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>libb.o:
</span></span><span style="display:flex;"><span>                 U add
</span></span><span style="display:flex;"><span>0000000000000000 T add10
</span></span></code></pre></div><p>当然也能用 <code>riscv64-elf-objdump</code> 反汇编包文件：</p>
<p><code>$ riscv64-elf-objdump -d libmath.a</code></p>
<p>输出（部分）结果如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>In archive libmath.a:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>liba.o:     file format elf64-littleriscv
</span></span><span style="display:flex;"><span>Disassembly of section .text:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>0000000000000000 &lt;add&gt;:
</span></span><span style="display:flex;"><span>   0:   1101                    addi    sp,sp,-32
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>  26:   6105                    addi    sp,sp,32
</span></span><span style="display:flex;"><span>  28:   8082                    ret
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>libb.o:     file format elf64-littleriscv
</span></span><span style="display:flex;"><span>Disassembly of section .text:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>0000000000000000 &lt;add10&gt;:
</span></span><span style="display:flex;"><span>   0:   1101                    addi    sp,sp,-32
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>  26:   6105                    addi    sp,sp,32
</span></span><span style="display:flex;"><span>  28:   8082                    ret
</span></span></code></pre></div><p>通过反汇编会发现，包文件（即静态库）仅仅是把原先的多个目标文件 <strong>原样</strong> 合并起来，其中的内容均未改变。这跟链接程序把多个目标文件链接起来的情况不同，链接程序会修改部分内容（主要是会解决各个符号的地址，本项目的其它文章会讲解）。</p>
<h3 id="链接">链接</h3>
<p>由于当前这个程序是一个裸机程序，而且 QEMU RISC-V 对程序的入口地址有要求，所以不能使用默认的链接脚本来链接目标文件，目录 <a href="./resources/bare-metal/">resources/bare-metal</a> 里有链接脚本 <code>app.lds</code>，其内容如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>OUTPUT_ARCH(riscv)
</span></span><span style="display:flex;"><span>ENTRY(_start)
</span></span><span style="display:flex;"><span>BASE_ADDRESS = 0x80000000;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>SECTIONS
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  . = BASE_ADDRESS;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  .text : {
</span></span><span style="display:flex;"><span>    *(.text.entry)
</span></span><span style="display:flex;"><span>    *(.text .text.*)
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  .rodata : {
</span></span><span style="display:flex;"><span>    *(.rodata .rodata.*)
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  . = ALIGN(4096);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  .data : {
</span></span><span style="display:flex;"><span>    *(.sdata .sdata.*)
</span></span><span style="display:flex;"><span>    *(.data .data.*)
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  .bss :{
</span></span><span style="display:flex;"><span>    *(.sbss .sbss.*)
</span></span><span style="display:flex;"><span>    *(.bss .bss.*)
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  . = ALIGN(8);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  /* a 4KB stack */
</span></span><span style="display:flex;"><span>  stack_bottom = .;
</span></span><span style="display:flex;"><span>  . += 4096;
</span></span><span style="display:flex;"><span>  stack_top = .;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>有关链接脚本的具体内容可以参阅 <a href="https://sourceware.org/binutils/docs/ld/Scripts.html">Linker Scripts</a> 或者 <a href="https://blog.csdn.net/m0_47799526/article/details/108765403">中文翻译版</a> 。</p>
<p>下面将 <code>app_startup.o</code>，<code>app.o</code>，<code>libmath.a</code>，<code>libprint.o</code> 和 <code>put_char.o</code> 链接起来：</p>
<p><code>$ riscv64-elf-ld -T app.lds -o app.out app_startup.o app.o libmath.a libprint.o put_char.o</code></p>
<ul>
<li>参数 <code>-T app.lds</code> 表示使用指定的链接脚本 <code>app.lds</code>。</li>
<li>参数 <code>-o app.out</code> 指示输出的文件名。</li>
<li>参数 <code>app_startup.o app.o libmath.a libprint.o put_char.o</code> 表示待链接的文件列表（友情提示：文件列表尽量按照这样的顺序列出：被依赖的文件排在后面。有时编译器会因为顺序问题而出现莫名其妙的错误）。</li>
</ul>
<p>链接命令中的参数 <code>libmath.a</code> 是静态库文件，可见其实静态库文件可以简化链接命令（假设静态库是由非常多的目标文件组成的话）。</p>
<p>命令运行之后得到 ELF 格式的可执行文件 <code>app.out</code>。</p>
<h3 id="运行-1">运行</h3>
<p>下面使用 QEMU 的 <em>系统模式</em> 运行该文件：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ qemu-system-riscv64 <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    -machine virt <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    -nographic <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    -bios none <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    -kernel app.out
</span></span></code></pre></div><p>如无意外，应该能看到正确的输出结果：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>Hello world!
</span></span><span style="display:flex;"><span>8
</span></span><span style="display:flex;"><span>13
</span></span></code></pre></div><p>按 <code>Ctrl+a</code>，再按 <code>x</code> 结束 QEMU 模拟程序。</p>
<p>下一篇文章 <a href="../build-risc-v-program-from-assembly-code/README.zh-Hans.md">通过汇编代码构建 RISC-V 程序</a> 我们将会讲解 RISC-V 程序的组成和运行原理。</p>


</article>


<section class="post-nav">
    <ul>
        <li>
        
            <a href="https://hemashushu.github.io/posts/2022-11-07-build-minimal-risc-v-program/readme/"><i class="fa fa-chevron-circle-left"></i> </a>
        
        </li>
        <li>
        
            <a href="https://hemashushu.github.io/posts/2022-11-06-risc-v-gcc-quick-start/readme/"> <i class="fa fa-chevron-circle-right"></i> </a>
        
        </li>
    </ul>
</section>
  
    
    
  





</main>
    <footer>
        <ul>
            <li>
                <h6>Copyright © 2022 - Hippospark | 
                    <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh"><img alt="cc by-nc-nd" class="license" src="/images/cc-by-nc-nd.png" /></a> |
                    Rendered by <a href="https://gohugo.io" title="Hugo">Hugo</a> |
                    Theme <a href="https://github.com/funkydan2/hugo-kiera" title="Kiera">Kiera</a> |
                    <a href="https://hemashushu.github.io/index.xml">Subscribe </a></h6>
            </li>
            
            
        </ul>
        
    </footer>
</div>
<script src="/js/scripts.js"></script>


</body>

</html>

