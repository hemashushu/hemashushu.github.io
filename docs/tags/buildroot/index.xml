
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
 <channel>
   <title>buildroot on Hemashushu&#39;s Homepage</title>
   <link>https://hemashushu.github.io/tags/buildroot/</link>
   <description>Recent content in buildroot on Hemashushu&#39;s Homepage</description>
   <generator>Hugo -- gohugo.io</generator>
   <language>en</language>
   <copyright>Copyright &amp;copy; 2023 - Hippospark Young</copyright>
   <lastBuildDate>Sun, 08 Jan 2023 00:00:00 +0000</lastBuildDate>
   
       <atom:link href="https://hemashushu.github.io/tags/buildroot/index.xml" rel="self" type="application/rss+xml" />
   
   
     <item>
       <title>S10C02 RISC-V development using QEMU - Part 2 Build a base Linux system using Buildroot</title>
       <link>https://hemashushu.github.io/posts/2023-01-08-s10c02-risc-v-development-using-qemu-part-2-buildroot/</link>
       <pubDate>Sun, 08 Jan 2023 00:00:00 +0000</pubDate>
       
       <guid>https://hemashushu.github.io/posts/2023-01-08-s10c02-risc-v-development-using-qemu-part-2-buildroot/</guid>
       <description>&lt;p&gt;This series articles will guide you setting up a RISC-V development environment using QEMU. The series includes four parts:&lt;/p&gt;&lt;p&gt;&lt;a href=&#34;../2023-01-06-s10c01-risc-v-development-using-qemu-part-1-minimal-linux/&#34;&gt;Part 1&lt;/a&gt;. Building a minimal RISC-V Linux system with only Linux kernel and BusyBox, and runs on the QEMU emulator.&lt;/p&gt;&lt;p&gt;&lt;a href=&#34;../2023-01-08-s10c01-risc-v-development-using-qemu-part-2-buildroot&#34;&gt;Part 2&lt;/a&gt;. Building a base RISC-V Linux system with the ability of doing RISC-V assembly development and debug using Buildroot.&lt;/p&gt;&lt;p&gt;Part 3. Setting up a complete Debian RISC-V Linux system in QEMU, and do C language development and debug with GCC toolchains.&lt;/p&gt;&lt;p&gt;Part 4. Remote debugging with the GDB, and setup remote text editing and debugging by VSCode.&lt;/p&gt;&lt;hr&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&#34;#1-get-the-_buildroot_-source-code&#34;&gt;1. Get the &lt;em&gt;Buildroot&lt;/em&gt; source code&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#2-configure-_buildroot_&#34;&gt;2. Configure &lt;em&gt;Buildroot&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#3-select-packages&#34;&gt;3. Select packages&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#4-compile-_buildroot_&#34;&gt;4. Compile &lt;em&gt;Buildroot&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#5-boot-the-system&#34;&gt;5. Boot the system&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#6-check-the-system&#34;&gt;6. Check the system&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#7-create-a-non-privileged-user&#34;&gt;7. Create a non-privileged user&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#8-log-in-to-the-guest-machine-via-ssh&#34;&gt;8. Log in to the guest machine via SSH&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#9-risc-v-assembly-development&#34;&gt;9. RISC-V Assembly development&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#10-debug-program-by-gdb&#34;&gt;10. Debug program by GDB&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#11-where-is-the-gcc-toolchain&#34;&gt;11. Where is the GCC toolchain?&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#12-conclusion&#34;&gt;12. Conclusion&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;!-- raw HTML omitted --&gt;&lt;p&gt;In the previous section, we built a minimal Linux system by compiling the &lt;em&gt;Linux kernel&lt;/em&gt; and &lt;em&gt;BusyBox&lt;/em&gt;. While the system contains a base Shell environment and is capable of running static linked user programs, it is not suitable for development purposes. In theory, we could add any software, such as &lt;code&gt;ssh&lt;/code&gt;, &lt;code&gt;vim&lt;/code&gt;, &lt;code&gt;git&lt;/code&gt; or &lt;code&gt;binutils&lt;/code&gt; and so on by compiling their source codes and copying the binaries and libraries into the image file. Actually, there is a project called &lt;a href=&#34;https://www.linuxfromscratch.org/lfs/&#34;&gt;Linux From Scratch&lt;/a&gt; that guides users through building the entire Linux system from source code. Although it&amp;rsquo;s an excellent tutorial for those who want to understand how Linux system are built, it can be challenging for beginners, and the process would be tedious and time consuming.&lt;/p&gt;&lt;p&gt;In this chapter, we will use a tool called &lt;a href=&#34;https://buildroot.org/&#34;&gt;Buildroot&lt;/a&gt; to download and compile software automatically, resulting in the creation of an image file. &lt;code&gt;Buildroot&lt;/code&gt; is free and open-source, so you can check its source code if you want to know how it works.&lt;/p&gt;&lt;h2 id=&#34;1-get-the-_buildroot_-source-code&#34;&gt;1. Get the &lt;em&gt;Buildroot&lt;/em&gt; source code&lt;/h2&gt;&lt;p&gt;To get started, create a project folder in your home directory, let&amp;rsquo;s call &lt;code&gt;riscv64-buildroot&lt;/code&gt;. Once created, change into the folder and clone the &lt;a href=&#34;https://git.buildroot.net/buildroot&#34;&gt;Buildroot source code repository&lt;/a&gt; via &lt;em&gt;Git&lt;/em&gt;. After the download is complete, change into the &lt;code&gt;buildroot&lt;/code&gt; directory and check out a stable version, e.g., &lt;code&gt;2023.02&lt;/code&gt;:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ mkdir ~/riscv64-buildroot&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ cd ~/riscv64-buildroot&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ git clone https://git.buildroot.net/buildroot&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ cd buildroot&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ git checkout -b 2023.02&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;2-configure-_buildroot_&#34;&gt;2. Configure &lt;em&gt;Buildroot&lt;/em&gt;&lt;/h2&gt;&lt;p&gt;&lt;em&gt;Buildroot&lt;/em&gt; is capable of building Linux systems for various hardware platforms. You can check the &lt;code&gt;board&lt;/code&gt; directory to see a list of all platform vendors and modules. Each platform has one or more corresponding default configurations located in the &lt;code&gt;configs&lt;/code&gt; directory. Run the following command to configure a QEMU RISC-V target platform with default settings:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ make qemu_riscv64_virt_defconfig&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;You can customize the target system by changing the image file capacity, adding packages, and more by execute the &lt;code&gt;make menuconfig&lt;/code&gt; command:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ make menuconfig&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Check the following options:&lt;/p&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-conf&#34; data-lang=&#34;conf&#34;&gt;Toolchain ---&amp;gt;    * Install glibc utilities    * Enable C++ supportBuild options ---&amp;gt;    * Enable compiler cacheFilesystem images ---&amp;gt;    * ext2/3/4        * ext4    exact size        * 2048M&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Where the &lt;code&gt;image size&lt;/code&gt; option requires manual input.&lt;/p&gt;&lt;p&gt;There are several selection markers in the &lt;em&gt;menuconfig&lt;/em&gt;, and their meanings as follow:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;[*]&lt;/code&gt;: Build into the kernel.&lt;/li&gt;&lt;li&gt;&lt;code&gt;[ ]&lt;/code&gt;: Do not build.&lt;/li&gt;&lt;li&gt;&lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt;: Build into the kernel.&lt;/li&gt;&lt;li&gt;&lt;code&gt;&amp;lt; &amp;gt;&lt;/code&gt;: Do not build.&lt;/li&gt;&lt;li&gt;&lt;code&gt;&amp;lt;M&amp;gt;&lt;/code&gt;: Build as external module, this means that the result of the build of this item will not be included in the kernel, but in a separate file.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;We won&amp;rsquo;t be using external modules in this section, so avoid using the marker &lt;code&gt;&amp;lt;M&amp;gt;&lt;/code&gt;.&lt;/p&gt;&lt;h2 id=&#34;3-select-packages&#34;&gt;3. Select packages&lt;/h2&gt;&lt;p&gt;Next, select the packages you need. Note that the option &amp;ldquo;Show packages that are also provided by busybox&amp;rdquo; must be selected first, otherwise some options will be unavailable. You can press the &lt;code&gt;/&lt;/code&gt; key at any time to search for packages by name. The following is a list of recommended packages for building a RISC-V assembly development environment.&lt;/p&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-conf&#34; data-lang=&#34;conf&#34;&gt;Target packages ---&amp;gt;    * Show packages that are also provided by busybox    Compressors and decompressors ---&amp;gt;        * bzip2        * gzip        * unzip        * xz-utils        * zip        * zstd    Debugging, profiling and benchmark ---&amp;gt;        * gdb            * gdbserver            * full debugger            * TUI support    Development tools ---&amp;gt;        * binutils            * binutils binaries        * check        * diffutils        * findutils        * flex        * gawk        * gettext        * git        * grep        * libtool        * make        * patch        * pkgconf        * sed        * tree    Hardware handling ---&amp;gt;        * kbd    Interpreter languages and scripting ---&amp;gt;        * python3            python3 module format to install ---&amp;gt;                * .py sources and .pyc compiled            External python modules                * python-pip    Libraries ---&amp;gt;        Crypto ---&amp;gt;            * CA Certificates            openssl support                ssl library ---&amp;gt;                    * openssl                openssl                    * openssl binary    Networking applications ---&amp;gt;        iputils            * ping        * openssh        * wget    Shell and utilities ---&amp;gt;        * bash        * bash completion        * file        * sudo        * time        * which    System tools        * coreutils            * Individual binaries        * htop        * shadow        * tar    Text editors and viewers ---&amp;gt;        * less        * vim        * install runtime&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Check out the &lt;a href=&#34;https://www.linuxfromscratch.org/lfs/view/stable/&#34;&gt;Linux From Scratch Book&lt;/a&gt; for a detailed explanation of each package. Once you have selected your packages, select &amp;ldquo;Save&amp;rdquo; and &amp;ldquo;Exit&amp;rdquo; to exit the configuration interface.&lt;/p&gt;&lt;h2 id=&#34;4-compile-_buildroot_&#34;&gt;4. Compile &lt;em&gt;Buildroot&lt;/em&gt;&lt;/h2&gt;&lt;p&gt;Run the &lt;code&gt;make&lt;/code&gt; command to start the package download and compilation process.&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ make -j &lt;span style=&#34;color:#66d9ef&#34;&gt;$(&lt;/span&gt;nproc&lt;span style=&#34;color:#66d9ef&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;&lt;p&gt;The &lt;code&gt;$(nproc)&lt;/code&gt; is a &lt;em&gt;command substitution&lt;/em&gt; that is replaced by the output of the &lt;code&gt;nproc&lt;/code&gt; command. The &lt;code&gt;nproc&lt;/code&gt; command is used to display the number of CPU cores. So the above command will become &lt;code&gt;make -j 6&lt;/code&gt; assuming there are 6 cores in your CPU. This will make the compilation process much faster since the code will be compiled with multiple threads.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;Depending on the performance of your machine, you may have time for a cup of tea or perhaps another biscuit while the download and compilation are completed. Afterward, the resulting files will be located in the &lt;code&gt;output/images&lt;/code&gt; directory. Checking with the &lt;code&gt;ls&lt;/code&gt; command:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ ls -lh output/images&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The output will resemble the following:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;total 252M&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-rw-r--r-- 1 yang yang 119K Mar  4 02:58 fw_dynamic.bin&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-rw-r--r-- 1 yang yang 1.1M Mar  4 02:58 fw_dynamic.elf&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-rw-r--r-- 1 yang yang 119K Mar  4 02:58 fw_jump.bin&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-rw-r--r-- 1 yang yang 1.1M Mar  4 02:58 fw_jump.elf&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-rw-r--r-- 1 yang yang  19M Mar  4 02:59 Image&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-rw-r--r-- 1 yang yang 2.0G Mar  4 03:01 rootfs.ext2&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;lrwxrwxrwx 1 yang yang   11 Mar  4 02:59 rootfs.ext4 -&amp;gt; rootfs.ext2&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-rw-r--r-- 1 yang yang  86M Mar  4 02:59 rootfs.tar&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-rwxr-xr-x 1 yang yang  499 Mar  4 02:59 start-qemu.sh&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;5-boot-the-system&#34;&gt;5. Boot the system&lt;/h2&gt;&lt;p&gt;To boot the target system, use the following command:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;qemu-system-riscv64 &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;    -machine virt &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;    -m 1G &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;    -bios ./buildroot/output/images/fw_jump.elf &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;    -kernel ./buildroot/output/images/Image &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;    -append &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;rootwait root=/dev/vda ro&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;    -drive file&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;./buildroot/output/images/rootfs.ext2,format&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;raw,id&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;hd0 &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;    -device virtio-blk-device,drive&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;hd0 &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;    -netdev user,id&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;net0,hostfwd&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;tcp::10022-:22 &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;    -device virtio-net-device,netdev&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;net0 &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;    -nographic&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Compare to the previous chapter, there are three new QEMU parameters:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;-bios ./buildroot/output/images/fw_jump.elf&lt;/code&gt;: This specifies the BIOS firmware. The &lt;code&gt;fw_jump.elf&lt;/code&gt; is actually the OpenSBI, which is generated by &lt;em&gt;Buildroot&lt;/em&gt;. Note that when omitting the &lt;code&gt;-bios&lt;/code&gt; parameter, the QEMU builtin one will be loaded. In this case, we should use the &lt;em&gt;Buildroot&lt;/em&gt; version.&lt;/li&gt;&lt;li&gt;&lt;code&gt;-netdev user,id=net0,hostfwd=tcp::10022-:22&lt;/code&gt; and &lt;code&gt;-device virtio-net-device,netdev=net0&lt;/code&gt;: These parameters are used to assign a virtual network interface to the virtual machine, and &lt;code&gt;hostfwd=tcp::10022-:22&lt;/code&gt; means redirect TCP port 10022 from host to port 22 of the virtual machine.&lt;/li&gt;&lt;/ul&gt;&lt;blockquote&gt;&lt;p&gt;The &lt;em&gt;virtual machine&lt;/em&gt; created by QEMU is also called the &lt;em&gt;guest machine&lt;/em&gt;, the name it is related to the &lt;em&gt;host machine&lt;/em&gt;, which is the machine running QEMU.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;Once the command is executed, many message will be shown, generated by &lt;em&gt;OpenSBI&lt;/em&gt;, kernel and the &lt;code&gt;init&lt;/code&gt; process. You can safely ignore them if there is no error message.&lt;/p&gt;&lt;p&gt;The message will be ended with two lines: &lt;code&gt;Welcome to Buildroot&lt;/code&gt; and &lt;code&gt;buildroot login&lt;/code&gt;, enter the user name &lt;code&gt;root&lt;/code&gt; without password to log in.&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;buildroot login: root&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;6-check-the-system&#34;&gt;6. Check the system&lt;/h2&gt;&lt;p&gt;You can do a quick check to validate whether the cpu module, memory size, kernel version and storage space match what you configured:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# uname -a&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Linux buildroot 5.15.43 &lt;span style=&#34;color:#75715e&#34;&gt;#1 SMP Tue Mar 4 07:31:21 CST 2023 riscv64 GNU/Linux&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# free -h&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;              total        used        free      shared  buff/cache   available&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Mem:         988.5M       19.4M      961.0M       48.0K        8.0M      959.1M&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Swap:             &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;           &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;           &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# df -h&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Filesystem      Size  Used Avail Use% Mounted on&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;/dev/root       2.0G  151M  1.7G   9% /&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;devtmpfs        494M     &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;  494M   0% /dev&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;tmpfs           495M     &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;  495M   0% /dev/shm&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;tmpfs           495M   24K  495M   1% /tmp&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;tmpfs           495M   24K  495M   1% /run&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# cat /proc/cpuinfo&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;processor       : &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;hart            : &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;isa             : rv64imafdch_zicsr_zifencei_zihintpause_zba_zbb_zbc_zbs_sstc&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;mmu             : sv48&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;./images/buildroot.png&#34; alt=&#34;Buildroot&#34;&gt;&lt;/p&gt;&lt;p&gt;Next, check the installed packages:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# python --version&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Python 3.11.2&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# git --version&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git version 2.40.0&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# wget --version | head -n 1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;GNU Wget 1.21.3 built on linux-gnu.&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# vim --version | head -n 1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;VIM - Vi IMproved 9.0 &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2022&lt;/span&gt; Jun 28, compiled Mar &lt;span style=&#34;color:#ae81ff&#34;&gt;12&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2023&lt;/span&gt; 17:15:56&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Note the output text may be slighty different from your guest machine.&lt;/p&gt;&lt;h2 id=&#34;7-create-a-non-privileged-user&#34;&gt;7. Create a non-privileged user&lt;/h2&gt;&lt;p&gt;It&amp;rsquo;s easy to make mistakes when operating with the root user, so it&amp;rsquo;s good practice to creat a non-privileged user after system is installed, and switch to it as soon as possible.&lt;/p&gt;&lt;p&gt;To begin, create a user named &lt;code&gt;yang&lt;/code&gt; (or the username you usually use) and set its password:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ useradd -m -s /bin/bash yang&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ passwd yang&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Next, add the user to the &lt;code&gt;sudo&lt;/code&gt; group, which makes it possible to promote privileges when needed.&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ usermod -a -G sudo yang&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;&lt;p&gt;Make sure the &lt;code&gt;shadow&lt;/code&gt; package is selected in &lt;em&gt;Buildroot&lt;/em&gt; package selecting step, as the &lt;code&gt;useradd&lt;/code&gt; and &lt;code&gt;usermod&lt;/code&gt; commands are provided by this package.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;Switch to the newly created user and check its privileges.&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ su - yang&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ id&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;uid&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;1000&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;yang&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; gid&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;1000&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;yang&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; groups&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;1000&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;yang&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;,102&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;sudo&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The above text &lt;code&gt;102(sudo)&lt;/code&gt; indicates this account has been successfully added to the &lt;code&gt;sudo&lt;/code&gt; group. Try running the following command:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ sudo cat /etc/sudoers&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;It should not produce any errors.&lt;/p&gt;&lt;p&gt;Create a file &lt;code&gt;.bash_profile&lt;/code&gt; in the home directory and add the following text to it to improve your experience:&lt;/p&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-conf&#34; data-lang=&#34;conf&#34;&gt;alias ls=&amp;#39;ls --color=auto&amp;#39;PS1=&amp;#39;[\u@\h \W]\$ &amp;#39;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Run the command &lt;code&gt;$ source ~/.bash_profile&lt;/code&gt; to make it take effect. Your custom base Linux system is now fully set up.&lt;/p&gt;&lt;h2 id=&#34;8-log-in-to-the-guest-machine-via-ssh&#34;&gt;8. Log in to the guest machine via SSH&lt;/h2&gt;&lt;p&gt;Since there may be some minor text rendering defects in the QEMU terminal, it&amp;rsquo;s better to access the guest machine via SSH. Make sure that the &lt;code&gt;openssh&lt;/code&gt; package is selected in the &lt;em&gt;Buildroot&lt;/em&gt; package selecting step, the SSH daemon (a background process) will start automatically. Open another Terminal window and run the following command:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ ssh -p &lt;span style=&#34;color:#ae81ff&#34;&gt;10022&lt;/span&gt; yang@localhost&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;9-risc-v-assembly-development&#34;&gt;9. RISC-V Assembly development&lt;/h2&gt;&lt;p&gt;The GNU Assembler and Linker are included in the &lt;code&gt;binutils&lt;/code&gt; package. You can write some assembly code and assemble it into an executable program file to run it in the guest machine.&lt;/p&gt;&lt;p&gt;To do this, create a file named &lt;code&gt;hello.S&lt;/code&gt; in the home directory, and add the following text:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-S&#34; data-lang=&#34;S&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    .text&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    .global _start&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;_start&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# calling convention&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# a0-a2                     - parameters to Linux function&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# a7                        - Linux function number&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# call `write(int fd, char* s, int len)`&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    li      a0, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;               &lt;span style=&#34;color:#75715e&#34;&gt;# file descriptor, 1 = stdout&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    la      a1, s               &lt;span style=&#34;color:#75715e&#34;&gt;# the address/pointer to `s` string&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                                &lt;span style=&#34;color:#75715e&#34;&gt;# `la a1, s` is equivalent to&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                                &lt;span style=&#34;color:#75715e&#34;&gt;# `lui a1, %hi(s)` and `addi a1, a1, %lo(s)`&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    li      a2, &lt;span style=&#34;color:#ae81ff&#34;&gt;13&lt;/span&gt;              &lt;span style=&#34;color:#75715e&#34;&gt;# the length of string `s`&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    li      a7, &lt;span style=&#34;color:#ae81ff&#34;&gt;64&lt;/span&gt;              &lt;span style=&#34;color:#75715e&#34;&gt;# the number of syscall `write`&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ecall&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# call `exit(int)`&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    addi    a0, x0, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;           &lt;span style=&#34;color:#75715e&#34;&gt;# return code must be from 0 to 255&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    addi    a7, x0, &lt;span style=&#34;color:#ae81ff&#34;&gt;93&lt;/span&gt;          &lt;span style=&#34;color:#75715e&#34;&gt;# the number of syscall `exit`&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ecall&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    .section .rodata&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;s&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    .asciz  &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Hello World!\n&amp;#34;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;&lt;p&gt;If you are interested in the RISC-V assembly language, check out another series of my articles: &lt;a href=&#34;../&#34;&gt;Gentle RISC-V Assembly Language Tutorial&lt;/a&gt;.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;Next, assemble and link the file:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ as -g -o hello.o hello.S&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ ld -o hello.elf hello.o&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This will generate a file named &lt;code&gt;hello.elf&lt;/code&gt;. Try running it, a line of text reading &amp;ldquo;Hello World!&amp;rdquo; will be displayed if there are no exceptions.&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ ./hello.elf&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Hello World!&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;./images/hello-world.png&#34; alt=&#34;Hello World&#34;&gt;&lt;/p&gt;&lt;h2 id=&#34;10-debug-program-by-gdb&#34;&gt;10. Debug program by GDB&lt;/h2&gt;&lt;p&gt;The &lt;code&gt;gdb&lt;/code&gt; package has also been installed. Let&amp;rsquo;s start debugging &lt;code&gt;main.elf&lt;/code&gt;:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ gdb hello.elf&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;and run some GDB commands:&lt;/p&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-gdb&#34; data-lang=&#34;gdb&#34;&gt;(gdb) startiStarting program: /home/yang/hello.elfProgram stopped._start () at hello.S:1010          li      a0, 1               # file descriptor, 1 = stdout(gdb) x/6i $pc=&amp;gt; 0x100b0 &amp;lt;_start&amp;gt;:    li      a0,1   0x100b4 &amp;lt;_start+4&amp;gt;:  auipc   a1,0x0   0x100b8 &amp;lt;_start+8&amp;gt;:  addi    a1,a1,32   0x100bc &amp;lt;_start+12&amp;gt;: li      a2,13   0x100c0 &amp;lt;_start+16&amp;gt;: li      a7,64   0x100c4 &amp;lt;_start+20&amp;gt;: ecall(gdb) si11          la      a1, s               # the address/pointer to `s` string(gdb) si0x00000000000100b8      11          la      a1, s               # the address/pointer to `s` string(gdb) si14          li      a2, 13              # the length of string `s`(gdb) si15          li      a7, 64              # the number of syscall `write`(gdb) si16          ecall(gdb) i r a0 a1 a2 a7a0             0x1      1a1             0x100d4  65748a2             0xd      13a7             0x40     64(gdb) qA debugging session is active.        Inferior 1 [process 165] will be killed.Quit anyway? (y or n) y&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;./images/gdb.png&#34; alt=&#34;GDB Debugging&#34;&gt;&lt;/p&gt;&lt;p&gt;As shown above, this Linux system already contains common tools and is capable of base assembly development and program debugging.&lt;/p&gt;&lt;h2 id=&#34;11-where-is-the-gcc-toolchain&#34;&gt;11. Where is the GCC toolchain?&lt;/h2&gt;&lt;p&gt;Unfortunately, the &lt;code&gt;gcc&lt;/code&gt; package is not available in Buildroot, as explained in &lt;a href=&#34;https://buildroot.org/downloads/manual/manual.html#faq-no-compiler-on-target&#34;&gt;the Buildroot documentation&lt;/a&gt;. If you have patient enough, you can compile the GCC toolchains from source and copy it into the guest machine, It may be helpful to check out some scripts such as &lt;a href=&#34;https://github.com/michaeljclark/musl-riscv-toolchain/&#34;&gt;musl-riscv-toolchain&lt;/a&gt; and &lt;a href=&#34;https://git.zv.io/toolchains/musl-cross-make&#34;&gt;musl-cross-make&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;Alternatively, you can download the pre-compiled RISC-V crossing compilation toolchains from &lt;a href=&#34;https://toolchains.bootlin.com/&#34;&gt;toolchains.bootlin.com&lt;/a&gt; and the native compilation toolchains from &lt;a href=&#34;https://musl.cc/&#34;&gt;musl.cc&lt;/a&gt;. But these are beyond the scope of this chapter.&lt;/p&gt;&lt;h2 id=&#34;12-conclusion&#34;&gt;12. Conclusion&lt;/h2&gt;&lt;p&gt;In this section, we built a base Linux system that contains general tools as well as &lt;code&gt;binutils&lt;/code&gt; and &lt;code&gt;gdb&lt;/code&gt; using &lt;em&gt;Buildroot&lt;/em&gt;. However, it is still not complete, for example, the GCC toolchain is missing, and there is no package management tool, making it difficult to install or update software.&lt;/p&gt;&lt;p&gt;In the next section, we will set up a complete Debian distribution in QEMU.&lt;/p&gt;&lt;div&gt;    &lt;img src=&#34;https://hemashushu.github.io/images/subscribe-and-donate.en.png&#34; class=&#34;block-image image-480px&#34;/&gt;&lt;/div&gt;</description>
     </item>
   
     <item>
       <title>S10C01 RISC-V development using QEMU - Part 1 Build a minimal Linux system</title>
       <link>https://hemashushu.github.io/posts/2023-01-06-s10c01-risc-v-development-using-qemu-part-1-minimal-linux/</link>
       <pubDate>Fri, 06 Jan 2023 00:00:00 +0000</pubDate>
       
       <guid>https://hemashushu.github.io/posts/2023-01-06-s10c01-risc-v-development-using-qemu-part-1-minimal-linux/</guid>
       <description>&lt;p&gt;This series of articles will guide you setting up a RISC-V development environment using QEMU. The series includes four parts:&lt;/p&gt;&lt;p&gt;&lt;a href=&#34;../2023-01-06-s10c01-risc-v-development-using-qemu-part-1-minimal-linux/&#34;&gt;Part 1&lt;/a&gt;. Building a minimal RISC-V Linux system with only Linux kernel and BusyBox, and runs on the QEMU emulator.&lt;/p&gt;&lt;p&gt;&lt;a href=&#34;../2023-01-08-s10c02-risc-v-development-using-qemu-part-2-buildroot&#34;&gt;Part 2&lt;/a&gt;. Building a base RISC-V Linux system with the ability of doing RISC-V assembly development and debug using Buildroot.&lt;/p&gt;&lt;p&gt;Part 3. Setting up a complete Debian RISC-V Linux system in QEMU, and do C language development and debug with GCC toolchains.&lt;/p&gt;&lt;p&gt;Part 4. Remote debugging with the GDB, and setup remote text editing and debugging by VSCode.&lt;/p&gt;&lt;hr&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&#34;#1-why-not-the-real-risc-v-hardware&#34;&gt;1. Why not the real RISC-V hardware?&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#2-create-the-project-folder&#34;&gt;2. Create the project folder&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#3-build-the-linux-system&#34;&gt;3. Build the Linux system&lt;/a&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&#34;#31-compile-linux-kernel&#34;&gt;3.1 Compile Linux kernel&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#32-compile-busybox&#34;&gt;3.2 Compile BusyBox&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#4-make-the-image-file&#34;&gt;4. Make the image file&lt;/a&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&#34;#41-create-an-empty-image-file&#34;&gt;4.1 Create an empty image file&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#42-partition-the-image-file&#34;&gt;4.2 Partition the image file&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#43-make-the-file-system&#34;&gt;4.3 Make the file system&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#44-configure-the-system&#34;&gt;4.4 Configure the system&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#45-check-the-file-system&#34;&gt;4.5 Check the file system&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#5-boot-the-system&#34;&gt;5. Boot the system&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#6-get-rid-of-the-busybox&#34;&gt;6. Get rid of the BusyBox&lt;/a&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&#34;#61-create-_hello-world_-program&#34;&gt;6.1 Create &lt;em&gt;Hello World&lt;/em&gt; program&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#62-create-initramfs-file&#34;&gt;6.2 Create &lt;code&gt;initramfs&lt;/code&gt; file&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#63-boot-the-new-system&#34;&gt;6.3 Boot the new system&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#7-conclusion&#34;&gt;7. Conclusion&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;!-- raw HTML omitted --&gt;&lt;h2 id=&#34;1-why-not-the-real-risc-v-hardware&#34;&gt;1. Why not the real RISC-V hardware?&lt;/h2&gt;&lt;p&gt;The RISC-V ISA has become popular in recent years due to its ease of learning and implementation, and the RISC-V toolchains are now quite mature. However, high-performance, stable and affordable RISC-V chips are still missing as of 2023.&lt;/p&gt;&lt;p&gt;Moreover, writing and debugging programs in an emulator is far more convenient than on real hardware. This approach can save money, eliminate the need for connecting wires, and avoid the hassle of copying or synchronizing program files. You can perform all sorts of tasks on just one machine.&lt;/p&gt;&lt;h2 id=&#34;2-create-the-project-folder&#34;&gt;2. Create the project folder&lt;/h2&gt;&lt;p&gt;QEMU is a software that emulates all the hardware of a complete computer system, including the CPU, memory, storage drives and network interfaces. This emulation is commonly known as a &amp;ldquo;virtual computer&amp;rdquo; or &amp;ldquo;virtual machine&amp;rdquo;.&lt;/p&gt;&lt;p&gt;Unlike VirtualBox or VMWare, In QEMU, the hardware configuation of a virtual machine, such as the type of CPU, number of cores, memory capacity, is specified through QEMU command line parameters. As a result, the command to start QEMU can be quite lengthy. It&amp;rsquo;s good practice to create a shell script to start QEMU and a directory for each virtual machine to hold this script file and the image file.&lt;/p&gt;&lt;p&gt;To get started, create a directory in your home directory and name it something like &amp;ldquo;riscv64-minimal-linux&amp;rdquo;, this is where you will store all the files created in this chapter.&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ mkdir ~/riscv64-minimal-linux&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ cd ~/riscv64-minimal-linux&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;&lt;p&gt;It is not possible to create a RISC-V virtual machine using virtualaztion software such as VirtualBox and VMWare on the &lt;em&gt;x86_64&lt;/em&gt; or &lt;em&gt;ARM&lt;/em&gt; platform. This is because these types of software are only capable of creating virtual machine with the same architecture CPU as the host machine. For example, on an &lt;em&gt;x86_64&lt;/em&gt; platform, you can only create an &lt;em&gt;x86_64&lt;/em&gt; virtual machine. However, since the computing ability of virtual machines is provided by the physical CPU of the host machine, their performance is typically much higher than that of QEMU.&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&#34;3-build-the-linux-system&#34;&gt;3. Build the Linux system&lt;/h2&gt;&lt;p&gt;There is a common misconception that building a Linux system is a daunting task. However, building a minimal, runnable Linux system is much easier than you might expect. In fact, it only requires two programs: a &lt;a href=&#34;https://www.kernel.org/&#34;&gt;Linux kernel&lt;/a&gt; and a user program.&lt;/p&gt;&lt;p&gt;The Linux kernel is responsible for driving and initializing hardware componenets, as well as creating an environment for running applications. On the other hand, the user program is responsible for providing specific functionality.&lt;/p&gt;&lt;p&gt;A typical Linux system consists of numerous user programs, including:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;An initialization program (&lt;code&gt;/sbin/init&lt;/code&gt;) which is launched by the kernel and starts all other user programs.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;A user interactive interface program called &lt;em&gt;shell&lt;/em&gt; (&lt;code&gt;/bin/sh&lt;/code&gt;), which accepts user input and executes commands.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;A series of base programs such as &lt;em&gt;ls&lt;/em&gt;, &lt;em&gt;cat&lt;/em&gt;, &lt;em&gt;echo&lt;/em&gt; etc.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img src=&#34;./images/linux-boot-process.png&#34; alt=&#34;Linux System Boot Process&#34;&gt;&lt;/p&gt;&lt;p&gt;There is an amazing program called &lt;a href=&#34;https://busybox.net/&#34;&gt;Busybox&lt;/a&gt; that contains all of the user programs mentioned above in a single program. BusyBox greatly simplifies the process of building a system. In this chapter we will build our first system using Busybox and the Linux kernel.&lt;/p&gt;&lt;figure class=&#34;mid&#34;&gt;&lt;img src=&#34;./images/minimal-linux-os.png&#34;         alt=&#34;Minimal Linux Operating System&#34;/&gt;&lt;figcaption&gt;            &lt;p&gt;Minimal Linux Operating System&lt;/p&gt;        &lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 id=&#34;31-compile-linux-kernel&#34;&gt;3.1 Compile Linux kernel&lt;/h3&gt;&lt;ol&gt;&lt;li&gt;Install RISC-V GCC toolchains&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;You may need to install the RISC-V GCC toolchains if they are not already installed on your system. For example, on &lt;em&gt;Arch Linux&lt;/em&gt;, the required packages are:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;riscv64-linux-gnu-gcc&lt;/li&gt;&lt;li&gt;riscv64-linux-gnu-binutils&lt;/li&gt;&lt;li&gt;riscv64-linux-gnu-gdb&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;On Debian/Ubuntu, the packages are:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;gcc-riscv64-linux-gnu&lt;/li&gt;&lt;li&gt;binutils-riscv64-linux-gnu (may be installed automatically)&lt;/li&gt;&lt;li&gt;gdb-multiarch&lt;/li&gt;&lt;/ul&gt;&lt;ol start=&#34;2&#34;&gt;&lt;li&gt;Prepare the Linux kernel source code&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;Download the &lt;a href=&#34;https://cdn.kernel.org/pub/linux/kernel/v6.x/linux-6.2.10.tar.xz&#34;&gt;Linux kernel source code tarball&lt;/a&gt; to the project folder.&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ wget https://cdn.kernel.org/pub/linux/kernel/v6.x/linux-6.2.10.tar.xz&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Once the tarball is downloaded, extract it to obtain a folder named &lt;code&gt;linux-6.2.10&lt;/code&gt;.&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ tar xf linux-6.2.10.tar.xz&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;&lt;p&gt;It&amp;rsquo;s not recommended that cloning the kernel source code Git repository, as it is very large, takes a long time to download and requires a significant amount of storage space.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;Ensure that no permission errors occur, transfer ownership of the directory to the current user:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ chown -R $USER:$USER linux-6.2.10&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol start=&#34;3&#34;&gt;&lt;li&gt;Compiling with default configuration&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;Ensure that the kernel tree is absolutely clean, change into the kernel source directory created and run the &lt;code&gt;make mrproper&lt;/code&gt; command:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ cd linux-6.2.10&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ make mrproper&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Configure with the default settings and start to compile:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ ARCH&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;riscv CROSS_COMPILE&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;riscv64-linux-gnu- make defconfig&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ ARCH&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;riscv CROSS_COMPILE&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;riscv64-linux-gnu- make -j &lt;span style=&#34;color:#66d9ef&#34;&gt;$(&lt;/span&gt;nproc&lt;span style=&#34;color:#66d9ef&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Take a break and step out for a cup of coffee. When you return, you should find a file named &lt;code&gt;arch/riscv/boot/Image&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;To examine this file, use the &lt;code&gt;file&lt;/code&gt; command:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ file arch/riscv/boot/Image&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The output should indicate that file is a &amp;ldquo;PE32+ executable (EFI application)&amp;rdquo;&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;./arch/riscv/boot/Image: PE32+ executable (EFI application) RISC-V 64-bit (stripped to external PDB), for MS Windows, 2 sections&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Note that the output file is different from the &lt;em&gt;x86&lt;/em&gt; architecture. When compiling for &lt;em&gt;x86&lt;/em&gt;, the default output file is &lt;code&gt;arch/x86/boot/bzImage&lt;/code&gt;, which is a compressed binary image. It will be later renamed to &lt;em&gt;vmlinuz&lt;/em&gt; and copied to the &lt;code&gt;/boot&lt;/code&gt; directory (the prefix &amp;ldquo;vm&amp;rdquo; stands for &amp;ldquo;virtual memory&amp;rdquo;, and the suffix &amp;ldquo;z&amp;rdquo; indicates that the file is compressed). While &lt;code&gt;arch/riscv/boot/Image&lt;/code&gt; is a flat binary image file and it is a commonly used for embedded systems. Check &lt;a href=&#34;https://en.wikipedia.org/wiki/Vmlinux&#34;&gt;vmlinux wiki&lt;/a&gt; for details.&lt;/p&gt;&lt;h3 id=&#34;32-compile-busybox&#34;&gt;3.2 Compile BusyBox&lt;/h3&gt;&lt;p&gt;Navigate back to the &lt;code&gt;~/riscv64-minimal-linux&lt;/code&gt; folder, download the &lt;a href=&#34;https://busybox.net/downloads/busybox-1.36.0.tar.bz2&#34;&gt;BusyBox source code tarball&lt;/a&gt;, extract the tarball and configure it using the default settings.&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ cd ..&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ wget https://busybox.net/downloads/busybox-1.36.0.tar.bz2&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ tar xf busybox-1.36.0.tar.bz2&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ cd busybox-1.36.0&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ CROSS_COMPILE&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;riscv64-linux-gnu- make defconfig&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Before compiling, some minor modifications are needed:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ make menuconfig&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Select the &amp;ldquo;Settings -&amp;gt; Build Options -&amp;gt; Build static binary (no shared libs)&amp;rdquo; option. Then select &amp;ldquo;Exit&amp;rdquo; and confirm &amp;ldquo;Yes&amp;rdquo; when prompted with &amp;ldquo;Do you wish to save your new configuration&amp;rdquo;.&lt;/p&gt;&lt;p&gt;Once you have completed this step, you can begin the compilation process:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ CROSS_COMPILE&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;riscv64-linux-gnu- make -j &lt;span style=&#34;color:#66d9ef&#34;&gt;$(&lt;/span&gt;nproc&lt;span style=&#34;color:#66d9ef&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;We now have the output file &lt;code&gt;./busybox&lt;/code&gt;, use the &lt;code&gt;file&lt;/code&gt; command to check and confirm that it is a RISC-V executable file with &lt;strong&gt;static linking&lt;/strong&gt;:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ file busybox&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The expected output should resemble something like:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;busybox: ELF 64-bit LSB executable, UCB RISC-V, RVC, double-float ABI, version 1 (SYSV), statically linked, BuildID[sha1]=04d2e9ad32458855c1861202cc4f7b53dea75374, for GNU/Linux 4.15.0, stripped&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;4-make-the-image-file&#34;&gt;4. Make the image file&lt;/h2&gt;&lt;p&gt;Just as a computer needs a hard drive or SSD to store programs and data, a virtual machine needs storage device as well. The storage device for virtual machines is usually implemented using a type of file called &amp;ldquo;image file&amp;rdquo;, which means that the hard disk drive you see within the virtual machine is actually an ordinary file located on the &lt;em&gt;host machine&lt;/em&gt; (the machine running QEMU). Operations such as partitioning, formatting, reading and writing to the hard disk drive within the virtual machine take place inside the image file.&lt;/p&gt;&lt;h3 id=&#34;41-create-an-empty-image-file&#34;&gt;4.1 Create an empty image file&lt;/h3&gt;&lt;p&gt;Navigate back to the &lt;code&gt;~/riscv64-minimal-linux&lt;/code&gt; folder, create an empty file &lt;code&gt;vda.img&lt;/code&gt; with a capacity of 128MB:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ dd &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;/dev/zero of&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;vda.img bs&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;1M count&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;128&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The &lt;code&gt;dd&lt;/code&gt; command copies data from &lt;code&gt;if&lt;/code&gt; to &lt;code&gt;of&lt;/code&gt; with the specified capacity, where &lt;code&gt;/dev/zero&lt;/code&gt; is a special file filled with zeroes with an infinite size. You can check the contents of a file using the hexadecimal and binary viewr and converter tool &lt;code&gt;xxd&lt;/code&gt;:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ xxd -l &lt;span style=&#34;color:#ae81ff&#34;&gt;64&lt;/span&gt; vda.img&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The above command shows the first 64 bytes of the file &lt;code&gt;vda.img&lt;/code&gt;. The expected output is:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;00000000: 0000 0000 0000 0000 0000 0000 0000 0000  ................&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;00000010: 0000 0000 0000 0000 0000 0000 0000 0000  ................&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;00000020: 0000 0000 0000 0000 0000 0000 0000 0000  ................&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;00000030: 0000 0000 0000 0000 0000 0000 0000 0000  ................&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;42-partition-the-image-file&#34;&gt;4.2 Partition the image file&lt;/h3&gt;&lt;p&gt;The current image file is like a flash new hard disk and needs to be partitioned before we can store programs and data on it.&lt;/p&gt;&lt;p&gt;There is a convenient tool called &lt;code&gt;fdisk&lt;/code&gt; that can be used to partition a disk or image file. Run the following command:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ fdisk vda.img&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Since we are not partitioning a real hard disk, the above command does not require root privileges (i.e., running as the root user or using &lt;code&gt;sudo&lt;/code&gt;). Then enter the following commands in sequence in &lt;code&gt;fdisk&lt;/code&gt;:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Command (m for help): g&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Command (m for help): n&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Command (m for help): w&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The meaning of each command is:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;g&lt;/code&gt;: create a new empty GPT partition table.&lt;/li&gt;&lt;li&gt;&lt;code&gt;n&lt;/code&gt;: add a new partition. Use the default values for all options in this step.&lt;/li&gt;&lt;li&gt;&lt;code&gt;w&lt;/code&gt;: write the partition table to disk and exit &lt;code&gt;fdisk&lt;/code&gt;.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Let&amp;rsquo;s check the partitions of the image file:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ fdisk -l vda.img&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The output should resemble this:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Disk vda.img: 128 MiB, 134217728 bytes, 262144 sectors&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Units: sectors of 1 * 512 = 512 bytes&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Sector size (logical/physical): 512 bytes / 512 bytes&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;I/O size (minimum/optimal): 512 bytes / 512 bytes&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Disklabel type: gpt&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Device     Start    End Sectors  Size Type&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;vda.img1    2048 260095  258048  126M Linux filesystem&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Then attach this image file to the current system:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ sudo losetup -P /dev/loop0 vda.img&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The image file is treated as a hard disk. The device file &lt;code&gt;/dev/loop0&lt;/code&gt; refers to the hard disk, and &lt;code&gt;/dev/loop0p1&lt;/code&gt; refers to the first partition (the &lt;code&gt;/dev/loop0p2&lt;/code&gt; is the second partition and so on).&lt;/p&gt;&lt;p&gt;Format the first partition with the &lt;code&gt;ext2&lt;/code&gt; file system:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ sudo mkfs.ext2 /dev/loop0p1&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;&lt;p&gt;A typical hard disk or SSD for a Linux system consists of four partitions: &lt;code&gt;/boot&lt;/code&gt;, root, &lt;code&gt;/home&lt;/code&gt; and a swap partition. However, for a simple system, only one root partition is required.&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 id=&#34;43-make-the-file-system&#34;&gt;4.3 Make the file system&lt;/h3&gt;&lt;p&gt;To begin, mount the first partition:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ mkdir -p part1&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ sudo mount /dev/loop0p1 part1&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The &lt;code&gt;part1&lt;/code&gt; directory represents the root filesystem of the virtual machine to be built. We need to create a series of directories within it that are required by the Linux system.&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ cd part1&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ sudo mkdir -p bin sbin lib usr/bin usr/sbin usr/lib&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ sudo mkdir -p etc&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ sudo mkdir -p root&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;You may wonder why so many directories are needed, but it&amp;rsquo;s for historical reasons. Linux inherited the concept of Unix, which is a 50-year-old system when computer hardware and software were very different from modern ones. Now this series of directories has become a convention for Linux system.&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;bin&lt;/code&gt;: base programs such as &lt;code&gt;ls&lt;/code&gt;, &lt;code&gt;cat&lt;/code&gt;, &lt;code&gt;mkdir&lt;/code&gt;.&lt;/li&gt;&lt;li&gt;&lt;code&gt;sbin&lt;/code&gt;: system programs such as &lt;code&gt;init&lt;/code&gt;, &lt;code&gt;mount&lt;/code&gt;, &lt;code&gt;sysctl&lt;/code&gt;.&lt;/li&gt;&lt;li&gt;&lt;code&gt;lib&lt;/code&gt;: base system libraries such as C standard library &lt;code&gt;libc.so&lt;/code&gt;.&lt;/li&gt;&lt;li&gt;&lt;code&gt;usr/bin&lt;/code&gt;: genernal programs such as &lt;code&gt;xxd&lt;/code&gt;, &lt;code&gt;wget&lt;/code&gt;, &lt;code&gt;make&lt;/code&gt;.&lt;/li&gt;&lt;li&gt;&lt;code&gt;usr/sbin&lt;/code&gt;: system daemons and utilities such as &lt;code&gt;sshd&lt;/code&gt;, &lt;code&gt;httpd&lt;/code&gt;.&lt;/li&gt;&lt;li&gt;&lt;code&gt;usr/lib&lt;/code&gt;: genernal libraries.&lt;/li&gt;&lt;li&gt;&lt;code&gt;etc&lt;/code&gt;: system configuration files.&lt;/li&gt;&lt;li&gt;&lt;code&gt;root&lt;/code&gt;: the home folder for the &lt;code&gt;root&lt;/code&gt; user. As you know the home folder for all users is under the &lt;code&gt;/home&lt;/code&gt; folder, but the root user is an exception.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;If you write a program to distribute to a Linux system, you need to follow these conventions as well:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;/usr/bin&lt;/code&gt;: binary executables.&lt;/li&gt;&lt;li&gt;&lt;code&gt;/usr/share&lt;/code&gt;: read-only program resource files.&lt;/li&gt;&lt;li&gt;&lt;code&gt;/etc&lt;/code&gt;: system-wide program configuration files.&lt;/li&gt;&lt;li&gt;&lt;code&gt;/var/lib&lt;/code&gt;: system-wide program data.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;If you write a shared library:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;/usr/lib&lt;/code&gt;: the library files.&lt;/li&gt;&lt;li&gt;&lt;code&gt;/usr/include&lt;/code&gt;: library headers.&lt;/li&gt;&lt;/ul&gt;&lt;blockquote&gt;&lt;p&gt;In certain modern Linux distributions, the directories &lt;code&gt;/bin&lt;/code&gt;, &lt;code&gt;/sbin&lt;/code&gt;, &lt;code&gt;/lib&lt;/code&gt; are simple symbolic links to &lt;code&gt;/usr/bin&lt;/code&gt;, &lt;code&gt;/usr/sbin&lt;/code&gt; and &lt;code&gt;/usr/lib&lt;/code&gt; correspondingly.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;Apart from the &lt;em&gt;actual file system&lt;/em&gt;, there are various virtual file system directries whose contents are generated by the kernel and drivers. Although you still need to create them manually on the hard disk, they serve as mount points.&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ sudo mkdir -p dev proc sys&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;dev&lt;/code&gt;: device files created by device drivers, Linux treats all hardware as files, for example, &lt;code&gt;/dev/hda&lt;/code&gt; is the first hard disk of your system, and you can read and write to it as if the entire hard disk is a huge file.&lt;/li&gt;&lt;li&gt;&lt;code&gt;proc&lt;/code&gt;: user programs running information, but also some kernel and drivers running information for historical reasons.&lt;/li&gt;&lt;li&gt;&lt;code&gt;sys&lt;/code&gt;: kernel and drivers running information.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Two additional virtual directories present, named &lt;code&gt;run&lt;/code&gt; and &lt;code&gt;tmp&lt;/code&gt;. They are actually RAM disks for storing cache and temporary files, and all data stored in them would be lost when the machine is rebooted.&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ sudo mkdir -p run tmp&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;It is important to note that:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Not everyone has a consistent understanding of these directories, so some directories may store other content.&lt;/li&gt;&lt;li&gt;They are created all with root privilegs because the owner of these folders should be the &lt;code&gt;root&lt;/code&gt; user.&lt;/li&gt;&lt;/ul&gt;&lt;blockquote&gt;&lt;p&gt;Check the &lt;a href=&#34;https://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard&#34;&gt;Filesystem Hierarchy Standard&lt;/a&gt; for the details of directory structure.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;Next, copy the BusyBox program file into the &lt;code&gt;bin&lt;/code&gt; folder and create essential symbolic links.&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ cd bin&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ sudo cp ../../busybox-1.36.0/busybox .&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ sudo ln -s busybox sh&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ cd ..&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ cd sbin&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ sudo ln -s ../bin/busybox init&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ sudo ln -s ../bin/busybox mount&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ cd ..&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;By default, when kernel has finish initializing hardware and building the user program running environment, it launches the first and only user program &lt;code&gt;/sbin/init&lt;/code&gt;. The file path is hard coding in the kernel source, so we should follow this convention as well.&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;As you can see from the above commands, &lt;code&gt;init&lt;/code&gt; is just a symbolic link, and it is actually the Busybox program itself, as well as the shell program &lt;code&gt;sh&lt;/code&gt; and mount utility &lt;code&gt;mount&lt;/code&gt;. How does Busybox do this? This is because Busybox integrates including &lt;code&gt;init&lt;/code&gt;, shell, and many base programs (such as &lt;code&gt;cat&lt;/code&gt;, &lt;code&gt;ls&lt;/code&gt;). When it is called through a symbolic link, it knows the name of the link (remember the value of the first element of the parameter &lt;code&gt;argv&lt;/code&gt; in the &lt;code&gt;main()&lt;/code&gt; function?) and starts the corresponding function inside it by that name, thus enabling one program to play the role of multiple programs.&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 id=&#34;44-configure-the-system&#34;&gt;4.4 Configure the system&lt;/h3&gt;&lt;p&gt;The system built by Busybox is configured by commands, including mounting file systems, assigning IP addresses for network interface. Create a shell script &lt;code&gt;/etc/init.d/rcS&lt;/code&gt; and write command lines into it as needed.&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ cd etc&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ sudo mkdir -p init.d&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ cat &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;lt;&amp;lt; EOF | sudo tee init.d/rcS&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;#!/bin/sh&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;mount -t proc none /proc&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;mount -t sysfs none /sys&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;mount -t tmpfs none /run&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;mount -t tmpfs none /tmp&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;EOF&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ sudo chmod +x init.d/rcS&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ cd ..&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Since we are building a simple system, there are only mount virtual folder commands in the initialization shell script. Remember to add the &lt;em&gt;execute permission&lt;/em&gt; to the script file, otherwise it wouldn&amp;rsquo;t be executed.&lt;/p&gt;&lt;p&gt;To prevent Busybox from complaining, there are still some files that need to be created:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ cd dev&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ sudo mknod -m &lt;span style=&#34;color:#ae81ff&#34;&gt;666&lt;/span&gt; tty2 c &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ sudo mknod -m &lt;span style=&#34;color:#ae81ff&#34;&gt;666&lt;/span&gt; tty3 c &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ sudo mknod -m &lt;span style=&#34;color:#ae81ff&#34;&gt;666&lt;/span&gt; tty4 c &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ cd ..&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ sudo touch etc/fstab&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;45-check-the-file-system&#34;&gt;4.5 Check the file system&lt;/h3&gt;&lt;p&gt;To ensure that the file system has been created correctly, run the &lt;code&gt;tree&lt;/code&gt; command:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ sudo tree&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The expected output should resemble the following:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; bin&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    busybox&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    sh -&amp;gt; busybox&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; dev&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    tty2&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    tty3&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    tty4&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; etc&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    fstab&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    init.d&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        rcS&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; lib&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; lost+found&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; proc&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; root&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; run&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; sbin&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    init -&amp;gt; ../bin/busybox&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    mount -&amp;gt; ../bin/busybox&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; sys&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; tmp&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; usr&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;     bin&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;     lib&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;     sbin&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;17 directories, 9 files&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Finally, leave the &lt;code&gt;part1&lt;/code&gt; folder and unmount the image file:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ cd ..&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ sudo umount part1&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ rm -r part1&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ sudo losetup -d /dev/loop0&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;You now have an image file &lt;code&gt;vda.img&lt;/code&gt; which contains a minimal bootable Linux file system.&lt;/p&gt;&lt;h2 id=&#34;5-boot-the-system&#34;&gt;5. Boot the system&lt;/h2&gt;&lt;p&gt;Install QEMU, On Arch Linux, the package is:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;qemu-system-riscv&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;On Debian/Ubuntu, the package is:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;qemu-system&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Once you&amp;rsquo;ve installed QEMU, navigate back to the &lt;code&gt;~/riscv64-minimal-linux&lt;/code&gt; folder again and run the following command:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ qemu-system-riscv64 &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;     -machine virt &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;     -m 1G &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;     -kernel ./linux-6.2.10/arch/riscv/boot/Image &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;     -append &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;root=/dev/vda1 rw console=ttyS0&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;     -drive file&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;vda.img,format&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;raw,id&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;hd0 &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;     -device virtio-blk-device,drive&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;hd0 &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;     -nographic&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;There are several parameters in this command, let&amp;rsquo;s go through them line by line:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;-machine virt&lt;/code&gt; QEMU can emulate many real hardware platforms. A machine is a combination of a specified processor and some peripherals. &lt;a href=&#34;https://qemu-project.gitlab.io/qemu/system/riscv/virt.html&#34;&gt;The &lt;code&gt;virt&lt;/code&gt; machine&lt;/a&gt; is a specical one that doesn&amp;rsquo;t correspond to any real hardware. It&amp;rsquo;s an idealized processor for a specified architecture combined with some devices.&lt;/li&gt;&lt;li&gt;&lt;code&gt;-m 1G&lt;/code&gt;: This specifies the memory capacity.&lt;/li&gt;&lt;li&gt;&lt;code&gt;-kernel ./linux-6.2/arch/riscv/boot/Image&lt;/code&gt;: This specifies the kernel file. Just like a real machine, the QEMU boot process also contains several stages: &amp;ldquo;bios -&amp;gt; kernel -&amp;gt; initramfs -&amp;gt; userspace init&amp;rdquo;. When you omit the &lt;code&gt;-bios&lt;/code&gt; parameter, the &lt;a href=&#34;https://qemu-project.gitlab.io/qemu/system/target-riscv.html#risc-v-cpu-firmware&#34;&gt;default RISC-V QEMU BIOS firmware&lt;/a&gt; called &lt;code&gt;OpenSBI&lt;/code&gt; will be loaded automatically.&lt;/li&gt;&lt;li&gt;&lt;code&gt;-append &amp;quot;root=/dev/vda rw console=ttyS0&amp;quot;&lt;/code&gt;: This appends parameters to the kernel. Yes, the kernel is also an executable file that accepts many startup parameters, just like a normal user program. The common parameters &lt;code&gt;root=&lt;/code&gt; and &lt;code&gt;init=&lt;/code&gt; are used to specify the root file system and the &lt;code&gt;init&lt;/code&gt; program file path.  Check &lt;a href=&#34;https://docs.kernel.org/admin-guide/kernel-parameters.html&#34;&gt;this link&lt;/a&gt; for the full list of kernel parameters.&lt;/li&gt;&lt;li&gt;&lt;code&gt;-drive file=vda.img,format=raw,id=hd0&lt;/code&gt; and &lt;code&gt;-device virtio-blk-device,drive=hd0&lt;/code&gt;: These parameters specify the block device, which can be considered as the hard disk drive or SSD. In the current case, it&amp;rsquo;s the image file &lt;code&gt;vda.img&lt;/code&gt;.&lt;/li&gt;&lt;li&gt;&lt;code&gt;-nographic&lt;/code&gt;: This indicates that this machine has no graphic interface hardware (also called &lt;em&gt;graphic card&lt;/em&gt;), so all text messages generated by the software in this machine will be fed back to user through the &lt;em&gt;Serial port&lt;/em&gt;. Of course, the &lt;em&gt;Serial port&lt;/em&gt; is also virtual, it redirects the text message to the &lt;em&gt;Terminal&lt;/em&gt; running the QEMU program.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;After executing the command, a lot of text will scroll up until a message appears:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Please press Enter to activate this console.&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Press the &lt;code&gt;Enter&lt;/code&gt; key, and a command prompt &lt;code&gt;~ #&lt;/code&gt; will appear.&lt;/p&gt;&lt;p&gt;Note that all base and system programs (i.e., the symbolic links to Busybox) have not been created yet. Run the following command to complete the installation:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# /bin/busybox --install -s&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Note that this step only needs to be done once. The Linux system is now ready, let&amp;rsquo;s do some checking:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# uname -a&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Linux &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;none&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; 6.2.10 &lt;span style=&#34;color:#75715e&#34;&gt;#1 SMP Tue Jan 4 02:10:41 CST 2023 riscv64 GNU/Linux&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# free -h&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;              total        used        free      shared  buff/cache   available&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Mem:         970.5M       10.6M      957.1M           &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;        2.7M      952.6M&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# df -h&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Filesystem                Size      Used Available Use% Mounted on&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;/dev/root               116.6M      1.7M    108.6M   2% /&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;devtmpfs                484.2M         &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;    484.2M   0% /dev&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;none                    485.2M         &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;    485.2M   0% /run&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;none                    485.2M         &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;    485.2M   0% /tmp&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# cat /proc/cpuinfo&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;processor       : &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;hart            : &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;isa             : rv64imafdch_sstc_zihintpause&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;mmu             : sv57&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;mvendorid       : 0x0&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;marchid         : 0x70200&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;mimpid          : 0x70200&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;./images/busybox.png&#34; alt=&#34;Busybox&#34;&gt;&lt;/p&gt;&lt;p&gt;Run the command &lt;code&gt;poweroff&lt;/code&gt; to turn off the virtual machine to exit QEMU. If there is any exception causes the virtual machine to freeze, press &lt;code&gt;Ctrl+a&lt;/code&gt; and then press the &lt;code&gt;x&lt;/code&gt; key to terminate QEMU. Note that the &lt;code&gt;Ctrl+C&lt;/code&gt; key does not work.&lt;/p&gt;&lt;h2 id=&#34;6-get-rid-of-the-busybox&#34;&gt;6. Get rid of the BusyBox&lt;/h2&gt;&lt;p&gt;If there is only one user program need to run, and the shell is not necessary, the system we built can be further simplified.&lt;/p&gt;&lt;p&gt;Next we will create a &lt;em&gt;Hello World&lt;/em&gt; program, and use it to replace the Busybox. Thus the system only consist of Linux kernel and one &lt;em&gt;Hello World&lt;/em&gt; program.&lt;/p&gt;&lt;h3 id=&#34;61-create-_hello-world_-program&#34;&gt;6.1 Create &lt;em&gt;Hello World&lt;/em&gt; program&lt;/h3&gt;&lt;p&gt;Navigate back to the &lt;code&gt;~/riscv64-minimal-linux&lt;/code&gt; folder, create file &lt;code&gt;app.c&lt;/code&gt; with the following code:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;printf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Hello, world!&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;printf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Press Ctrl+a, then press x to exit QEMU.&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; c &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;getchar&lt;/span&gt;();&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;putchar&lt;/span&gt;(c);&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Then compile it with RISC-V GCC compiler:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ riscv64-linux-gnu-gcc -g -Wall -static -o app.elf app.c&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;&lt;p&gt;The compilation parameter &lt;code&gt;-static&lt;/code&gt; instructs the compiler to generate an executable program with static linking, it simplifies our example.&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 id=&#34;62-create-initramfs-file&#34;&gt;6.2 Create &lt;code&gt;initramfs&lt;/code&gt; file&lt;/h3&gt;&lt;p&gt;In the modern Linux systems, there is a small, temporary file system called &lt;code&gt;initramfs&lt;/code&gt; (&lt;em&gt;initial RAM File System&lt;/em&gt;) between the kernel and the real root file system. When the kernel finishes the base hardware initialization and building the program running environment, it launches the &lt;code&gt;/sbin/init&lt;/code&gt; program located in the &lt;code&gt;initramfs&lt;/code&gt; instead of the real root file system. Then &lt;code&gt;initramfs&lt;/code&gt; loads additional hardware device drivers, sets up network interfaces, loads and jumps to the real root file system.&lt;/p&gt;&lt;p&gt;&lt;code&gt;initramfs&lt;/code&gt; increases the flexibility of the system. For example, the real root file system can be located on an encrypted disk or on a network, and &lt;code&gt;initramfs&lt;/code&gt; can handle this without any changes to the kernel.&lt;/p&gt;&lt;p&gt;&lt;code&gt;initramfs&lt;/code&gt; is an archive file that resembles a &lt;code&gt;*.tar&lt;/code&gt; tarball. It is far easier to create an &lt;code&gt;initramfs&lt;/code&gt; than to create an image file. Thus, we will put the &lt;em&gt;Hello World&lt;/em&gt; program into &lt;code&gt;initramfs&lt;/code&gt; and will not need to create the &lt;code&gt;vda.img&lt;/code&gt; image file anymore.&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;In earlier versions of Linux, there was another temporary RAM file system called &lt;code&gt;initrd&lt;/code&gt; (&lt;em&gt;initial RAM disk&lt;/em&gt;), which is a bit like an image file. It would be loaded and mounted to RAM by bootloader during the machine boot process. However it is now deprecated and replaced by &lt;code&gt;initramfs&lt;/code&gt;. The name &lt;em&gt;initrd&lt;/em&gt; is still inherited, and can be seen in files such as the GRUB configuration file &lt;code&gt;/boot/grub/grub.cfg&lt;/code&gt; and the QEMU command parameters.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;Navigate to the &lt;code&gt;~/riscv64-minimal-linux&lt;/code&gt; folder, create the folder &lt;code&gt;ram1&lt;/code&gt;, change into it, and create the folder &lt;code&gt;sbin&lt;/code&gt;:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ mkdir -p ram1&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ cd ram1&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ mkdir -p sbin&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Copy the &lt;em&gt;Hello World&lt;/em&gt; program into &lt;code&gt;sbin&lt;/code&gt; folder and name it &lt;code&gt;init&lt;/code&gt;:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ cp ../app.elf sbin/init&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The file system creation is complete. Note that both creating folder and copying file do not require root privileges. Run the &lt;code&gt;tree&lt;/code&gt; command to check the new file system:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ tree&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The output should be:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; sbin&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;     init&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;2 directories, 1 file&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Use the command &lt;code&gt;cpio&lt;/code&gt; to package the &lt;code&gt;ram1&lt;/code&gt; folder into an archive file and compress it with &lt;code&gt;gzip&lt;/code&gt; command:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;find . | &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;     cpio -o -v --format&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;newc | &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;     gzip &amp;gt; ../initramfs.cpio.gz&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Now you have obtained the file &lt;code&gt;~/riscv64-minimal-linux/initramfs.cpio.gz&lt;/code&gt;. It is safe to delete the &lt;code&gt;ram1&lt;/code&gt; folder:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ cd ..&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ rm -Rf ram1&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;63-boot-the-new-system&#34;&gt;6.3 Boot the new system&lt;/h3&gt;&lt;p&gt;Run the following command:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;qemu-system-riscv64 &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;    -machine virt &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;    -m 1G &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;    -kernel ./linux-6.2.10/arch/riscv/boot/Image &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;    -initrd ./initramfs.cpio.gz &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;    -append &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;root=/dev/ram rdinit=/sbin/init console=ttyS0&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;    -nographic&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;There is a new kernel parameter &lt;code&gt;rdinit=&lt;/code&gt;, which is used to specify the &lt;code&gt;init&lt;/code&gt; program file path in the &lt;code&gt;initramfs&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;After a while, the &amp;ldquo;Hello, World!&amp;rdquo; message will appear:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Hello, world!&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Press Ctrl+a, then press x to exit QEMU.&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;./images/app.png&#34; alt=&#34;Hello, World! Program&#34;&gt;&lt;/p&gt;&lt;p&gt;This indicates that our program is executed correctly.&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Because this &lt;em&gt;Hello World&lt;/em&gt; program is the only user program, it is launched directly by the kernel. It has no exit door to leave. Therefore, there is an inifinite loop in the &lt;code&gt;main()&lt;/code&gt; functon in the &lt;code&gt;app.c&lt;/code&gt;. If this only user program ends, the machine will crash and a &lt;em&gt;kernel panic&lt;/em&gt; message will be shown.&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&#34;7-conclusion&#34;&gt;7. Conclusion&lt;/h2&gt;&lt;p&gt;In this section, we&amp;rsquo;ve created a minimal Linux system with a base shell, and it can properly run a static linking user program. However, you&amp;rsquo;ll notice that this system lacks many tools that we use daily, such as &lt;code&gt;ssh&lt;/code&gt;, &lt;code&gt;vim&lt;/code&gt; and &lt;code&gt;git&lt;/code&gt; etc. In the next section, we&amp;rsquo;ll build a base Linux system with common tools and the capability of doing RISC-V assembly development and debugging.&lt;/p&gt;&lt;div&gt;    &lt;img src=&#34;https://hemashushu.github.io/images/subscribe-and-donate.en.png&#34; class=&#34;block-image image-480px&#34;/&gt;&lt;/div&gt;</description>
     </item>
   
     <item>
       <title>S01C02 Write a Hello World program that can run standalone without the need for an OS</title>
       <link>https://hemashushu.github.io/posts/2022-11-06-s01c02-write-a-bare-metal-program-run-alone-without-os/</link>
       <pubDate>Sun, 06 Nov 2022 00:00:00 +0000</pubDate>
       
       <guid>https://hemashushu.github.io/posts/2022-11-06-s01c02-write-a-bare-metal-program-run-alone-without-os/</guid>
       <description>&lt;div&gt;    &lt;img src=&#34;https://hemashushu.github.io/images/subscribe-and-donate.en.png&#34; class=&#34;block-image image-480px&#34;/&gt;&lt;/div&gt;</description>
     </item>
   
     <item>
       <title>S01C01 What is cross-compilation? Let&#39;s cross-compile and run the first program</title>
       <link>https://hemashushu.github.io/posts/2022-11-05-s01c01-cross-compile-and-run-the-first-program/</link>
       <pubDate>Sat, 05 Nov 2022 00:00:00 +0000</pubDate>
       
       <guid>https://hemashushu.github.io/posts/2022-11-05-s01c01-cross-compile-and-run-the-first-program/</guid>
       <description>&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;p&gt;This is the first chapter of series &lt;em&gt;Dive into RISC-V system, step by step&lt;/em&gt;. In this series, we will learn the basic principles of programs, including how they are constructed, the structure of program files, how programs run, how software and hardware communicate, and how assembly language is converted into instructions. In the latter part of this series, we will implement a RISC-V assembler and linker, as well as a custom RISC-V assembly language and linker script language. With the assembler and linker, we will have the ability to generate programs (binary executable files), making it possible for us to create our own tools from scratch.&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;In the first chapter of &lt;em&gt;Linkers &amp;amp; Loaders&lt;/em&gt; by John R. Levine, it is mentioned that &amp;ldquo;all the linker writers in the world could probably fir in on root&amp;rdquo;. Perphaps after we finish this series, we may aslo be able to squeeze into this room .&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;I will be using &lt;a href=&#34;https://www.rust-lang.org/&#34;&gt;Rust&lt;/a&gt; to write the assembler and script parser for this series. While many articles, tutorials and projects related to compiler and system programming often use C as the programming language. Rust provides a better option in this era. Using Rust is not just to keep up with the trend, but also to avoid low-level errors and reduce frustration in the learning and development process, which is especially important for beginners in system programming. Additionally, Rust has a convenient toolchain, like many modern languages, which allows us to focus on development and reduce some repetitive work. However, in the chapters that discuss basic principles, I will still use C language since it is very straightforward and can correspond well with low-level technology.&lt;/p&gt;&lt;p&gt;You may be wondering, &amp;ldquo;Why don&amp;rsquo;t we jump right in and start by writing a language, an operation system, or a CPU?&amp;rdquo; While I understand the eagerness to dive into these ambitious projects. it&amp;rsquo;s not a feasible approach. These projects have a high starting point. If you attempt to learn or practice directly from them, you will encounter many new concepts, which will lead to even more new concepts. Eventually, you may become overwhelmed by too many incomprehensible things. Of course, there are many paths to exploration and learning, but after stumbling around for a while, you will likely return to this starting point, which is like a beginner&amp;rsquo;s village in system programming. To avoid unnecessary detours, it&amp;rsquo;s best to begin your exploration journey here.&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Many beginners often ask questions like &amp;ldquo;How does the CPU work?&amp;rdquo; or &amp;ldquo;How to write an operating system?&amp;rdquo; Unfortunately, these questions are too &amp;ldquo;huge&amp;rdquo; to receive satisfactory answers. Such questions are akin to asking &amp;ldquo;Why can a battery light up a bulb?&amp;rdquo; or &amp;ldquo;Why does a magnet attract iron?&amp;rdquo; Initially, these questions may seem simple, but as you go deeper, new questions keep arising, leading to knowledge gaps that are difficult to fill.&lt;/p&gt;&lt;/blockquote&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&#34;#1-preface&#34;&gt;1. Preface&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#2-what-is-cross-compilation&#34;&gt;2. What is cross-compilation?&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#3-gcc-compiler&#34;&gt;3. GCC compiler&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#4-cross-compiling-your-first-program&#34;&gt;4. Cross-compiling your first program&lt;/a&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&#34;#41-creating-the-hello-world-program&#34;&gt;4.1 Creating the &amp;ldquo;Hello, World!&amp;rdquo; program&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#42-cross-compiling&#34;&gt;4.2 Cross-compiling&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#43-the-elf-format&#34;&gt;4.3 The ELF format&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#5-executing&#34;&gt;5. Executing&lt;/a&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&#34;#51-installing-qemu&#34;&gt;5.1 Installing QEMU&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#52-trying-to-run-the-program&#34;&gt;5.2 Trying to run the program&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#53-specify-the-dynamic-linker-path&#34;&gt;5.3 Specify the dynamic linker path&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#54-compiling-program-as-statically-linked-type&#34;&gt;5.4 Compiling program as statically linked type&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#55-modify-the-interpreter-of-program&#34;&gt;5.5 Modify the interpreter of program&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#6-phased-compilation&#34;&gt;6. Phased compilation&lt;/a&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&#34;#61-preprocessing&#34;&gt;6.1 Preprocessing&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#62-compilation&#34;&gt;6.2 Compilation&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#63-assembly&#34;&gt;6.3 Assembly&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#64-linking&#34;&gt;6.4 Linking&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#7-general-compilation-parameters&#34;&gt;7. General compilation parameters&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#8-conclusion&#34;&gt;8. Conclusion&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;!-- raw HTML omitted --&gt;&lt;h2 id=&#34;1-preface&#34;&gt;1. Preface&lt;/h2&gt;&lt;p&gt;To understand how programs are constructed, we can use some existing and widely used tools, such as compilers and debuggers. At the same time, to implement a relatively complete compiler within one person&amp;rsquo;s capabilities, this series will focus on the relatively simple and low-threshold RISC-V architecture as the research and practice object. Of course, most of the computers we use today are based on the &lt;em&gt;x86_64&lt;/em&gt; or &lt;em&gt;ARM&lt;/em&gt; architecture. Therefore, to build RISC-V programs, we need to start with &lt;em&gt;cross-compilation&lt;/em&gt;.&lt;/p&gt;&lt;h2 id=&#34;2-what-is-cross-compilation&#34;&gt;2. What is cross-compilation?&lt;/h2&gt;&lt;p&gt;&lt;em&gt;Cross-compilation&lt;/em&gt; is the process of compiling an application on one computer to run on another computer with a different architecture or operating system. For example, compiling an application on a computer to run on a mobile phone, compiling a Windows application on a Linux system, compiling a Linux application for the &lt;em&gt;RISC-V&lt;/em&gt; architecture on an &lt;em&gt;x86_64&lt;/em&gt; architecture machine.&lt;/p&gt;&lt;p&gt;In other word, cross-compilation occurs when &amp;ldquo;the environment in which the compiler runs&amp;rdquo; is different from &amp;ldquo;the environment in which the generated program runs&amp;rdquo;. The target environment includes two main elements: the &lt;em&gt;target architecture&lt;/em&gt; and the &lt;em&gt;target platform&lt;/em&gt;.&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;The &lt;em&gt;target architecture&lt;/em&gt; refers to the CPU instruction set architecture (ISA), such as the x86_64 instruction set of Intel and AMD CPUs, and the A64 instruction set used by popular mobile phones.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;The &lt;em&gt;target platform&lt;/em&gt; refers to the type of operating system, such as Linux, Windows, and Darwin/macOS.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;The working principles and processes of both &lt;em&gt;native compilation&lt;/em&gt; (ordinary compilation) and &lt;em&gt;cross-compilation&lt;/em&gt; are exactly the same. Both aim to translate high-level languages into machine instructions (assembly code) for the target environment. So the term &lt;em&gt;cross-compilation&lt;/em&gt; does not refer to a specific function, but is just used to describe a situation where the compilation environment is different from the runtime environment.&lt;/p&gt;&lt;figure class=&#34;wide&#34;&gt;&lt;img src=&#34;./images/compilation-comparasion.png&#34;         alt=&#34;Compilation Comparation&#34;/&gt;&lt;figcaption&gt;            &lt;p&gt;Compilation Comparation&lt;/p&gt;        &lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;Of course, when developing programs, in addition to considering the target architecture and target platform, more detailed information may need to be considered. For example, when developing Linux applications, subtle differences between different distributions need to be considered. However, for the compiler, it only cares about the target archiecture and target platform.&lt;/p&gt;&lt;p&gt;It&amp;rsquo;s worth nothing that there are programs that do not require an operating system and can run independently, called &lt;em&gt;freestanding&lt;/em&gt; or &lt;em&gt;bare-metal&lt;/em&gt; programs, such as firmwares running on the microcontrollers (MCUs) and the kernel. When compiling such programs, only the &lt;em&gt;target architecture&lt;/em&gt; needs to be specified, and the &lt;em&gt;target platform&lt;/em&gt; does not need to be specified.&lt;/p&gt;&lt;p&gt;Cross-compilation serves two main purposes:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;First, it facilitates the generation of program files (binary executable files) for different target envvironments. If an application needs to be released on multiple platforms, cross-compilation can be used to generate the required program files with just a few steps for each update. Without cross-compilation, the source code would need to be copied to each target enviroment and then compiled, which would be tedious and time-consuming.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Second, and most importantly, some target environments cannot run a compiler at all. For example, microcontrollers typically have limited resources, there is usually only tens of KiB of RAM and a few hundred KiB of flash, and cannot run a full set of compiler tools. You would not expect your smart oven or toilet to run compiler. In this case, cross-compilation can be used to generate programs.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;The target instruction set of the compiler to be implemented in this series is &lt;em&gt;riscv64gc&lt;/em&gt;, which is also a cross-compiler.&lt;/p&gt;&lt;h2 id=&#34;3-gcc-compiler&#34;&gt;3. GCC compiler&lt;/h2&gt;&lt;p&gt;The mainstream compilers currently in use are GCC and LLVM, both of which are open source and free. However, GCC is more commonly used in the field of microcontrollers, which will be used in the later chapters discussing the principles of software and hardware communication. Therefore, for simplicity, only GCC will be discussed below.&lt;/p&gt;&lt;p&gt;In addition to the compiler, the binary tool Binutils, debugging tool GDB, standard libraries, and kernel headers are often used when developing programs, collectively known as the GNU Toolchain. The GNU Toolchain can be easily installed through package managers in most Linux distributions. Depending on the compilation target, the names of the packages in the toolchain will also be different. For example, in Arch Linux, the RISC-V GNU Toolchain package names name:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;riscv64-linux-gnu-binutils&lt;/li&gt;&lt;li&gt;riscv64-linux-gnu-gcc&lt;/li&gt;&lt;li&gt;riscv64-linux-gnu-gdb&lt;/li&gt;&lt;li&gt;riscv64-linux-gnu-glibc&lt;/li&gt;&lt;li&gt;riscv64-linux-gnu-linux-api-headers&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;In addition, there are packages for compiling RISC-V bare-metal programs:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;riscv64-elf-binutils&lt;/li&gt;&lt;li&gt;riscv64-elf-gcc&lt;/li&gt;&lt;li&gt;riscv64-elf-gdb&lt;/li&gt;&lt;li&gt;riscv64-elf-newlib&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Package names may vary in different Linux distributions. For example, in &lt;em&gt;Debian&lt;/em&gt;/&lt;em&gt;Ubuntu&lt;/em&gt;, the package names are:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;binutils-riscv64-linux-gnu&lt;/li&gt;&lt;li&gt;gcc-riscv64-linux-gnu&lt;/li&gt;&lt;li&gt;binutils-riscv64-unknown-elf&lt;/li&gt;&lt;li&gt;gcc-riscv64-unknown-elf&lt;/li&gt;&lt;li&gt;gdb-multiarch&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;If the RISC-V GNU Toolchain is not available in your system&amp;rsquo;s package repository, you can &lt;a href=&#34;https://github.com/riscv-collab/riscv-gnu-toolchain&#34;&gt;download the source code&lt;/a&gt; and install it from the source code.&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Unless otherwise specified, all operations in this series of articlles are completed in the Linux environment. While it is possible to operate on other systems, it is recommended to use Linux if one is determined to learn system programming in depth. In addition to being more convenient, the Linux system is like an open library full of treasures, and it would be a shame not to take advantage of the treasures at your fingertips.&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&#34;4-cross-compiling-your-first-program&#34;&gt;4. Cross-compiling your first program&lt;/h2&gt;&lt;p&gt;The &amp;ldquo;Hello, World!&amp;rdquo; program is a staple of the programming world, and it is a natural first step for learning cross-compilation.&lt;/p&gt;&lt;h3 id=&#34;41-creating-the-hello-world-program&#34;&gt;4.1 Creating the &amp;ldquo;Hello, World!&amp;rdquo; program&lt;/h3&gt;&lt;p&gt;Create a file named &lt;code&gt;app.c&lt;/code&gt; anywhere with the following contents:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;) {&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;printf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Hello, World!&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The program is very simple: print the text &amp;ldquo;Hello, World!&amp;rdquo; to the screen then exit the program with a return value of 0.&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;After program exits, it returns an integer to the caller, which is called the &lt;em&gt;exit code&lt;/em&gt;, It is a &lt;code&gt;uint32&lt;/code&gt; number. It should be noted that in the Linux environment, only the least significant 8 bits of the number are valid. Therefore, the valid range of exit code is from 0 to 255. If a negative number is returned, it will be returned in &lt;a href=&#34;https://en.wikipedia.org/wiki/Two%27s_complement&#34;&gt;Two&amp;rsquo;s complement&lt;/a&gt; form. For example, &lt;code&gt;-10&lt;/code&gt; is represented in binary as &lt;code&gt;0000,1010&lt;/code&gt; and in Two&amp;rsquo;s complement as &lt;code&gt;1111,0101 + 1 = 1111,0110&lt;/code&gt;, which corresponds to decimal &lt;code&gt;246&lt;/code&gt;.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;In the Linux environment, it is a convention to return 0 when the program exits successfully and a non-zero value when it fails. It&amp;rsquo;s worth nothing that this is exactly the opposite of the &lt;em&gt;Boolean&lt;/em&gt; value convention in most programming languages, Therefore, when writing shell scripts, one should be careful that the &lt;code&gt;true&lt;/code&gt; value in shell script is 0. In the shell, you can check the exit code of the previous program with the command &lt;code&gt;echo $?&lt;/code&gt;. For example, running the command &lt;code&gt;true; echo $?&lt;/code&gt; will display the number 0.&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;I will create a folder called &lt;code&gt;resources&lt;/code&gt; in the directory of each article. This folder will contain all the source code for the examples in that article. You can download them from &lt;a href=&#34;https://github.com/hemashushu/hemashushu.github.io/tree/main/src/content/posts&#34;&gt;my blog&amp;rsquo;s Github repository&lt;/a&gt; if you need it.&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 id=&#34;42-cross-compiling&#34;&gt;4.2 Cross-compiling&lt;/h3&gt;&lt;p&gt;The programs for compiling, assembling, and linking in the GNU Toolchain are &lt;code&gt;gcc&lt;/code&gt;, &lt;code&gt;as&lt;/code&gt; and &lt;code&gt;ld&lt;/code&gt;. If you are processing a native compile, simply enter the program names. When cross-compiling, you need to add a prefix to the program name. For example, the prefix is &lt;code&gt;riscv64-linux-gnu-&lt;/code&gt; when the target envirtonment is RISC-V and Linux.&lt;/p&gt;&lt;p&gt;To cross-compile the &amp;ldquo;Hello, World!&amp;rdquo; program, run the following command:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ riscv64-linux-gnu-gcc -g -Wall -o app.elf app.c&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The meanings of each parameters are:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;-g&lt;/code&gt;: Used to generate debugging information for use by GDB. The debugging information includes variable names, the location (line number) of instructions in the source code, etc. The debugging information is kept in the output file. Although we don&amp;rsquo;t need debugging information in this example, it is good practice to include the &lt;code&gt;-g&lt;/code&gt; parameter when compiling code in general.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;-Wall&lt;/code&gt;: Reports all warning messages generated during the compilation process, such as &amp;ldquo;declaring a local variable without using it&amp;rdquo;, or &amp;ldquo;assigning a value to a variable without ever reading it&amp;rdquo;. These warning messages are helpful in writing good code. Another similar parameter is &lt;code&gt;-Wextra&lt;/code&gt;, which reports extra warning messages other than &lt;code&gt;-Wall&lt;/code&gt;, such as &amp;ldquo;comparing &lt;code&gt;int&lt;/code&gt; type and &lt;code&gt;unsigned int&lt;/code&gt; type variables. For a detailed list, see &lt;a href=&#34;https://gcc.gnu.org/onlinedocs/gcc/Warning-Options.html&#34;&gt;GCC 3.8 Options to Request or Suppress Warnings&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote&gt;&lt;p&gt;Sometimes, when compiling old source code, errors may be reported and the compilation process may be terminated. However, an old version of GCC can successfully complete the compilation. This is because the new version of GCC introduces new error checking rules, or some rules that only warned in the old version but are now treated as errors. If you cannot modify the source code, you can temporarily disable the rules by adding &lt;code&gt;-Wno-error=...&lt;/code&gt; parameter to the GCC command. For example, &lt;code&gt;-Wno-error=int-conversion&lt;/code&gt; allows pointer types to be assigned to integer variables or passed to integer parameters. Conversely, you can specify the &lt;code&gt;-Werror=...&lt;/code&gt; parameter to promote some rules from the warning level to the error level. This can help catch potential issues early in the development process and prevent them from causing problems later on.&lt;/p&gt;&lt;/blockquote&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;-o app.elf&lt;/code&gt;: Specifies the name of the output file. If this parameter is omitted, the default output file name is &lt;code&gt;a.out&lt;/code&gt;. Note that &lt;code&gt;-o app.elf&lt;/code&gt; is a complete parameter, and the &lt;code&gt;app.c&lt;/code&gt; that follows it is not part of this parameter.&lt;/li&gt;&lt;/ul&gt;&lt;blockquote&gt;&lt;p&gt;In the Linux system, the file extension of an executable file can be anything, unlike in the Windows system where the file extension of an executable file must be &lt;code&gt;exe&lt;/code&gt;. This means that the output file can have any file extension or no extension at all, as long as it is marked as executable using the &lt;code&gt;chmod&lt;/code&gt; command or other means.&lt;/p&gt;&lt;/blockquote&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;app.c&lt;/code&gt;: The name of the source code file.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;The &lt;code&gt;app.elf&lt;/code&gt; file is generated when compiling complete.&lt;/p&gt;&lt;h3 id=&#34;43-the-elf-format&#34;&gt;4.3 The ELF format&lt;/h3&gt;&lt;p&gt;The ELF (&lt;em&gt;Executable and Linkable Format&lt;/em&gt;) format is one of the formats for binary executable files, and &lt;code&gt;app.elf&lt;/code&gt; generated in the previous step is a file in ELF format. To check the format information of the output file, you can use the following command:&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ file app.elf&lt;/code&gt;&lt;/p&gt;&lt;p&gt;The output result is roughly as follows:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;app.elf: ELF 64-bit LSB pie executable, UCB RISC-V, RVC, double-float ABI, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux-riscv64-lp64d.so.1, BuildID[sha1]=afe0994d7df77dc817058ae17e814d8f0a4163ed, for GNU/Linux 4.15.0, with debug_info, not stripped&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Here are the meanings of some of the content in the above text:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;ELF&lt;/code&gt; and &lt;code&gt;execuable&lt;/code&gt;: Indicates that the current file is an &lt;em&gt;executable file&lt;/em&gt; in the &lt;em&gt;ELF file format&lt;/em&gt;. There are three types of ELF format:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;executable&lt;/code&gt;: Which is the most common type. Note that in Linux systems, some executable files are not in ELF format, they are just script files with executable permissions, and their contents are text rather than binary.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;shared object&lt;/code&gt;: Which is shared library used for dynamic linking during runtime. The bunch of &amp;ldquo;*.so&amp;rdquo; files in the directories &lt;code&gt;/lib&lt;/code&gt; and &lt;code&gt;/usr/lib&lt;/code&gt; are this type.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;relocatable&lt;/code&gt;: Which is a file generated during the compilation process. The GCC compilation command in the previous step roughly did two things behind the scenes: the first is converting the C source code into a series of machine instructions and saved them in a relocatable file, which is called &lt;em&gt;compiling&lt;/em&gt;; The second is linking one or more relocatable files into an executable file or shared library, which is called &lt;em&gt;linking&lt;/em&gt;.&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;dynamically linked&lt;/code&gt;, &lt;code&gt;interpreter&lt;/code&gt;: Indicates that the current executable file is the &lt;em&gt;dynamically linked&lt;/em&gt; type, which means that it needs the help of other shared libraries to complete its work during runtime. The loading and initialization tasks of these libraries are completed by a program called &lt;em&gt;interpreter&lt;/em&gt;, which is also called the &lt;em&gt;runtime dynamic linker&lt;/em&gt;. This program is usually &lt;code&gt;/usr/bin/id.so&lt;/code&gt; (although the extension is &lt;code&gt;so&lt;/code&gt;, which looks like a shared library, it it actually an executable file. The reason why &lt;code&gt;so&lt;/code&gt; suffix is added is probably to distinguish it from the statically linked program &lt;code&gt;ld&lt;/code&gt;). The executable file can also be the &lt;em&gt;statically linked&lt;/em&gt; type, which does not need the help of other shared libraries during runtime and can complete all work by itself.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;pie&lt;/code&gt;: Indicates that the current executable file is a &lt;em&gt;position independent executables&lt;/em&gt;, which will be explained in detail later.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;64-bit, RISC-V, double-float ABI, GNU/Linux 4.15.0&lt;/code&gt;: These pieces of information indicate the target architecture, target platform, and some detailed information of the target environment.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;LSB&lt;/code&gt;: Indicates that the data in the current file is &lt;em&gt;least significant byte&lt;/em&gt; first, which is commonly known as &lt;em&gt;little-endian&lt;/em&gt;. The opposite of LSB is MSB, which is &lt;em&gt;most significant byte&lt;/em&gt; first, commonly known as &lt;em&gt;bit-endian&lt;/em&gt;. Byte order determines how an integer (such as &lt;code&gt;int32&lt;/code&gt; and &lt;code&gt;int64&lt;/code&gt;, which must be composed of multiple bytes) is stored in memory or on disk. For example, if the number &lt;code&gt;0x11223344&lt;/code&gt; is stored in memory using LSB, the order of each byte is &amp;ldquo;(start) 44 33 22 11&amp;rdquo;, and if it is stored using MSB, the order is &amp;ldquo;(start) 11 22 33 44&amp;rdquo;. When viewing the contents of an executable file with a hexadecimal viewer that uses LSB byte order, the order of each byte of an integer number needs to be reversed to get its true value, while text content can be read directly.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;with debug_info, not stripped&lt;/code&gt;: Indicates that the current executable file contains debug information.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;The &lt;code&gt;file&lt;/code&gt; command can only roughly view the format and basic information of a file. If you want to view the detailed contents of an executable file, you need a set of tools in the GNU Toolchain called &lt;a href=&#34;https://www.gnu.org/software/binutils/&#34;&gt;GNU Binutils&lt;/a&gt;, which will be explained in detail in later sections.&lt;/p&gt;&lt;h2 id=&#34;5-executing&#34;&gt;5. Executing&lt;/h2&gt;&lt;p&gt;If you try to run the &lt;code&gt;app.elf&lt;/code&gt; compiled above directly, you will find that it cannot run property. This is because the target architecture of the executable file is RISC-V (assuming that your current machine is not RISC-V architecture). To run the program, a convenient method is to use an emulator software to simulate a RISC-V machine.&lt;/p&gt;&lt;p&gt;The generally well-known &lt;em&gt;virtualization software&lt;/em&gt;, such as VirtualBox and VMWare, can only virtualize a machine with the same architecture as the host machine. This is because the virtual processor provided by these software is actually provided by the CPU hareware of the host. If you need to virtualize a machine with a different architecture, you need to use an emulator software, such as &lt;a href=&#34;https://www.qemu.org/&#34;&gt;QEMU&lt;/a&gt;. The emulator uses software to simulate the target CPU, and then simulates some peripherals such as network interfaces, graphics interfaces, and solid-state storage drivers to ultimately create a virtual machine.&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Note that the term &amp;ldquo;Virtual Machine (VM)&amp;rdquo; is also often used in the runtime of programming languages, which is a concept closer to the emulator. A VM simulates an idealized processor (which is unrelated to the host processor) during runtime, and allows the processor to execute bytecode compiled from specific programming languages. Unlike an emulator, the VM only simulates the processor, and all the system calls and the hardware access are redirected to the host, so the VM is not a complete machine.&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 id=&#34;51-installing-qemu&#34;&gt;5.1 Installing QEMU&lt;/h3&gt;&lt;p&gt;QEMU is an open-source and free software that is included in most Linux distribution&amp;rsquo;s package repositories. So you can install QEMU using your system&amp;rsquo;s package manager. In &lt;em&gt;Arch Linux&lt;/em&gt;, the packages are:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;qemu-system-riscv&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;qemu-user&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;qemu-user-static&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;In &lt;em&gt;Debian&lt;/em&gt;/&lt;em&gt;Ubuntu&lt;/em&gt;, the packages are:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;qemu-system&lt;/li&gt;&lt;li&gt;qemu-user&lt;/li&gt;&lt;li&gt;qemu-user-static&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;For distributions that do not have QEMU in their package repositories, you can download the QEMU source code and compile and install it according to &lt;a href=&#34;https://wiki.qemu.org/Documentation/Platforms/RISCV&#34;&gt;this guide&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;QEMU can simmulate a complete set of hardware, including CPU, memory, hard disk driver, network interfaces and other components. All CPU instructions can be executed, and bare-metal programs can be run in this mode, this mode is called &lt;em&gt;full system mode&lt;/em&gt;. In addition, QEMU can also simulate an independent Linux system. Linux applications compiled for different architecture can be run directly in this mode, this mode is called &lt;em&gt;user mode&lt;/em&gt;. In this mode, QEMU dynamically translates the instructions in the application into the instructions of the host architecture, as well as redirect the system calls.&lt;/p&gt;&lt;p&gt;To start the &lt;em&gt;full system mode&lt;/em&gt;, use the program &lt;code&gt;qemu-system-riscv64&lt;/code&gt; and specify the machine type, the number of CPU cores, the amount of memory, and the virtual disk configuration through command parameters. To start the &lt;em&gt;user mode&lt;/em&gt;, use the program &lt;code&gt;qemu-riscv64&lt;/code&gt; and pass the file path of the application (executable file) as a parameter.&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;QEMU is created by a legendary programmer &lt;a href=&#34;https://bellard.org/&#34;&gt;Fabrice Bellard&lt;/a&gt;, who also wrote &lt;a href=&#34;http://ffmpeg.org/&#34;&gt;FFmpeg&lt;/a&gt;. FFmpeg exists on almost every computer and mobile phone (although many people may not know it), since most media player software and video editing software rely on it. He also wrote TCC, QuickJS and other notable programs.&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 id=&#34;52-trying-to-run-the-program&#34;&gt;5.2 Trying to run the program&lt;/h3&gt;&lt;p&gt;If you want to run the above &amp;ldquo;Hello, World!&amp;rdquo; program in QEMU full system mode, you need to configure a RISC-V system with bootloader, a virtual disk and install a Linux system, and copy the program into the virtual machine. for simplicity, we will run the program in the user mode:&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ qemu-riscv64 app.elf&lt;/code&gt;&lt;/p&gt;&lt;p&gt;The result of the command is:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;qemu-riscv64: Could not open &amp;#39;/lib/ld-linux-riscv64-lp64d.so.1&amp;#39;: No such file or directory&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Obviously, the program did not run correctly. By default, GCC produces dynamically linked programs, which require a &lt;em&gt;runtime dynamic linker&lt;/em&gt; to load the shared libraries required by the program. The runtime dynamic linker is the program &lt;code&gt;ld.so&lt;/code&gt;, which is the &lt;code&gt;/lib/ld-linux-riscv64-lp64d.so.1&lt;/code&gt; shown in the error message in this example.&lt;/p&gt;&lt;p&gt;The program produced by GCC is assumed to run in a &amp;ldquo;normal Linux system&amp;rdquo;, while we are currently in a special environment called QEMU user mode. From the perspective of the &amp;ldquo;Hello, World!&amp;rdquo; program, it does not know that it is running in a specical environment and assumes that it is running in a Linux system based on the RISC-V architecture. Therefore, it searches for the dynamic linker &lt;code&gt;/lib/ld-linux-riscv64-lp64d.so.1&lt;/code&gt; as usual. In reality, the current environment (the author&amp;rsquo;s machine) is running the &lt;em&gt;x86_64&lt;/em&gt; version of Linux, and the dynamic linker is &lt;code&gt;/lib/ld-linux-x86-64.so.2&lt;/code&gt;. QEMU user mode only translates CPU instructions and does not convert other data such as file paths, so the program fails to run.&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;You may have noticed that &lt;code&gt;./app.elf&lt;/code&gt; can be executed directly, and the error message produced are the same. This is because the Linux kernel supports programs which require interpreters through the &lt;a href=&#34;https://www.kernel.org/doc/html/latest/admin-guide/binfmt-misc.html&#34;&gt;MISC binary&lt;/a&gt; feature. Check the file &lt;code&gt;/proc/sys/fs/binfmt_misc/qemu-riscv64&lt;/code&gt;, it shows when you run &lt;code&gt;./app.elf&lt;/code&gt; from the command line, the actually command &lt;code&gt;/usr/bin/qemu-riscv64-static ./app.elf&lt;/code&gt; is executed. &lt;code&gt;qemu-riscv64-static&lt;/code&gt; is the same as &lt;code&gt;qemu-riscv64&lt;/code&gt; above, except that it is itself statically linked.&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 id=&#34;53-specify-the-dynamic-linker-path&#34;&gt;5.3 Specify the dynamic linker path&lt;/h3&gt;&lt;p&gt;You will find that the file &lt;code&gt;ld-linux-riscv64-lp64d.so.1&lt;/code&gt; does exist if your system is &lt;em&gt;Arch Linux&lt;/em&gt; and the package &lt;code&gt;riscv64-linux-gnu-glibc&lt;/code&gt; is installed, but the path is &lt;code&gt;/usr/riscv64-linux-gnu/lib/ld-linux-riscv64-lp64d.so.1&lt;/code&gt; instead of &lt;code&gt;/lib/ld-linux-riscv64-lp64d.so.1&lt;/code&gt;. According to the manual of &lt;code&gt;qemu-riscv64&lt;/code&gt;, you can pass a path as a parameter using the &lt;code&gt;-L&lt;/code&gt; options or setting the &lt;code&gt;QEMU_LD_PREFIX&lt;/code&gt; environment variable, then QEMU will add this path as a prefix to the ELF&amp;rsquo;s &lt;code&gt;interpreter&lt;/code&gt; path.&lt;/p&gt;&lt;p&gt;Therefore, you can run the &lt;code&gt;app.elf&lt;/code&gt; program as follows:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;$ qemu-riscv64 -L /usr/riscv64-linux-gnu/ app.elf&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;$ QEMU_LD_PREFIX=/usr/riscv64-linux-gnu/ qemu-riscv64 app.elf&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Both commands can run correctly, and you should see the &amp;ldquo;Hello, World!&amp;rdquo; text output by the program.&lt;/p&gt;&lt;p&gt;&lt;img src=&#34;./images/qemu-user.png&#34; alt=&#34;QEMU User Mode&#34;&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;On Linux, you can use the &lt;code&gt;locate&lt;/code&gt; command to quickly find the location of files. For example, the command &lt;code&gt;$ locate lp64d.so.1&lt;/code&gt; will show you the path to the dynamic linker.&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 id=&#34;54-compiling-program-as-statically-linked-type&#34;&gt;5.4 Compiling program as statically linked type&lt;/h3&gt;&lt;p&gt;In addition to running programs by specifying the path of dynamic linker in QEMU user mode, there is another method: generating statically linked executable files using GCC.&lt;/p&gt;&lt;p&gt;A statically linked program copies the binary code of external functions into the target executable file during compilation. In this way, the program does not need any shared libraries at runtime, and it does not need the dynamic linker &lt;code&gt;ld.so&lt;/code&gt; either. The GCC compiler generates a statically linked program by adding the &lt;code&gt;-static&lt;/code&gt; option. The modified compile command is as follows:&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ riscv64-linux-gnu-gcc -static -o app-static.elf app.c&lt;/code&gt;&lt;/p&gt;&lt;p&gt;Next, check the file format using the &lt;code&gt;file&lt;/code&gt; command:&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ file app-static.elf&lt;/code&gt;&lt;/p&gt;&lt;p&gt;Part of the output is as follows:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;app-static.elf: ... statically linked ...&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;It shows that the original &amp;ldquo;dynamically linked&amp;rdquo; program has become &amp;ldquo;statically linked&amp;rdquo;.&lt;/p&gt;&lt;p&gt;Then run this program with &lt;code&gt;qemu-riscv64&lt;/code&gt;:&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ qemu-riscv64 app-static.elf&lt;/code&gt;&lt;/p&gt;&lt;p&gt;The program can run correctly without needing the &lt;code&gt;-L&lt;/code&gt; option or setting the &lt;code&gt;QEMU_LD_PREFIX&lt;/code&gt; environment variable. Actually the statically linked programs completely ignore the file system unless they need to read or write files.&lt;/p&gt;&lt;p&gt;Since statically linked programs are so portable and convenient to use, why not compile all programs as statically linked? Let&amp;rsquo;s compare the file sizes of the same &amp;ldquo;Hello, World!&amp;rdquo; program in dynamically linked and statically linked types:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ ls -lh&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;total 668K&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-rw-r--r-- 1 yang yang   78 Nov 26 04:00 app.c&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-rwxr-xr-x 1 yang yang 9.8K Nov 27 13:38 app.elf&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-rwxr-xr-x 1 yang yang 645K Nov 27 21:40 app-static.elf&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The result shows that the size of the dynamically linked program is &lt;code&gt;9.8K&lt;/code&gt;, while the size of the statically linked program is &lt;code&gt;645K&lt;/code&gt;, which is much larger than the former.  This is because the compiler copies all the binary code of the functions requried by the &lt;code&gt;printf&lt;/code&gt; function directly or indirectly into the target executable file. Statically linked programs not only have a larger file size, but also take longer to load and occupy more memory at runtime. On the other hand, the shared libraries are only loaded once and shared with all applications using memory mapping. So the dynamically linked programs load faster and occupy less memory. When a program depends on more libraries, the difference between these two types will be more significant.&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;em&gt;Dynamically linking&lt;/em&gt; is a good idea for systems, However it also brings some headaches. In daily use experience with Linux, few programs that can be downloaded and run directly. In most cases, errors such as missing or mismatched shared libraries will occur. If you want to install a program that does not exist in the package repository, you can only install it by compiling the source code. This is too difficult for non-professional users. The author believes that this problem is caused by an excessive use of shared libraries. Many small and non-essential libraries should not be global shared libraries.&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;The operating system that is being implemented will completely prohibit users from adding global shared libraries to the system. Global shared libraries are limited to very general and essential libraries, and they should be maintained by the kernel maintainers. Applications should also be isolated from each other, the shared libraries provided by a program can only be used by the program itself and its child programs. This mechanism fundamentally solves the portability problem caused by global share libraries, reduces the troubles of application deployment, and make application updates more effective and timely, eliminating the need for third-party maintainers.&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 id=&#34;55-modify-the-interpreter-of-program&#34;&gt;5.5 Modify the interpreter of program&lt;/h3&gt;&lt;p&gt;To make the &amp;ldquo;Hello, World!&amp;rdquo; program run correctly, you can also modify the dynamic linker of a program by passing the &lt;code&gt;--dynamic-linker&lt;/code&gt; option to the GCC compiler, and the value of &lt;code&gt;interpreter&lt;/code&gt; of the program will be updated. For example:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ riscv64-linux-gnu-gcc -g -Wall -Wl,--dynamic-linker,/usr/riscv64-linux-gnu/lib/ld-linux-riscv64-lp64d.so.1 -o app-inter.elf app.c -L /usr/riscv64-linux-gnu/lib -lc&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The &lt;code&gt;-Wl,--dynamic-linker,...&lt;/code&gt; option in the command is used to pass parameters to the linker; the &lt;code&gt;-L&lt;/code&gt; option is used to specify the path for the linker to search for shared libraries; the &lt;code&gt;-lc&lt;/code&gt; option is used to specify the &lt;code&gt;libc.so&lt;/code&gt; shared library to link. These options will be explained in detail in later sections.&lt;/p&gt;&lt;p&gt;When compilation is completed, check the program using the &lt;code&gt;file&lt;/code&gt; command:&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ file app-inter.elf&lt;/code&gt;&lt;/p&gt;&lt;p&gt;Part of the output is:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;app-inter.elf: ... interpreter /usr/riscv64-linux-gnu/lib/ld-linux-riscv64-lp64d.so.1 ...&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;It shows that the &lt;code&gt;interpreter&lt;/code&gt; of the program has been changed to the specified path. However, when running this program, a new error message appears:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ qemu-riscv64 app-inter.elf&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;app-inter.elf: error while loading shared libraries: libc.so.6: cannot open shared object file: No such file or directory&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;It seems that the RISC-V version of &lt;code&gt;ld.so&lt;/code&gt; works, but the dynamic linker cannot find the RISC-V version of the shared library &lt;code&gt;libc.so.6&lt;/code&gt;. This problem is easy to solve, just specify the path of the shared library that the program depends on through the &lt;code&gt;LD_LIBRARY_PATH&lt;/code&gt; environment variable, for example:&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ LD_LIBRARY_PATH=/usr/riscv64-linux-gnu/lib qemu-riscv64 app-inter.elf&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&#34;./images/interpreter-path.png&#34; alt=&#34;Interpreter Path&#34;&gt;&lt;/p&gt;&lt;p&gt;The program can also run correctly. However this method is not very useful because it is much more complicated than the first two methods, and the generated program is only suitable for running in the QEMU user mode, and cannot run in a standard RISC-V Linux system. The main purpose of this example is to demonstrate how to modify the &lt;code&gt;interpreter&lt;/code&gt; of a program. For more information about dynamic linkers, you can use the command &lt;code&gt;$ man ld.so&lt;/code&gt; to view the documentation.&lt;/p&gt;&lt;h2 id=&#34;6-phased-compilation&#34;&gt;6. Phased compilation&lt;/h2&gt;&lt;p&gt;When the command &lt;code&gt;riscv64-linux-gnu-gcc&lt;/code&gt; compiles a C source code into an executable file, GCC actually completes the process in four stages.&lt;/p&gt;&lt;figure class=&#34;wide&#34;&gt;&lt;img src=&#34;./images/gcc-compile-stage.png&#34;         alt=&#34;GCC compile stages&#34;/&gt;&lt;figcaption&gt;            &lt;p&gt;GCC compile stages&lt;/p&gt;        &lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 id=&#34;61-preprocessing&#34;&gt;6.1 Preprocessing&lt;/h3&gt;&lt;p&gt;The files specified by &lt;code&gt;#include ...&lt;/code&gt; in the source code are copied, and the conditional compilation instructions (&lt;code&gt;#ifdef&lt;/code&gt;) are parsed and the macros are expanded. This is equivalent to the command:&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ riscv64-linux-gnu-cpp app.c &amp;gt; app.i&lt;/code&gt;&lt;/p&gt;&lt;p&gt;or&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ riscv64-linux-gnu-gcc -E app.c &amp;gt; app.i&lt;/code&gt;&lt;/p&gt;&lt;p&gt;The source code file that has been preprocessed has the extension &lt;code&gt;*.i&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;Note that the &amp;ldquo;cpp&amp;rdquo; in the name of program &lt;code&gt;riscv64-linux-gnu-cpp&lt;/code&gt; stands for &amp;ldquo;C Preprocessor&amp;rdquo;, not &amp;ldquo;C++&amp;rdquo;.&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;The &lt;code&gt;-D&lt;/code&gt; parameter of the GCC compiler command is used to pass values to the C source code to control the conditional compilation instructions. For example, &lt;code&gt;-D DEBUG&lt;/code&gt; (equivalent to &lt;code&gt;-D DEBUG=1&lt;/code&gt;) can make the condition value of &lt;code&gt;#ifdef DEBUG ...&lt;/code&gt; to true. For details, please refer to &lt;a href=&#34;https://gcc.gnu.org/onlinedocs/gcc/Preprocessor-Options.html&#34;&gt;GCC Preprocessor&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 id=&#34;62-compilation&#34;&gt;6.2 Compilation&lt;/h3&gt;&lt;p&gt;The C source code is compiled into assembly code, which is equivalent to the command:&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ riscv64-linux-gnu-gcc -S app.i&lt;/code&gt;&lt;/p&gt;&lt;p&gt;The generated assembly code file has the extension name &lt;code&gt;*.s&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;Note that when we write assembly code by hand, the file extension is generally &lt;code&gt;*.S&lt;/code&gt; (capital S). &lt;code&gt;*.S&lt;/code&gt; files will be preprocessed (such as processing &lt;code&gt;.include&lt;/code&gt; instructions) during assembly, while the &lt;code&gt;*.s&lt;/code&gt; (lowercase s) files will not be preprocessed. The specific extensions and GCC parameters can be found in &lt;a href=&#34;https://gcc.gnu.org/onlinedocs/gcc/Overall-Options.html&#34;&gt;GCC Options Controlling the Kind of Output&lt;/a&gt;.&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Steps 1 and 2 can also be combined into one command: &lt;code&gt;$ riscv64-linux-gnu-gcc -S app.c&lt;/code&gt;.&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 id=&#34;63-assembly&#34;&gt;6.3 Assembly&lt;/h3&gt;&lt;p&gt;The assembly code is converted into a sequence of machine instructions, generating a &lt;em&gt;relocatable file&lt;/em&gt;, which is equivalent to the command:&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ riscv64-linux-gnu-as -o app.o app.s&lt;/code&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Steps 1 to 3 can also be combined into one command: &lt;code&gt;$ riscv64-linux-gnu-gcc -c -o app.o app.c&lt;/code&gt;. The &lt;code&gt;-c&lt;/code&gt; parameter means compile only but not link.&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 id=&#34;64-linking&#34;&gt;6.4 Linking&lt;/h3&gt;&lt;p&gt;One or more &lt;em&gt;relocatable files&lt;/em&gt; are linked together, and the address of global variables, static variables, and functions are relocated. Finally, an ELF format executable file is generated, which is equivalent to the command:&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ riscv64-linux-gnu-ld -o app.elf startup.o app.o&lt;/code&gt;&lt;/p&gt;&lt;p&gt;The above commands links the two files &lt;code&gt;startup.o&lt;/code&gt; and &lt;code&gt;app.o&lt;/code&gt; to generate the executable file &lt;code&gt;app.elf&lt;/code&gt;.&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;code&gt;startup.o&lt;/code&gt; provides the entry procedure &lt;code&gt;_start&lt;/code&gt; and performs some initialization and cleanup work. It will be implemented in the next chapter.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;These four steps represent a series of operations that occur when executing the command &lt;code&gt;$ riscv64-linux-gnu-gcc -o app.elf app.c&lt;/code&gt;. If you wish to understand each step and detail of GCC during the compilation process, you can add the &lt;code&gt;-v&lt;/code&gt; parameter to the command, like &lt;code&gt;$ riscv64-linux-gnu-gcc -v -o app.elf app.c&lt;/code&gt;. This will prompt the GCC to display each operation as it occurs.&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;In most cases, we do not need to divide the compilation process into four steps. Instead, we typically separate it into two steps: steps 1 to 3 referred to as &lt;em&gt;compilation&lt;/em&gt;, and step 4 known as &lt;em&gt;linking&lt;/em&gt;. Fenerally, building tools such as &lt;code&gt;make&lt;/code&gt; are utilized to complete these tasks. Nevertheless, it is still crucial to comprehend the stages involved in the compilation process, and this can aid in resolving various issues encountered during the compilation.&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&#34;7-general-compilation-parameters&#34;&gt;7. General compilation parameters&lt;/h2&gt;&lt;p&gt;GCC has some other commonly used parameters:&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;-I&lt;/code&gt; is used to specify the path of header files during compilation&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Sometimes header files (&lt;code&gt;*.h&lt;/code&gt;) are distributed in multiple directories. In this case, the &lt;code&gt;-I&lt;/code&gt; parameter can be used to include the additional header file paths. For example, if the current path is &lt;code&gt;/home/yang/hello-world/app.c&lt;/code&gt;, and there are additional header files located in &lt;code&gt;/home/yang/hello-world/include&lt;/code&gt;, the command can be:&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ riscv64-linux-gnu-gcc -I /home/yang/hello-world/include app.c&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;-L&lt;/code&gt; and &lt;code&gt;-l&lt;/code&gt; are used to specify the path and name of additional libraries during linking&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;For example, if a program depends on the shared library &lt;code&gt;/usr/lib/hello-world/libmymath.so&lt;/code&gt;, the command can be:&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ riscv64-linux-gnu-gcc app.c -L /usr/lib/hello-world/ -lmymath&lt;/code&gt;&lt;/p&gt;&lt;p&gt;The parameter &lt;code&gt;-lmymath&lt;/code&gt; indicates that the linking process will use the shared library &lt;code&gt;libmymath.so&lt;/code&gt;. Note that the value of the &lt;code&gt;-l&lt;/code&gt; parameter is not the file name of the library, but the &lt;em&gt;soname&lt;/em&gt; of the library. For example, the real name of shared library file in the above example is &lt;code&gt;libmymath.so&lt;/code&gt;, and the soname is obtained by removing the prefix &lt;code&gt;lib&lt;/code&gt; and the suffix &lt;code&gt;.so&lt;/code&gt;. Similarly, &lt;code&gt;-lm&lt;/code&gt; represents the shared library &lt;code&gt;libm.so&lt;/code&gt;, and &lt;code&gt;-lpthread&lt;/code&gt; represents the shared library &lt;code&gt;libpthread.so&lt;/code&gt;.&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Generally, the parameters &lt;code&gt;-L ...&lt;/code&gt; and &lt;code&gt;-l ...&lt;/code&gt; are placed at the end of command, following the order of &amp;ldquo;dependent come last&amp;rdquo;.&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;If the compilation process is separated into two stages of &lt;em&gt;compilation&lt;/em&gt; and &lt;em&gt;linking&lt;/em&gt;, then the &lt;code&gt;-I&lt;/code&gt; parameter only needs to be specified during the compilation stage. This is because header files are only used for preprocessing and are not required during linking. Similarly, the &lt;code&gt;-L&lt;/code&gt; and &lt;code&gt;-l&lt;/code&gt; parameters only need to be specified during the linking stage. This is because library files are only used during the linking process and are not required during compilatin.&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;You may have noticed that the syntax of GCC parameters is different from that regular programs. For example, the parameter &lt;code&gt;-lmymath&lt;/code&gt; is actually a shorthand for &lt;code&gt;-l mymath&lt;/code&gt;. The parameter &lt;code&gt;-static&lt;/code&gt; which should be written as &lt;code&gt;--static&lt;/code&gt; according to the standard syntax. GCC has a historical legacy.&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&#34;8-conclusion&#34;&gt;8. Conclusion&lt;/h2&gt;&lt;p&gt;In this chapter, we learned about cross-compilation and how to cross-compile a &amp;ldquo;Hello, World! program. We also used QEMU to simulate a Linux environment of a different architecture to run the cross-compile executable file. Through this process, we found that cross-compilation is not significantly different from regular compilation, but it produces an executable file that cannot be run directly on the current machine.&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;This chapter is the first in a series of articles, and some parts may be difficult to understand. However, as we progress through the series, the content will become clearer. Learning C language in the Linux environment is crucial, and taking breaks between reading chapters to allow the brain to digest the information is recommended.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;In the next chapter, we will build a simple program that can run independently without an operation system. If you feel confident in your understanding of the concepts covered in this chapter, feel free to proceed to the next chapter.&lt;/p&gt;&lt;div&gt;    &lt;img src=&#34;https://hemashushu.github.io/images/subscribe-and-donate.en.png&#34; class=&#34;block-image image-480px&#34;/&gt;&lt;/div&gt;</description>
     </item>
   
 </channel>
</rss>
