
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
 <channel>
   <title>Tags on Hemashushu&#39;s Homepage</title>
   <link>https://hemashushu.github.io/tags/</link>
   <description>Recent content in Tags on Hemashushu&#39;s Homepage</description>
   <generator>Hugo -- gohugo.io</generator>
   <language>en-us</language>
   <copyright>Copyright &amp;copy; 2022 - Hippospark</copyright>
   <lastBuildDate>Sun, 08 Jan 2023 00:00:00 +0000</lastBuildDate>
   
       <atom:link href="https://hemashushu.github.io/tags/index.xml" rel="self" type="application/rss+xml" />
   
   
     <item>
       <title>S10C02 RISC-V development using QEMU - Part 2 Build a base Linux system using Buildroot</title>
       <link>https://hemashushu.github.io/posts/2023-01-08-s10c02-risc-v-development-using-qemu-part-2-buildroot/</link>
       <pubDate>Sun, 08 Jan 2023 00:00:00 +0000</pubDate>
       
       <guid>https://hemashushu.github.io/posts/2023-01-08-s10c02-risc-v-development-using-qemu-part-2-buildroot/</guid>
       <description>&lt;p&gt;This series articles will guide you setting up a RISC-V development environment using QEMU. The series includes four parts:&lt;/p&gt;&lt;p&gt;&lt;a href=&#34;../2023-01-06-s10c01-risc-v-development-using-qemu-part-1-minimal-linux/&#34;&gt;Part 1&lt;/a&gt;. Building a minimal RISC-V Linux system with only Linux kernel and BusyBox, and runs on the QEMU emulator.&lt;/p&gt;&lt;p&gt;&lt;a href=&#34;../2023-01-08-s10c01-risc-v-development-using-qemu-part-2-buildroot&#34;&gt;Part 2&lt;/a&gt;. Building a base RISC-V Linux system with the ability of doing RISC-V assembly development and debug using Buildroot.&lt;/p&gt;&lt;p&gt;Part 3. Setting up a complete Debian RISC-V Linux system in QEMU, and do C language development and debug with GCC toolchains.&lt;/p&gt;&lt;p&gt;Part 4. Remote debugging with the GDB, and setup remote text editing and debugging by VSCode.&lt;/p&gt;&lt;hr&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&#34;#1-get-the-_buildroot_-source-code&#34;&gt;1. Get the &lt;em&gt;Buildroot&lt;/em&gt; source code&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#2-configure-_buildroot_&#34;&gt;2. Configure &lt;em&gt;Buildroot&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#3-select-packages&#34;&gt;3. Select packages&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#4-compile-_buildroot_&#34;&gt;4. Compile &lt;em&gt;Buildroot&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#5-boot-the-system&#34;&gt;5. Boot the system&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#6-check-the-system&#34;&gt;6. Check the system&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#7-create-a-non-privileged-user&#34;&gt;7. Create a non-privileged user&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#8-log-in-to-the-guest-machine-via-ssh&#34;&gt;8. Log in to the guest machine via SSH&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#9-risc-v-assembly-development&#34;&gt;9. RISC-V Assembly development&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#10-debug-program-by-gdb&#34;&gt;10. Debug program by GDB&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#11-where-is-the-gcc-toolchain&#34;&gt;11. Where is the GCC toolchain?&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#12-conclusion&#34;&gt;12. Conclusion&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;!-- raw HTML omitted --&gt;&lt;p&gt;In the previous section, we built a minimal Linux system by compiling the &lt;em&gt;Linux kernel&lt;/em&gt; and &lt;em&gt;BusyBox&lt;/em&gt;. While the system contains a base Shell environment and is capable of running static linked user programs, it is not suitable for development purposes. In theory, we could add any software, such as &lt;code&gt;ssh&lt;/code&gt;, &lt;code&gt;vim&lt;/code&gt;, &lt;code&gt;git&lt;/code&gt; or &lt;code&gt;binutils&lt;/code&gt; and so on by compiling their source codes and copying the binaries and libraries into the image file. Actually, there is a project called &lt;a href=&#34;https://www.linuxfromscratch.org/lfs/&#34;&gt;Linux From Scratch&lt;/a&gt; that guides users through building the entire Linux system from source code. Although it&amp;rsquo;s an excellent tutorial for those who want to understand how Linux system are built, it can be challenging for beginners, and the process would be tedious and time consuming.&lt;/p&gt;&lt;p&gt;In this chapter, we will use a tool called &lt;a href=&#34;https://buildroot.org/&#34;&gt;Buildroot&lt;/a&gt; to download and compile software automatically, resulting in the creation of an image file. &lt;code&gt;Buildroot&lt;/code&gt; is free and open-source, so you can check its source code if you want to know how it works.&lt;/p&gt;&lt;h2 id=&#34;1-get-the-_buildroot_-source-code&#34;&gt;1. Get the &lt;em&gt;Buildroot&lt;/em&gt; source code&lt;/h2&gt;&lt;p&gt;To get started, create a project folder in your home directory, let&amp;rsquo;s call &lt;code&gt;riscv64-buildroot&lt;/code&gt;. Once created, change into the folder and clone the &lt;a href=&#34;https://git.buildroot.net/buildroot&#34;&gt;Buildroot source code repository&lt;/a&gt; via &lt;em&gt;Git&lt;/em&gt;. After the download is complete, change into the &lt;code&gt;buildroot&lt;/code&gt; directory and check out a stable version, e.g., &lt;code&gt;2023.02&lt;/code&gt;:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ mkdir ~/riscv64-buildroot&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ cd ~/riscv64-buildroot&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ git clone https://git.buildroot.net/buildroot&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ cd buildroot&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ git checkout -b 2023.02&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;2-configure-_buildroot_&#34;&gt;2. Configure &lt;em&gt;Buildroot&lt;/em&gt;&lt;/h2&gt;&lt;p&gt;&lt;em&gt;Buildroot&lt;/em&gt; is capable of building Linux systems for various hardware platforms. You can check the &lt;code&gt;board&lt;/code&gt; directory to see a list of all platform vendors and modules. Each platform has one or more corresponding default configurations located in the &lt;code&gt;configs&lt;/code&gt; directory. Run the following command to configure a QEMU RISC-V target platform with default settings:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ make qemu_riscv64_virt_defconfig&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;You can customize the target system by changing the image file capacity, adding packages, and more by execute the &lt;code&gt;make menuconfig&lt;/code&gt; command:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ make menuconfig&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Check the following options:&lt;/p&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-conf&#34; data-lang=&#34;conf&#34;&gt;Toolchain ---&amp;gt;    * Install glibc utilities    * Enable C++ supportBuild options ---&amp;gt;    * Enable compiler cacheFilesystem images ---&amp;gt;    * ext2/3/4        * ext4    exact size        * 2048M&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Where the &lt;code&gt;image size&lt;/code&gt; option requires manual input.&lt;/p&gt;&lt;h2 id=&#34;3-select-packages&#34;&gt;3. Select packages&lt;/h2&gt;&lt;p&gt;Next, select the packages you need. Note that the option &amp;ldquo;Show packages that are also provided by busybox&amp;rdquo; must be selected first, otherwise some options will be unavailable. You can press the &lt;code&gt;/&lt;/code&gt; key at any time to search for packages by name. The following is a list of recommended packages for building a RISC-V assembly development environment.&lt;/p&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-conf&#34; data-lang=&#34;conf&#34;&gt;Target packages ---&amp;gt;    * Show packages that are also provided by busybox    Compressors and decompressors ---&amp;gt;        * bzip2        * gzip        * unzip        * xz-utils        * zip        * zstd    Debugging, profiling and benchmark ---&amp;gt;        * gdb            * gdbserver            * full debugger            * TUI support    Development tools ---&amp;gt;        * binutils            * binutils binaries        * check        * diffutils        * findutils        * flex        * gawk        * gettext        * git        * grep        * libtool        * make        * patch        * pkgconf        * sed        * tree    Hardware handling ---&amp;gt;        * kbd    Interpreter languages and scripting ---&amp;gt;        * python3            python3 module format to install ---&amp;gt;                * .py sources and .pyc compiled            External python modules                * python-pip    Libraries ---&amp;gt;        Crypto ---&amp;gt;            * CA Certificates            openssl support                ssl library ---&amp;gt;                    * openssl                openssl                    * openssl binary    Networking applications ---&amp;gt;        iputils            * ping        * openssh        * wget    Shell and utilities ---&amp;gt;        * bash        * bash completion        * file        * sudo        * time        * which    System tools        * coreutils            * Individual binaries        * htop        * shadow        * tar    Text editors and viewers ---&amp;gt;        * less        * vim        * install runtime&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Check out the &lt;a href=&#34;https://www.linuxfromscratch.org/lfs/view/stable/&#34;&gt;Linux From Scratch Book&lt;/a&gt; for a detailed explanation of each package. Once you have selected your packages, select &amp;ldquo;Save&amp;rdquo; and &amp;ldquo;Exit&amp;rdquo; to exit the configuration interface.&lt;/p&gt;&lt;h2 id=&#34;4-compile-_buildroot_&#34;&gt;4. Compile &lt;em&gt;Buildroot&lt;/em&gt;&lt;/h2&gt;&lt;p&gt;Run the &lt;code&gt;make&lt;/code&gt; command to start the package download and compilation process.&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ make -j &lt;span style=&#34;color:#66d9ef&#34;&gt;$(&lt;/span&gt;nproc&lt;span style=&#34;color:#66d9ef&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;&lt;p&gt;The &lt;code&gt;$(nproc)&lt;/code&gt; is a &lt;em&gt;command substitution&lt;/em&gt; that is replaced by the output of the &lt;code&gt;nproc&lt;/code&gt; command. The &lt;code&gt;nproc&lt;/code&gt; command is used to display the number of CPU cores. So the above command will become &lt;code&gt;make -j 6&lt;/code&gt; assuming there are 6 cores in your CPU. This will make the compilation process much faster since the code will be compiled with multiple threads.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;Depending on the performance of your machine, you may have time for a cup of tea or perhaps another biscuit while the download and compilation are completed. Afterward, the resulting files will be located in the &lt;code&gt;output/images&lt;/code&gt; directory. Checking with the &lt;code&gt;ls&lt;/code&gt; command:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ ls -lh output/images&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The output will resemble the following:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;total 252M&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-rw-r--r-- 1 yang yang 119K Mar  4 02:58 fw_dynamic.bin&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-rw-r--r-- 1 yang yang 1.1M Mar  4 02:58 fw_dynamic.elf&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-rw-r--r-- 1 yang yang 119K Mar  4 02:58 fw_jump.bin&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-rw-r--r-- 1 yang yang 1.1M Mar  4 02:58 fw_jump.elf&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-rw-r--r-- 1 yang yang  19M Mar  4 02:59 Image&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-rw-r--r-- 1 yang yang 2.0G Mar  4 03:01 rootfs.ext2&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;lrwxrwxrwx 1 yang yang   11 Mar  4 02:59 rootfs.ext4 -&amp;gt; rootfs.ext2&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-rw-r--r-- 1 yang yang  86M Mar  4 02:59 rootfs.tar&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-rwxr-xr-x 1 yang yang  499 Mar  4 02:59 start-qemu.sh&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;5-boot-the-system&#34;&gt;5. Boot the system&lt;/h2&gt;&lt;p&gt;To boot the target system, use the following command:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;qemu-system-riscv64 &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;    -machine virt &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;    -m 1G &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;    -bios ./buildroot/output/images/fw_jump.elf &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;    -kernel ./buildroot/output/images/Image &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;    -append &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;rootwait root=/dev/vda ro&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;    -drive file&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;./buildroot/output/images/rootfs.ext2,format&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;raw,id&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;hd0 &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;    -device virtio-blk-device,drive&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;hd0 &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;    -netdev user,id&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;net0,hostfwd&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;tcp::10022-:22 &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;    -device virtio-net-device,netdev&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;net0 &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;    -nographic&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Compare to the previous chapter, there are three new QEMU parameters:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;-bios ./buildroot/output/images/fw_jump.elf&lt;/code&gt;: This specifies the BIOS firmware. The &lt;code&gt;fw_jump.elf&lt;/code&gt; is actually the OpenSBI, which is generated by &lt;em&gt;Buildroot&lt;/em&gt;. Note that when omitting the &lt;code&gt;-bios&lt;/code&gt; parameter, the QEMU builtin one will be loaded. In this case, we should use the &lt;em&gt;Buildroot&lt;/em&gt; version.&lt;/li&gt;&lt;li&gt;&lt;code&gt;-netdev user,id=net0,hostfwd=tcp::10022-:22&lt;/code&gt; and &lt;code&gt;-device virtio-net-device,netdev=net0&lt;/code&gt;: These parameters are used to assign a virtual network interface to the virtual machine, and &lt;code&gt;hostfwd=tcp::10022-:22&lt;/code&gt; means redirect TCP port 10022 from host to port 22 of the virtual machine.&lt;/li&gt;&lt;/ul&gt;&lt;blockquote&gt;&lt;p&gt;The &lt;em&gt;virtual machine&lt;/em&gt; created by QEMU is also called the &lt;em&gt;guest machine&lt;/em&gt;, the name it is related to the &lt;em&gt;host machine&lt;/em&gt;, which is the machine running QEMU.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;Once the command is executed, many message will be shown, generated by &lt;em&gt;OpenSBI&lt;/em&gt;, kernel and the &lt;code&gt;init&lt;/code&gt; process. You can safely ignore them if there is no error message.&lt;/p&gt;&lt;p&gt;The message will be ended with two lines: &lt;code&gt;Welcome to Buildroot&lt;/code&gt; and &lt;code&gt;buildroot login&lt;/code&gt;, enter the user name &lt;code&gt;root&lt;/code&gt; without password to log in.&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;buildroot login: root&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;6-check-the-system&#34;&gt;6. Check the system&lt;/h2&gt;&lt;p&gt;You can do a quick check to validate whether the cpu module, memory size, kernel version and storage space match what you configured:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# uname -a&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Linux buildroot 5.15.43 &lt;span style=&#34;color:#75715e&#34;&gt;#1 SMP Tue Mar 4 07:31:21 CST 2023 riscv64 GNU/Linux&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# free -h&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;              total        used        free      shared  buff/cache   available&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Mem:         988.5M       19.4M      961.0M       48.0K        8.0M      959.1M&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Swap:             &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;           &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;           &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# df -h&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Filesystem      Size  Used Avail Use% Mounted on&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;/dev/root       2.0G  151M  1.7G   9% /&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;devtmpfs        494M     &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;  494M   0% /dev&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;tmpfs           495M     &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;  495M   0% /dev/shm&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;tmpfs           495M   24K  495M   1% /tmp&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;tmpfs           495M   24K  495M   1% /run&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# cat /proc/cpuinfo&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;processor       : &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;hart            : &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;isa             : rv64imafdch_zicsr_zifencei_zihintpause_zba_zbb_zbc_zbs_sstc&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;mmu             : sv48&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;./images/buildroot.png&#34; alt=&#34;Buildroot&#34;&gt;&lt;/p&gt;&lt;p&gt;Next, check the installed packages:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# python --version&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Python 3.11.2&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# git --version&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git version 2.40.0&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# wget --version | head -n 1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;GNU Wget 1.21.3 built on linux-gnu.&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# vim --version | head -n 1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;VIM - Vi IMproved 9.0 &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2022&lt;/span&gt; Jun 28, compiled Mar &lt;span style=&#34;color:#ae81ff&#34;&gt;12&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2023&lt;/span&gt; 17:15:56&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Note the output text may be slighty different from your guest machine.&lt;/p&gt;&lt;h2 id=&#34;7-create-a-non-privileged-user&#34;&gt;7. Create a non-privileged user&lt;/h2&gt;&lt;p&gt;It&amp;rsquo;s easy to make mistakes when operating with the root user, so it&amp;rsquo;s good practice to creat a non-privileged user after system is installed, and switch to it as soon as possible.&lt;/p&gt;&lt;p&gt;To begin, create a user named &lt;code&gt;yang&lt;/code&gt; (or the username you usually use) and set its password:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ useradd -m -s /bin/bash yang&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ passwd yang&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Next, add the user to the &lt;code&gt;sudo&lt;/code&gt; group, which makes it possible to promote privileges when needed.&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ usermod -a -G sudo yang&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;&lt;p&gt;Make sure the &lt;code&gt;shadow&lt;/code&gt; package is selected in &lt;em&gt;Buildroot&lt;/em&gt; package selecting step, as the &lt;code&gt;useradd&lt;/code&gt; and &lt;code&gt;usermod&lt;/code&gt; commands are provided by this package.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;Switch to the newly created user and check its privileges.&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ su - yang&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ id&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;uid&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;1000&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;yang&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; gid&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;1000&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;yang&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; groups&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;1000&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;yang&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;,102&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;sudo&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The above text &lt;code&gt;102(sudo)&lt;/code&gt; indicates this account has been successfully added to the &lt;code&gt;sudo&lt;/code&gt; group. Try running the following command:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ sudo cat /etc/sudoers&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;It should not produce any errors.&lt;/p&gt;&lt;p&gt;Create a file &lt;code&gt;.bash_profile&lt;/code&gt; in the home directory and add the following text to it to improve your experience:&lt;/p&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-conf&#34; data-lang=&#34;conf&#34;&gt;alias ls=&amp;#39;ls --color=auto&amp;#39;PS1=&amp;#39;[\u@\h \W]\$ &amp;#39;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Run the command &lt;code&gt;$ source ~/.bash_profile&lt;/code&gt; to make it take effect. Your custom base Linux system is now fully set up.&lt;/p&gt;&lt;h2 id=&#34;8-log-in-to-the-guest-machine-via-ssh&#34;&gt;8. Log in to the guest machine via SSH&lt;/h2&gt;&lt;p&gt;Since there may be some minor text rendering defects in the QEMU terminal, it&amp;rsquo;s better to access the guest machine via SSH. Make sure that the &lt;code&gt;openssh&lt;/code&gt; package is selected in the &lt;em&gt;Buildroot&lt;/em&gt; package selecting step, the SSH daemon (a background process) will start automatically. Open another Terminal window and run the following command:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ ssh -p &lt;span style=&#34;color:#ae81ff&#34;&gt;10022&lt;/span&gt; yang@localhost&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;9-risc-v-assembly-development&#34;&gt;9. RISC-V Assembly development&lt;/h2&gt;&lt;p&gt;The GNU Assembler and Linker are included in the &lt;code&gt;binutils&lt;/code&gt; package. You can write some assembly code and assemble it into an executable program file to run it in the guest machine.&lt;/p&gt;&lt;p&gt;To do this, create a file named &lt;code&gt;hello.S&lt;/code&gt; in the home directory, and add the following text:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-S&#34; data-lang=&#34;S&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    .text&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    .global _start&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;_start&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# calling convention&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# a0-a2                     - parameters to Linux function&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# a7                        - Linux function number&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# call `write(int fd, char* s, int len)`&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    li      a0, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;               &lt;span style=&#34;color:#75715e&#34;&gt;# file descriptor, 1 = stdout&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    la      a1, s               &lt;span style=&#34;color:#75715e&#34;&gt;# the address/pointer to `s` string&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                                &lt;span style=&#34;color:#75715e&#34;&gt;# `la a1, s` is equivalent to&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                                &lt;span style=&#34;color:#75715e&#34;&gt;# `lui a1, %hi(s)` and `addi a1, a1, %lo(s)`&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    li      a2, &lt;span style=&#34;color:#ae81ff&#34;&gt;13&lt;/span&gt;              &lt;span style=&#34;color:#75715e&#34;&gt;# the length of string `s`&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    li      a7, &lt;span style=&#34;color:#ae81ff&#34;&gt;64&lt;/span&gt;              &lt;span style=&#34;color:#75715e&#34;&gt;# the number of syscall `write`&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ecall&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# call `exit(int)`&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    addi    a0, x0, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;           &lt;span style=&#34;color:#75715e&#34;&gt;# return code must be from 0 to 255&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    addi    a7, x0, &lt;span style=&#34;color:#ae81ff&#34;&gt;93&lt;/span&gt;          &lt;span style=&#34;color:#75715e&#34;&gt;# the number of syscall `exit`&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ecall&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    .section .rodata&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;s&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    .asciz  &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Hello World!\n&amp;#34;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;&lt;p&gt;If you are interested in the RISC-V assembly language, check out another series of my articles: &lt;a href=&#34;../&#34;&gt;Gentle RISC-V Assembly Language Tutorial&lt;/a&gt;.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;Next, assemble and link the file:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ as -g -o hello.o hello.S&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ ld -o hello.elf hello.o&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This will generate a file named &lt;code&gt;hello.elf&lt;/code&gt;. Try running it, a line of text reading &amp;ldquo;Hello World!&amp;rdquo; will be displayed if there are no exceptions.&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ ./hello.elf&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Hello World!&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;./images/hello-world.png&#34; alt=&#34;Hello World&#34;&gt;&lt;/p&gt;&lt;h2 id=&#34;10-debug-program-by-gdb&#34;&gt;10. Debug program by GDB&lt;/h2&gt;&lt;p&gt;The &lt;code&gt;gdb&lt;/code&gt; package has also been installed. Let&amp;rsquo;s start debugging &lt;code&gt;main.elf&lt;/code&gt;:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ gdb hello.elf&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;and run some GDB commands:&lt;/p&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-gdb&#34; data-lang=&#34;gdb&#34;&gt;(gdb) startiStarting program: /home/yang/hello.elfProgram stopped._start () at hello.S:1010          li      a0, 1               # file descriptor, 1 = stdout(gdb) x/6i $pc=&amp;gt; 0x100b0 &amp;lt;_start&amp;gt;:    li      a0,1   0x100b4 &amp;lt;_start+4&amp;gt;:  auipc   a1,0x0   0x100b8 &amp;lt;_start+8&amp;gt;:  addi    a1,a1,32   0x100bc &amp;lt;_start+12&amp;gt;: li      a2,13   0x100c0 &amp;lt;_start+16&amp;gt;: li      a7,64   0x100c4 &amp;lt;_start+20&amp;gt;: ecall(gdb) si11          la      a1, s               # the address/pointer to `s` string(gdb) si0x00000000000100b8      11          la      a1, s               # the address/pointer to `s` string(gdb) si14          li      a2, 13              # the length of string `s`(gdb) si15          li      a7, 64              # the number of syscall `write`(gdb) si16          ecall(gdb) i r a0 a1 a2 a7a0             0x1      1a1             0x100d4  65748a2             0xd      13a7             0x40     64(gdb) qA debugging session is active.        Inferior 1 [process 165] will be killed.Quit anyway? (y or n) y&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;As shown above, this Linux system already contains common tools and is capable of base assembly development and program debugging.&lt;/p&gt;&lt;h2 id=&#34;11-where-is-the-gcc-toolchain&#34;&gt;11. Where is the GCC toolchain?&lt;/h2&gt;&lt;p&gt;Unfortunately, the &lt;code&gt;gcc&lt;/code&gt; package is not available in Buildroot, as explained in &lt;a href=&#34;https://buildroot.org/downloads/manual/manual.html#faq-no-compiler-on-target&#34;&gt;the Buildroot documentation&lt;/a&gt;. If you have patient enough, you can compile the GCC toolchains from source and copy it into the guest machine, It may be helpful to check out some scripts such as &lt;a href=&#34;https://github.com/michaeljclark/musl-riscv-toolchain/&#34;&gt;musl-riscv-toolchain&lt;/a&gt; and &lt;a href=&#34;https://git.zv.io/toolchains/musl-cross-make&#34;&gt;musl-cross-make&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;Alternatively, you can download the pre-compiled RISC-V crossing compilation toolchains from &lt;a href=&#34;https://toolchains.bootlin.com/&#34;&gt;toolchains.bootlin.com&lt;/a&gt; and the native compilation toolchains from &lt;a href=&#34;https://musl.cc/&#34;&gt;musl.cc&lt;/a&gt;. But these are beyond the scope of this chapter.&lt;/p&gt;&lt;h2 id=&#34;12-conclusion&#34;&gt;12. Conclusion&lt;/h2&gt;&lt;p&gt;In this section, we built a base Linux system that contains general tools as well as &lt;code&gt;binutils&lt;/code&gt; and &lt;code&gt;gdb&lt;/code&gt; using &lt;em&gt;Buildroot&lt;/em&gt;. However, it is still not complete, for example, the GCC toolchain is missing, and there is no package management tool, making it difficult to install or update software.&lt;/p&gt;&lt;p&gt;In the next section, we will set up a complete Debian distribution in QEMU.&lt;/p&gt;&lt;div&gt;    &lt;img src=&#34;https://hemashushu.github.io/images/subscribe-and-donate.en.png&#34; class=&#34;block-image image-480px&#34;/&gt;&lt;/div&gt;</description>
     </item>
   
     <item>
       <title>S10C01 RISC-V development using QEMU - Part 1 Build a minimal Linux system</title>
       <link>https://hemashushu.github.io/posts/2023-01-06-s10c01-risc-v-development-using-qemu-part-1-minimal-linux/</link>
       <pubDate>Fri, 06 Jan 2023 00:00:00 +0000</pubDate>
       
       <guid>https://hemashushu.github.io/posts/2023-01-06-s10c01-risc-v-development-using-qemu-part-1-minimal-linux/</guid>
       <description>&lt;p&gt;This series of articles will guide you setting up a RISC-V development environment using QEMU. The series includes four parts:&lt;/p&gt;&lt;p&gt;&lt;a href=&#34;../2023-01-06-s10c01-risc-v-development-using-qemu-part-1-minimal-linux/&#34;&gt;Part 1&lt;/a&gt;. Building a minimal RISC-V Linux system with only Linux kernel and BusyBox, and runs on the QEMU emulator.&lt;/p&gt;&lt;p&gt;&lt;a href=&#34;../2023-01-08-s10c02-risc-v-development-using-qemu-part-2-buildroot&#34;&gt;Part 2&lt;/a&gt;. Building a base RISC-V Linux system with the ability of doing RISC-V assembly development and debug using Buildroot.&lt;/p&gt;&lt;p&gt;Part 3. Setting up a complete Debian RISC-V Linux system in QEMU, and do C language development and debug with GCC toolchains.&lt;/p&gt;&lt;p&gt;Part 4. Remote debugging with the GDB, and setup remote text editing and debugging by VSCode.&lt;/p&gt;&lt;hr&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&#34;#1-why-not-the-real-risc-v-hardware&#34;&gt;1. Why not the real RISC-V hardware?&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#2-create-the-project-folder&#34;&gt;2. Create the project folder&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#3-build-the-linux-system&#34;&gt;3. Build the Linux system&lt;/a&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&#34;#31-compile-linux-kernel&#34;&gt;3.1 Compile Linux kernel&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#32-compile-busybox&#34;&gt;3.2 Compile BusyBox&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#4-make-the-image-file&#34;&gt;4. Make the image file&lt;/a&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&#34;#41-create-an-empty-image-file&#34;&gt;4.1 Create an empty image file&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#42-partition-the-image-file&#34;&gt;4.2 Partition the image file&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#43-make-the-file-system&#34;&gt;4.3 Make the file system&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#44-configure-the-system&#34;&gt;4.4 Configure the system&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#45-check-the-file-system&#34;&gt;4.5 Check the file system&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#5-boot-the-system&#34;&gt;5. Boot the system&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#6-get-rid-of-the-busybox&#34;&gt;6. Get rid of the BusyBox&lt;/a&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&#34;#61-create-_hello-world_-program&#34;&gt;6.1 Create &lt;em&gt;Hello World&lt;/em&gt; program&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#62-create-initramfs-file&#34;&gt;6.2 Create &lt;code&gt;initramfs&lt;/code&gt; file&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#63-boot-the-new-system&#34;&gt;6.3 Boot the new system&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#7-conclusion&#34;&gt;7. Conclusion&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;!-- raw HTML omitted --&gt;&lt;h2 id=&#34;1-why-not-the-real-risc-v-hardware&#34;&gt;1. Why not the real RISC-V hardware?&lt;/h2&gt;&lt;p&gt;The RISC-V ISA has become popular in recent years due to its ease of learning and implementation, and the RISC-V toolchains are now quite mature. However, high-performance, stable and affordable RISC-V chips are still missing as of 2023.&lt;/p&gt;&lt;p&gt;Moreover, writing and debugging programs in an emulator is far more convenient than on real hardware. This approach can save money, eliminate the need for connecting wires, and avoid the hassle of copying or synchronizing program files. You can perform all sorts of tasks on just one machine.&lt;/p&gt;&lt;h2 id=&#34;2-create-the-project-folder&#34;&gt;2. Create the project folder&lt;/h2&gt;&lt;p&gt;QEMU is a software that emulates all the hardware of a complete computer system, including the CPU, memory, storage drives and network interfaces. This emulation is commonly known as a &amp;ldquo;virtual computer&amp;rdquo; or &amp;ldquo;virtual machine&amp;rdquo;.&lt;/p&gt;&lt;p&gt;Unlike VirtualBox or VMWare, In QEMU, the hardware configuation of a virtual machine, such as the type of CPU, number of cores, memory capacity, is specified through QEMU command line parameters. As a result, the command to start QEMU can be quite lengthy. It&amp;rsquo;s good practice to create a shell script to start QEMU and a directory for each virtual machine to hold this script file and the image file.&lt;/p&gt;&lt;p&gt;To get started, create a directory in your home directory and name it something like &amp;ldquo;riscv64-minimal-linux&amp;rdquo;, this is where you will store all the files created in this chapter.&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ mkdir ~/riscv64-minimal-linux&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ cd ~/riscv64-minimal-linux&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;&lt;p&gt;It is not possible to create a RISC-V virtual machine using virtualaztion software such as VirtualBox and VMWare on the &lt;em&gt;x86_64&lt;/em&gt; or &lt;em&gt;ARM&lt;/em&gt; platform. This is because these types of software are only capable of creating virtual machine with the same architecture CPU as the host machine. For example, on an &lt;em&gt;x86_64&lt;/em&gt; platform, you can only create an &lt;em&gt;x86_64&lt;/em&gt; virtual machine. However, since the computing ability of virtual machines is provided by the physical CPU of the host machine, their performance is typically much higher than that of QEMU.&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&#34;3-build-the-linux-system&#34;&gt;3. Build the Linux system&lt;/h2&gt;&lt;p&gt;There is a common misconception that building a Linux system is a daunting task. However, building a minimal, runnable Linux system is much easier than you might expect. In fact, it only requires two programs: a &lt;a href=&#34;https://www.kernel.org/&#34;&gt;Linux kernel&lt;/a&gt; and a user program.&lt;/p&gt;&lt;p&gt;The Linux kernel is responsible for driving and initializing hardware componenets, as well as creating an environment for running applications. On the other hand, the user program is responsible for providing specific functionality.&lt;/p&gt;&lt;p&gt;A typical Linux system consists of numerous user programs, including:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;An initialization program (&lt;code&gt;/sbin/init&lt;/code&gt;) which is launched by the kernel and starts all other user programs.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;A user interactive interface program called &lt;em&gt;shell&lt;/em&gt; (&lt;code&gt;/bin/sh&lt;/code&gt;), which accepts user input and executes commands.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;A series of base programs such as &lt;em&gt;ls&lt;/em&gt;, &lt;em&gt;cat&lt;/em&gt;, &lt;em&gt;echo&lt;/em&gt; etc.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img src=&#34;./images/linux-boot-process.png&#34; alt=&#34;Linux System Boot Process&#34;&gt;&lt;/p&gt;&lt;p&gt;There is an amazing program called &lt;a href=&#34;https://busybox.net/&#34;&gt;Busybox&lt;/a&gt; that contains all of the user programs mentioned above in a single program. BusyBox greatly simplifies the process of building a system. In this chapter we will build our first system using Busybox and the Linux kernel.&lt;/p&gt;&lt;h3 id=&#34;31-compile-linux-kernel&#34;&gt;3.1 Compile Linux kernel&lt;/h3&gt;&lt;ol&gt;&lt;li&gt;Install RISC-V GCC toolchains&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;You may need to install the RISC-V GCC toolchains if they are not already installed on your system. For example, on &lt;em&gt;Arch Linux&lt;/em&gt;, the required packages are:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;riscv64-linux-gnu-gcc&lt;/li&gt;&lt;li&gt;riscv64-linux-gnu-binutils&lt;/li&gt;&lt;li&gt;riscv64-linux-gnu-gdb&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;On Debian/Ubuntu, the packages are:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;gcc-riscv64-linux-gnu&lt;/li&gt;&lt;li&gt;binutils-riscv64-linux-gnu (may be installed automatically)&lt;/li&gt;&lt;li&gt;gdb-multiarch&lt;/li&gt;&lt;/ul&gt;&lt;ol start=&#34;2&#34;&gt;&lt;li&gt;Prepare the Linux kernel source code&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;Download the &lt;a href=&#34;https://cdn.kernel.org/pub/linux/kernel/v6.x/linux-6.2.10.tar.xz&#34;&gt;Linux kernel source code tarball&lt;/a&gt; to the project folder.&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ wget https://cdn.kernel.org/pub/linux/kernel/v6.x/linux-6.2.10.tar.xz&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Once the tarball is downloaded, extract it to obtain a folder named &lt;code&gt;linux-6.2.10&lt;/code&gt;.&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ tar xf linux-6.2.10.tar.xz&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;&lt;p&gt;It&amp;rsquo;s not recommended that cloning the kernel source code Git repository, as it is very large, takes a long time to download and requires a significant amount of storage space.&lt;/p&gt;&lt;/blockquote&gt;&lt;ol start=&#34;3&#34;&gt;&lt;li&gt;Compiling with default configuration&lt;/li&gt;&lt;/ol&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ cd linux-6.2.10&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ ARCH&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;riscv CROSS_COMPILE&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;riscv64-linux-gnu- make defconfig&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ ARCH&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;riscv CROSS_COMPILE&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;riscv64-linux-gnu- make -j &lt;span style=&#34;color:#66d9ef&#34;&gt;$(&lt;/span&gt;nproc&lt;span style=&#34;color:#66d9ef&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Take a break and step out for a cup of coffee. When you return, you should find a file named &lt;code&gt;arch/riscv/boot/Image&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;To examine this file, use the &lt;code&gt;file&lt;/code&gt; command:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ file arch/riscv/boot/Image&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The output should indicate that file is a &amp;ldquo;PE32+ executable (EFI application)&amp;rdquo;&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;./arch/riscv/boot/Image: PE32+ executable (EFI application) RISC-V 64-bit (stripped to external PDB), for MS Windows, 2 sections&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;32-compile-busybox&#34;&gt;3.2 Compile BusyBox&lt;/h3&gt;&lt;p&gt;Navigate back to the &lt;code&gt;~/riscv64-minimal-linux&lt;/code&gt; folder, download the &lt;a href=&#34;https://busybox.net/downloads/busybox-1.36.0.tar.bz2&#34;&gt;BusyBox source code tarball&lt;/a&gt;, extract the tarball and configure it using the default settings.&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ cd ..&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ wget https://busybox.net/downloads/busybox-1.36.0.tar.bz2&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ tar xf busybox-1.36.0.tar.bz2&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ cd busybox-1.36.0&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ CROSS_COMPILE&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;riscv64-linux-gnu- make defconfig&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Before compiling, some minor modifications are needed:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ make menuconfig&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Select the &amp;ldquo;Settings -&amp;gt; Build Options -&amp;gt; Build static binary (no shared libs)&amp;rdquo; option. Then select &amp;ldquo;Exit&amp;rdquo; and confirm &amp;ldquo;Yes&amp;rdquo; when prompted with &amp;ldquo;Do you wish to save your new configuration&amp;rdquo;.&lt;/p&gt;&lt;p&gt;Once you have completed this step, you can begin the compilation process:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ CROSS_COMPILE&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;riscv64-linux-gnu- make -j &lt;span style=&#34;color:#66d9ef&#34;&gt;$(&lt;/span&gt;nproc&lt;span style=&#34;color:#66d9ef&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;We now have the output file &lt;code&gt;./busybox&lt;/code&gt;, use the &lt;code&gt;file&lt;/code&gt; command to check and confirm that it is a RISC-V executable file with &lt;strong&gt;static linking&lt;/strong&gt;:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ file busybox&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The expected output should resemble something like:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;busybox: ELF 64-bit LSB executable, UCB RISC-V, RVC, double-float ABI, version 1 (SYSV), statically linked, BuildID[sha1]=04d2e9ad32458855c1861202cc4f7b53dea75374, for GNU/Linux 4.15.0, stripped&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;4-make-the-image-file&#34;&gt;4. Make the image file&lt;/h2&gt;&lt;p&gt;Just as a computer needs a hard drive or SSD to store programs and data, a virtual machine needs storage device as well. The storage device for virtual machines is usually implemented using a type of file called &amp;ldquo;image file&amp;rdquo;, which means that the hard disk drive you see within the virtual machine is actually an ordinary file located on the &lt;em&gt;host machine&lt;/em&gt; (the machine running QEMU). Operations such as partitioning, formatting, reading and writing to the hard disk drive within the virtual machine take place inside the image file.&lt;/p&gt;&lt;h3 id=&#34;41-create-an-empty-image-file&#34;&gt;4.1 Create an empty image file&lt;/h3&gt;&lt;p&gt;Navigate back to the &lt;code&gt;~/riscv64-minimal-linux&lt;/code&gt; folder, create an empty file &lt;code&gt;vda.img&lt;/code&gt; with a capacity of 128MB:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ dd &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;/dev/zero of&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;vda.img bs&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;1M count&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;128&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The &lt;code&gt;dd&lt;/code&gt; command copies data from &lt;code&gt;if&lt;/code&gt; to &lt;code&gt;of&lt;/code&gt; with the specified capacity, where &lt;code&gt;/dev/zero&lt;/code&gt; is a special file filled with zeroes with an infinite size. You can check the contents of a file using the hexadecimal and binary viewr and converter tool &lt;code&gt;xxd&lt;/code&gt;:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ xxd -l &lt;span style=&#34;color:#ae81ff&#34;&gt;64&lt;/span&gt; vda.img&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The above command shows the first 64 bytes of the file &lt;code&gt;vda.img&lt;/code&gt;. The expected output is:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;00000000: 0000 0000 0000 0000 0000 0000 0000 0000  ................&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;00000010: 0000 0000 0000 0000 0000 0000 0000 0000  ................&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;00000020: 0000 0000 0000 0000 0000 0000 0000 0000  ................&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;00000030: 0000 0000 0000 0000 0000 0000 0000 0000  ................&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;42-partition-the-image-file&#34;&gt;4.2 Partition the image file&lt;/h3&gt;&lt;p&gt;The current image file is like a flash new hard disk and needs to be partitioned before we can store programs and data on it.&lt;/p&gt;&lt;p&gt;There is a convenient tool called &lt;code&gt;fdisk&lt;/code&gt; that can be used to partition a disk or image file. Run the following command:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ fdisk vda.img&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Since we are not partitioning a real hard disk, the above command does not require root privileges (i.e., running as the root user or using &lt;code&gt;sudo&lt;/code&gt;). Then enter the following commands in sequence in &lt;code&gt;fdisk&lt;/code&gt;:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Command (m for help): g&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Command (m for help): n&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Command (m for help): w&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The meaning of each command is:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;g&lt;/code&gt;: create a new empty GPT partition table.&lt;/li&gt;&lt;li&gt;&lt;code&gt;n&lt;/code&gt;: add a new partition. Use the default values for all options in this step.&lt;/li&gt;&lt;li&gt;&lt;code&gt;w&lt;/code&gt;: write the partition table to disk and exit &lt;code&gt;fdisk&lt;/code&gt;.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Let&amp;rsquo;s check the partitions of the image file:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ fdisk -l vda.img&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The output should resemble this:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Disk vda.img: 128 MiB, 134217728 bytes, 262144 sectors&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Units: sectors of 1 * 512 = 512 bytes&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Sector size (logical/physical): 512 bytes / 512 bytes&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;I/O size (minimum/optimal): 512 bytes / 512 bytes&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Disklabel type: gpt&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Device     Start    End Sectors  Size Type&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;vda.img1    2048 260095  258048  126M Linux filesystem&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Then attach this image file to the current system:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ sudo losetup -P /dev/loop0 vda.img&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The image file is treated as a hard disk. The device file &lt;code&gt;/dev/loop0&lt;/code&gt; refers to the hard disk, and &lt;code&gt;/dev/loop0p1&lt;/code&gt; refers to the first partition (the &lt;code&gt;/dev/loop0p2&lt;/code&gt; is the second partition and so on).&lt;/p&gt;&lt;p&gt;Format the first partition with the &lt;code&gt;ext2&lt;/code&gt; file system:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ sudo mkfs.ext2 /dev/loop0p1&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;&lt;p&gt;A typical hard disk or SSD for a Linux system consists of four partitions: &lt;code&gt;/boot&lt;/code&gt;, root, &lt;code&gt;/home&lt;/code&gt; and a swap partition. However, for a simple system, only one root partition is required.&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 id=&#34;43-make-the-file-system&#34;&gt;4.3 Make the file system&lt;/h3&gt;&lt;p&gt;To begin, mount the first partition:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ mkdir -p part1&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ sudo mount /dev/loop0p1 part1&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The &lt;code&gt;part1&lt;/code&gt; directory represents the root filesystem of the virtual machine to be built. We need to create a series of directories within it that are required by the Linux system.&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ cd part1&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ sudo mkdir -p bin sbin lib usr/bin usr/sbin usr/lib&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ sudo mkdir -p etc&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ sudo mkdir -p dev proc sys run tmp&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ sudo mkdir -p root&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;You may wonder why so many directories are needed, but it&amp;rsquo;s for historical reasons. Linux inherited the concept of Unix, which is a 50-year-old system when computer hardware and software were very different from modern ones. Now this series of directories has become a convention for Linux system.&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;bin&lt;/code&gt;: base programs such as &lt;code&gt;ls&lt;/code&gt;, &lt;code&gt;cat&lt;/code&gt;, &lt;code&gt;mkdir&lt;/code&gt;.&lt;/li&gt;&lt;li&gt;&lt;code&gt;sbin&lt;/code&gt;: system programs such as &lt;code&gt;init&lt;/code&gt;, &lt;code&gt;mount&lt;/code&gt;, &lt;code&gt;sysctl&lt;/code&gt;.&lt;/li&gt;&lt;li&gt;&lt;code&gt;lib&lt;/code&gt;: base system libraries such as C standard library &lt;code&gt;libc.so&lt;/code&gt;.&lt;/li&gt;&lt;li&gt;&lt;code&gt;usr/bin&lt;/code&gt;: genernal programs such as &lt;code&gt;xxd&lt;/code&gt;, &lt;code&gt;wget&lt;/code&gt;, &lt;code&gt;make&lt;/code&gt;.&lt;/li&gt;&lt;li&gt;&lt;code&gt;usr/sbin&lt;/code&gt;: system daemons and utilities such as &lt;code&gt;sshd&lt;/code&gt;, &lt;code&gt;httpd&lt;/code&gt;.&lt;/li&gt;&lt;li&gt;&lt;code&gt;usr/lib&lt;/code&gt;: genernal libraries.&lt;/li&gt;&lt;li&gt;&lt;code&gt;etc&lt;/code&gt;: system configuration files.&lt;/li&gt;&lt;li&gt;&lt;code&gt;dev&lt;/code&gt;: device files created by device drivers, Linux treats all hardware as files, for example, &lt;code&gt;/dev/hda&lt;/code&gt; is the first hard disk of your system, and you can read and write to it as if the entire hard disk is a huge file.&lt;/li&gt;&lt;li&gt;&lt;code&gt;proc&lt;/code&gt;: user programs running information, but also some kernel and drivers running information for historical reasons.&lt;/li&gt;&lt;li&gt;&lt;code&gt;sys&lt;/code&gt;: kernel and drivers running information.&lt;/li&gt;&lt;li&gt;&lt;code&gt;run&lt;/code&gt; and &lt;code&gt;tmp&lt;/code&gt;: they are actually RAM disks, and all data would be lost when the machine power is off. They are used for storing cache and temporary files.&lt;/li&gt;&lt;li&gt;&lt;code&gt;root&lt;/code&gt;: the home folder for the &lt;code&gt;root&lt;/code&gt; user. As you know the home folder for all users is under the &lt;code&gt;/home&lt;/code&gt; folder, but the root user is an exception.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;The above are the general uses of these directories, it is important to note that:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Not everyone has a consistent understanding of these directories, so some directories may store other content.&lt;/li&gt;&lt;li&gt;They are created with root privilegs because the owner of these folders should be the &lt;code&gt;root&lt;/code&gt; user, whose ID is always zero in all Linux systems.&lt;/li&gt;&lt;li&gt;The &lt;code&gt;dev&lt;/code&gt;, &lt;code&gt;proc&lt;/code&gt;, &lt;code&gt;sys&lt;/code&gt;, &lt;code&gt;run&lt;/code&gt; and &lt;code&gt;tmp&lt;/code&gt; are all virtual directories whose contents are generated by the program. They are created on the hard disk only to provide mount names.&lt;/li&gt;&lt;li&gt;The kernel and drivers do not need these directories, they run in a separate state.&lt;/li&gt;&lt;/ul&gt;&lt;blockquote&gt;&lt;p&gt;Check the &lt;a href=&#34;https://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard&#34;&gt;Filesystem Hierarchy Standard&lt;/a&gt; for the details of directory structure.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;Next, copy the BusyBox program file into the &lt;code&gt;bin&lt;/code&gt; folder and create essential symbolic links.&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ cd bin&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ sudo cp ../../busybox-1.36.0/busybox .&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ sudo ln -s busybox sh&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ cd ..&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ cd sbin&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ sudo ln -s ../bin/busybox init&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ sudo ln -s ../bin/busybox mount&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ cd ..&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;By default, when kernel has finish initializing hardware and building the user program running environment, it launches the first and only user program &lt;code&gt;/sbin/init&lt;/code&gt;. The file path is hard coding in the kernel source, so we should follow this convention as well.&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;As you can see from the above commands, &lt;code&gt;init&lt;/code&gt; is just a symbolic link, and it is actually the Busybox program itself, as well as the shell program &lt;code&gt;sh&lt;/code&gt; and mount utility &lt;code&gt;mount&lt;/code&gt;. How does Busybox do this? This is because Busybox integrates including &lt;code&gt;init&lt;/code&gt;, shell, and many base programs (such as &lt;code&gt;cat&lt;/code&gt;, &lt;code&gt;ls&lt;/code&gt;). When it is called through a symbolic link, it knows the name of the link (remember the value of the first element of the parameter &lt;code&gt;argv&lt;/code&gt; in the &lt;code&gt;main()&lt;/code&gt; function?) and starts the corresponding function inside it by that name, thus enabling one program to play the role of multiple programs.&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 id=&#34;44-configure-the-system&#34;&gt;4.4 Configure the system&lt;/h3&gt;&lt;p&gt;The system built by Busybox is configured by commands, including mounting file systems, assigning IP addresses for network interface. Create a shell script &lt;code&gt;/etc/init.d/rcS&lt;/code&gt; and write command lines into it as needed.&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ cd etc&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ sudo mkdir -p init.d&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ cat &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;lt;&amp;lt; EOF | sudo tee init.d/rcS&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;#!/bin/sh&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;mount -t proc none /proc&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;mount -t sysfs none /sys&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;mount -t tmpfs none /run&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;mount -t tmpfs none /tmp&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;EOF&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ sudo chmod +x init.d/rcS&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ cd ..&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Since we are building a simple system, there are only mount virtual folder commands in the initialization shell script. Remember to add the &lt;em&gt;execute permission&lt;/em&gt; to the script file, otherwise it wouldn&amp;rsquo;t be executed.&lt;/p&gt;&lt;p&gt;To prevent Busybox from complaining, there are still some files that need to be created:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ cd dev&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ sudo mknod -m &lt;span style=&#34;color:#ae81ff&#34;&gt;666&lt;/span&gt; tty2 c &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ sudo mknod -m &lt;span style=&#34;color:#ae81ff&#34;&gt;666&lt;/span&gt; tty3 c &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ sudo mknod -m &lt;span style=&#34;color:#ae81ff&#34;&gt;666&lt;/span&gt; tty4 c &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ cd ..&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ sudo touch etc/fstab&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;45-check-the-file-system&#34;&gt;4.5 Check the file system&lt;/h3&gt;&lt;p&gt;To ensure that the file system has been created correctly, run the &lt;code&gt;tree&lt;/code&gt; command:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ sudo tree&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The expected output should resemble the following:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; bin&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    busybox&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    sh -&amp;gt; busybox&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; dev&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    tty2&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    tty3&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    tty4&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; etc&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    fstab&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    init.d&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        rcS&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; lib&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; lost+found&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; proc&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; root&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; run&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; sbin&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    init -&amp;gt; ../bin/busybox&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    mount -&amp;gt; ../bin/busybox&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; sys&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; tmp&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; usr&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;     bin&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;     lib&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;     sbin&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;17 directories, 9 files&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Finally, leave the &lt;code&gt;part1&lt;/code&gt; folder and unmount the image file:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ cd ..&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ sudo umount part1&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ rm -r part1&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ sudo losetup -d /dev/loop0&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;You now have an image file &lt;code&gt;vda.img&lt;/code&gt; which contains a minimal bootable Linux file system.&lt;/p&gt;&lt;h2 id=&#34;5-boot-the-system&#34;&gt;5. Boot the system&lt;/h2&gt;&lt;p&gt;Install QEMU, On Arch Linux, the package is:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;qemu-system-riscv&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;On Debian/Ubuntu, the package is:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;qemu-system&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Once you&amp;rsquo;ve installed QEMU, navigate back to the &lt;code&gt;~/riscv64-minimal-linux&lt;/code&gt; folder again and run the following command:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ qemu-system-riscv64 &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;     -machine virt &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;     -m 1G &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;     -kernel ./linux-6.2.10/arch/riscv/boot/Image &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;     -append &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;root=/dev/vda1 rw console=ttyS0&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;     -drive file&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;vda.img,format&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;raw,id&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;hd0 &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;     -device virtio-blk-device,drive&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;hd0 &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;     -nographic&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;There are several parameters in this command, let&amp;rsquo;s go through them line by line:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;-machine virt&lt;/code&gt; QEMU can emulate many real hardware platforms. A machine is a combination of a specified processor and some peripherals. &lt;a href=&#34;https://qemu-project.gitlab.io/qemu/system/riscv/virt.html&#34;&gt;The &lt;code&gt;virt&lt;/code&gt; machine&lt;/a&gt; is a specical one that doesn&amp;rsquo;t correspond to any real hardware. It&amp;rsquo;s an idealized processor for a specified architecture combined with some devices.&lt;/li&gt;&lt;li&gt;&lt;code&gt;-m 1G&lt;/code&gt;: This specifies the memory capacity.&lt;/li&gt;&lt;li&gt;&lt;code&gt;-kernel ./linux-6.2/arch/riscv/boot/Image&lt;/code&gt;: This specifies the kernel file. Just like a real machine, the QEMU boot process also contains several stages: &amp;ldquo;bios -&amp;gt; kernel -&amp;gt; initramfs -&amp;gt; userspace init&amp;rdquo;. When you omit the &lt;code&gt;-bios&lt;/code&gt; parameter, the &lt;a href=&#34;https://qemu-project.gitlab.io/qemu/system/target-riscv.html#risc-v-cpu-firmware&#34;&gt;default RISC-V QEMU BIOS firmware&lt;/a&gt; called &lt;code&gt;OpenSBI&lt;/code&gt; will be loaded automatically.&lt;/li&gt;&lt;li&gt;&lt;code&gt;-append &amp;quot;root=/dev/vda rw console=ttyS0&amp;quot;&lt;/code&gt;: This appends parameters to the kernel. Yes, the kernel is also an executable file that accepts many startup parameters, just like a normal user program. The common parameters &lt;code&gt;root=&lt;/code&gt; and &lt;code&gt;init=&lt;/code&gt; are used to specify the root file system and the &lt;code&gt;init&lt;/code&gt; program file path.  Check &lt;a href=&#34;https://docs.kernel.org/admin-guide/kernel-parameters.html&#34;&gt;this link&lt;/a&gt; for the full list of kernel parameters.&lt;/li&gt;&lt;li&gt;&lt;code&gt;-drive file=vda.img,format=raw,id=hd0&lt;/code&gt; and &lt;code&gt;-device virtio-blk-device,drive=hd0&lt;/code&gt;: These parameters specify the block device, which can be considered as the hard disk drive or SSD. In the current case, it&amp;rsquo;s the image file &lt;code&gt;vda.img&lt;/code&gt;.&lt;/li&gt;&lt;li&gt;&lt;code&gt;-nographic&lt;/code&gt;: This indicates that this machine has no graphic interface hardware (also called &lt;em&gt;graphic card&lt;/em&gt;), so all text messages generated by the software in this machine will be fed back to user through the &lt;em&gt;Serial port&lt;/em&gt;. Of course, the &lt;em&gt;Serial port&lt;/em&gt; is also virtual, it redirects the text message to the &lt;em&gt;Terminal&lt;/em&gt; running the QEMU program.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;After executing the command, a lot of text will scroll up until a message appears:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Please press Enter to activate this console.&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Press the &lt;code&gt;Enter&lt;/code&gt; key, and a command prompt &lt;code&gt;~ #&lt;/code&gt; will appear.&lt;/p&gt;&lt;p&gt;Note that all base and system programs (i.e., the symbolic links to Busybox) have not been created yet. Run the following command to complete the installation:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# /bin/busybox --install -s&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Note that this step only needs to be done once. The Linux system is now ready, let&amp;rsquo;s do some checking:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# uname -a&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Linux &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;none&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; 6.2.10 &lt;span style=&#34;color:#75715e&#34;&gt;#1 SMP Tue Jan 4 02:10:41 CST 2023 riscv64 GNU/Linux&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# free -h&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;              total        used        free      shared  buff/cache   available&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Mem:         970.5M       10.6M      957.1M           &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;        2.7M      952.6M&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# df -h&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Filesystem                Size      Used Available Use% Mounted on&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;/dev/root               116.6M      1.7M    108.6M   2% /&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;devtmpfs                484.2M         &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;    484.2M   0% /dev&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;none                    485.2M         &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;    485.2M   0% /run&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;none                    485.2M         &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;    485.2M   0% /tmp&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# cat /proc/cpuinfo&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;processor       : &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;hart            : &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;isa             : rv64imafdch_sstc_zihintpause&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;mmu             : sv57&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;mvendorid       : 0x0&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;marchid         : 0x70200&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;mimpid          : 0x70200&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;./images/busybox.png&#34; alt=&#34;Busybox&#34;&gt;&lt;/p&gt;&lt;p&gt;Run the command &lt;code&gt;poweroff&lt;/code&gt; to turn off the virtual machine to exit QEMU. If there is any exception causes the virtual machine to freeze, press &lt;code&gt;Ctrl+a&lt;/code&gt; and then press the &lt;code&gt;x&lt;/code&gt; key to terminate QEMU. Note that the &lt;code&gt;Ctrl+C&lt;/code&gt; key does not work.&lt;/p&gt;&lt;h2 id=&#34;6-get-rid-of-the-busybox&#34;&gt;6. Get rid of the BusyBox&lt;/h2&gt;&lt;p&gt;If there is only one user program need to run, and the shell is not necessary, the system we built can be further simplified.&lt;/p&gt;&lt;p&gt;Next we will create a &lt;em&gt;Hello World&lt;/em&gt; program, and use it to replace the Busybox. Thus the system only consist of Linux kernel and one &lt;em&gt;Hello World&lt;/em&gt; program.&lt;/p&gt;&lt;h3 id=&#34;61-create-_hello-world_-program&#34;&gt;6.1 Create &lt;em&gt;Hello World&lt;/em&gt; program&lt;/h3&gt;&lt;p&gt;Navigate back to the &lt;code&gt;~/riscv64-minimal-linux&lt;/code&gt; folder, create file &lt;code&gt;app.c&lt;/code&gt; with the following code:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Hello, world!&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Press Ctrl+a, then press x to exit QEMU.&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; c &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; getchar();&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        putchar(c);&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Then compile it with RISC-V GCC compiler:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ riscv64-linux-gnu-gcc -g -Wall -static -o app.elf app.c&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;&lt;p&gt;The compilation parameter &lt;code&gt;-static&lt;/code&gt; instructs the compiler to generate an executable program with static linking, it simplifies our example.&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 id=&#34;62-create-initramfs-file&#34;&gt;6.2 Create &lt;code&gt;initramfs&lt;/code&gt; file&lt;/h3&gt;&lt;p&gt;In the modern Linux systems, there is a small, temporary file system called &lt;code&gt;initramfs&lt;/code&gt; (&lt;em&gt;initial RAM File System&lt;/em&gt;) between the kernel and the real root file system. When the kernel finishes the base hardware initialization and building the program running environment, it launches the &lt;code&gt;/sbin/init&lt;/code&gt; program located in the &lt;code&gt;initramfs&lt;/code&gt; instead of the real root file system. Then &lt;code&gt;initramfs&lt;/code&gt; loads additional hardware device drivers, sets up network interfaces, loads and jumps to the real root file system.&lt;/p&gt;&lt;p&gt;&lt;code&gt;initramfs&lt;/code&gt; increases the flexibility of the system. For example, the real root file system can be located on an encrypted disk or on a network, and &lt;code&gt;initramfs&lt;/code&gt; can handle this without any changes to the kernel.&lt;/p&gt;&lt;p&gt;&lt;code&gt;initramfs&lt;/code&gt; is an archive file that resembles a &lt;code&gt;*.tar&lt;/code&gt; tarball. It is far easier to create an &lt;code&gt;initramfs&lt;/code&gt; than to create an image file. Thus, we will put the &lt;em&gt;Hello World&lt;/em&gt; program into &lt;code&gt;initramfs&lt;/code&gt; and will not need to create the &lt;code&gt;vda.img&lt;/code&gt; image file anymore.&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;In earlier versions of Linux, there was another temporary RAM file system called &lt;code&gt;initrd&lt;/code&gt; (&lt;em&gt;initial RAM disk&lt;/em&gt;), which is a bit like an image file. It would be loaded and mounted to RAM by bootloader during the machine boot process. However it is now deprecated and replaced by &lt;code&gt;initramfs&lt;/code&gt;. The name &lt;em&gt;initrd&lt;/em&gt; is still inherited, and can be seen in files such as the GRUB configuration file &lt;code&gt;/boot/grub/grub.cfg&lt;/code&gt; and the QEMU command parameters.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;Navigate to the &lt;code&gt;~/riscv64-minimal-linux&lt;/code&gt; folder, create the folder &lt;code&gt;ram1&lt;/code&gt;, change into it, and create the folder &lt;code&gt;sbin&lt;/code&gt;:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ mkdir -p ram1&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ cd ram1&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ mkdir -p sbin&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Copy the &lt;em&gt;Hello World&lt;/em&gt; program into &lt;code&gt;sbin&lt;/code&gt; folder and name it &lt;code&gt;init&lt;/code&gt;:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ cp ../app.elf sbin/init&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The file system creation is complete. Note that both creating folder and copying file do not require root privileges. Run the &lt;code&gt;tree&lt;/code&gt; command to check the new file system:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ tree&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The output should be:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; sbin&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;     init&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;2 directories, 1 file&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Use the command &lt;code&gt;cpio&lt;/code&gt; to package the &lt;code&gt;ram1&lt;/code&gt; folder into an archive file and compress it with &lt;code&gt;gzip&lt;/code&gt; command:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;find . | &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;     cpio -o -v --format&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;newc | &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;     gzip &amp;gt; ../initramfs.cpio.gz&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Now you have obtained the file &lt;code&gt;~/riscv64-minimal-linux/initramfs.cpio.gz&lt;/code&gt;. It is safe to delete the &lt;code&gt;ram1&lt;/code&gt; folder:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ cd ..&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ rm -Rf ram1&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;63-boot-the-new-system&#34;&gt;6.3 Boot the new system&lt;/h3&gt;&lt;p&gt;Run the following command:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;qemu-system-riscv64 &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;    -machine virt &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;    -m 1G &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;    -kernel ./linux-6.2.10/arch/riscv/boot/Image &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;    -initrd ./initramfs.cpio.gz &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;    -append &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;root=/dev/ram rdinit=/sbin/init console=ttyS0&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;    -nographic&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;There is a new kernel parameter &lt;code&gt;rdinit=&lt;/code&gt;, which is used to specify the &lt;code&gt;init&lt;/code&gt; program file path in the &lt;code&gt;initramfs&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;After a while, the &amp;ldquo;Hello, World!&amp;rdquo; message will appear:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Hello, world!&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Press Ctrl+a, then press x to exit QEMU.&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;./images/app.png&#34; alt=&#34;Hello, World! Program&#34;&gt;&lt;/p&gt;&lt;p&gt;This indicates that our program is executed correctly.&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Because this &lt;em&gt;Hello World&lt;/em&gt; program is the only user program, it is launched directly by the kernel. It has no exit door to leave. Therefore, there is an inifinite loop in the &lt;code&gt;main()&lt;/code&gt; functon in the &lt;code&gt;app.c&lt;/code&gt;. If this only user program ends, the machine will crash and a &lt;em&gt;kernel panic&lt;/em&gt; message will be shown.&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&#34;7-conclusion&#34;&gt;7. Conclusion&lt;/h2&gt;&lt;p&gt;In this section, we&amp;rsquo;ve created a minimal Linux system with a base shell, and it can properly run a static linking user program. However, you&amp;rsquo;ll notice that this system lacks many tools that we use daily, such as &lt;code&gt;ssh&lt;/code&gt;, &lt;code&gt;vim&lt;/code&gt; and &lt;code&gt;git&lt;/code&gt; etc. In the next section, we&amp;rsquo;ll build a base Linux system with common tools and the capability of doing RISC-V assembly development and debugging.&lt;/p&gt;&lt;div&gt;    &lt;img src=&#34;https://hemashushu.github.io/images/subscribe-and-donate.en.png&#34; class=&#34;block-image image-480px&#34;/&gt;&lt;/div&gt;</description>
     </item>
   
     <item>
       <title>S01C02 Write a Hello World program that can run alone without an OS</title>
       <link>https://hemashushu.github.io/posts/2022-11-06-s01c02-write-a-program-run-alone-without-os/</link>
       <pubDate>Sun, 06 Nov 2022 00:00:00 +0000</pubDate>
       
       <guid>https://hemashushu.github.io/posts/2022-11-06-s01c02-write-a-program-run-alone-without-os/</guid>
       <description>&lt;p&gt;&lt;a href=&#34;https://hemashushu.github.io/zh/posts/2022-11-06-s01c02-write-a-program-run-alone-without-os&#34;&gt;read first :: /zh/posts/2022-11-06-s01c02-write-a-program-run-alone-without-os&lt;/a&gt;&lt;/p&gt;&lt;div&gt;    &lt;img src=&#34;https://hemashushu.github.io/images/subscribe-and-donate.en.png&#34; class=&#34;block-image image-480px&#34;/&gt;&lt;/div&gt;</description>
     </item>
   
     <item>
       <title>S01C01 What is cross-compilation? Let&#39;s cross-compile and run our first program</title>
       <link>https://hemashushu.github.io/posts/2022-11-05-s01c01-cross-compile-and-run-the-first-program/</link>
       <pubDate>Sat, 05 Nov 2022 00:00:00 +0000</pubDate>
       
       <guid>https://hemashushu.github.io/posts/2022-11-05-s01c01-cross-compile-and-run-the-first-program/</guid>
       <description>&lt;p&gt;&lt;a href=&#34;https://hemashushu.github.io/zh/posts/2022-11-05-s01c01-cross-compile-and-run-the-first-program&#34;&gt;read first :: /zh/posts/2022-11-05-s01c01-cross-compile-and-run-the-first-program&lt;/a&gt;&lt;/p&gt;&lt;div&gt;    &lt;img src=&#34;https://hemashushu.github.io/images/subscribe-and-donate.en.png&#34; class=&#34;block-image image-480px&#34;/&gt;&lt;/div&gt;</description>
     </item>
   
     <item>
       <title>Making your own tools and building modern computer system from scratch, step by step - Index</title>
       <link>https://hemashushu.github.io/posts/2022-11-01-building-a-modern-computer-system-from-scratch-index/</link>
       <pubDate>Tue, 01 Nov 2022 00:00:00 +0000</pubDate>
       
       <guid>https://hemashushu.github.io/posts/2022-11-01-building-a-modern-computer-system-from-scratch-index/</guid>
       <description>&lt;p&gt;This is the index for the series of articles &lt;em&gt;Making your own tools and building modern computer system from scratch, step by step&lt;/em&gt;.&lt;/p&gt;&lt;p&gt;In the previous article &lt;a href=&#34;../2022-10-31-building-a-modern-computer-system-from-scratch-step-by-step&#34;&gt;Introduction&lt;/a&gt;, it was mentioned that this series consist of four sub-series, each containing several parts. The following are the titles of each part and links to the completed articles. This index will also be updated with new articles.&lt;/p&gt;&lt;p&gt;The first series covers fundamental knowledge, which may not be as exciting as the other three series. but it&amp;rsquo;s recommended not to skip. The field of modern computer technology is vast and complex, with various frameworks and tools constantly emerging. The iteration speed is so fast that it can easily overwhelm us. However, if you study towards the underlying technology, you will find that things become simple and straightforward. After reaching the destination, looking back at the fancy surface technology will become clear and simple. The first series will give you an accurate understanding of system technology.&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Maybe you have seen the &lt;a href=&#34;https://en.wikipedia.org/wiki/Fractal&#34;&gt;fractal graphics&lt;/a&gt; of the &lt;a href=&#34;https://en.wikipedia.org/wiki/Mandelbrot_set&#34;&gt;Mandelbrot set&lt;/a&gt;, which can be infinitely zoomed in and moved and always produce a variety of beautiful patterns. You can browse it like exploring the galaxies of our universe, and even spending a whole day on it will not be boring. But it&amp;rsquo;s unbelievable that this vast and complex universe is generated by a simple mathematical function: \(y = x^2 + z\), just keep substituing the value of \(y\) into \(x\), and the big bang happens.&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&#34;series-1-dive-into-risc-v-system-step-by-step&#34;&gt;Series 1: Dive into RISC-V system, step by step&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;Part I: Understanding the usage of compiler, linker, debugger and some common binary tools, understanding the organization of program, building minimal freestanding (also called &lt;em&gt;bare metal programs&lt;/em&gt;) executable programs.&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&#34;../2022-11-05-s01c01-cross-compile-and-run-the-first-program&#34;&gt;S01C01 What is cross-compilation? Let&amp;rsquo;s cross-compile and run our first program&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;../2022-11-06-s01c02-write-a-program-run-alone-without-os&#34;&gt;S01C02 Write a Hello World program that can run alone without an OS&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;../2022-11-07-s01c03-uncovering-the-elf-executable-file-making-a-minimal-hello-world-program&#34;&gt;S01C03 Uncovering the ELF executable file, making a minimal Hello World program only 70 bytes&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Part II: A brief look at the principles of interaction between software and hardware through microcontroller (MCU). Writing bare-metal program (firmware) without SDK or HAL (hardware abstraction library), directly reading and writing registers, controlling the electrical signal of input and output pin (GPIO), implementing serial communications.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Part III: Understanding the principles of program loading, dynamic linking in modern systems, understanding the function call conventions of RISC-V and the basic instructions, writing simple programs in assembly language.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Part IV: Design an assembly language with a target architecture of RISC-V, implement its assembler and syntax parser.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Part V: Designing a functional linker script language and implementing a script interpreter.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 id=&#34;series-2-implementing-a-modern-language-and-compiler-step-by-step&#34;&gt;Series 2: Implementing a modern language and compiler, step by step&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;Part I: Designing an IR (intermediate language) and implementing a code generator from IR to assembly language.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Part II: Designing a modern statically typed language, implementing a code generator from high-level language to IR, now you have a &lt;em&gt;simple but complete compilation system&lt;/em&gt;.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Part III: Implement the &lt;a href=&#34;https://webassembly.org/&#34;&gt;WASM&lt;/a&gt; virtual machine (VM) and then implement the code generator for the IR to WASM. With the WASM VM you can get a basic idea of how a processor works, while having the WASM code generator means that the language can run in a browser.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Part IV: Implementing the IR to the ARM and RISC-V assembly code generator.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Part V: Implementing the IR to the &lt;a href=&#34;https://llvm.org/docs/LangRef.html&#34;&gt;LLVM IR&lt;/a&gt; code generator.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Part VI: Implementing the project construction tool and package manager.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img src=&#34;images/compilation-system.png&#34; alt=&#34;compilation system&#34;&gt;&lt;/p&gt;&lt;h2 id=&#34;series-3-implementing-a-functional-risc-v-cpu-step-by-step&#34;&gt;Series 3: Implementing a functional RISC-V CPU, step by step&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;Part I: Designing a minimal instruction set that enables numeric accumulation and memory loading and storing, implement a minimal processor with digital circuit simulation software that contains the basic processor elements, such as ROM, RAM, register file, decoder, controller and ALU (arithmetic logic unit), which can execute the instruction set.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Part II: Deriving an HDL language from the language, implement a digital circuit simulator and a test framework, implement a code generator from this HDL to &lt;a href=&#34;https://en.wikipedia.org/wiki/SystemVerilog&#34;&gt;SystemVerilog&lt;/a&gt;. Re-implement the previous processor with the HDL and download it to the FPGA hardware for power-on testing.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Part III: Implementing a multi-cycle RV64I processor using the HDL language and download it to the FPGA hardware for power-on testing.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Part IV: Implementing some common protocols (e.g. UART, \(I^2C\), SPI), write drivers for common peripherals (e.g. GPIO, SPI Flash, SD card, SSD 1306 display etc.). Integrating into the processor to achieve a complete hardware system.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Part V: Upgrade the microarchitecture of the processor to a multi-stage pipeline design.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 id=&#34;series-4-implementing-a-functional-microkernel-os-step-by-step&#34;&gt;Series 4: Implementing a functional microkernel OS, step by step&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;Part I: Adding a MMU (memory management unit) to the processor, as well as a privileged module.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Part II: Implementing the minimal kernel, i.e. implementing basic serial text sending and receiving, page table memory management, program loader, process switch and message mechanisms.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Part III: Implementing a simple file system.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Part IV: Implementing a simple &lt;em&gt;Shell&lt;/em&gt;.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Part V: Implementing a simple network interface.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Part VI: Implementing a package manager.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Part VII: Adding a floating point module to the processor, and a matrix algorithm coprocessor.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Part VIII: implementing a simple machine learning library and then implementing a handwritten number recognition program.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Part IX: Implementing a simple graphics acceleration coprocessor.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Part X: Implementing a simple graphics library and physics engine, and make a retro action game.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;div&gt;    &lt;img src=&#34;https://hemashushu.github.io/images/subscribe-and-donate.en.png&#34; class=&#34;block-image image-480px&#34;/&gt;&lt;/div&gt;</description>
     </item>
   
     <item>
       <title>Making your own tools and building modern computer system from scratch, step by step - Introduction</title>
       <link>https://hemashushu.github.io/posts/2022-10-31-building-a-modern-computer-system-from-scratch-step-by-step/</link>
       <pubDate>Mon, 31 Oct 2022 14:34:52 +0800</pubDate>
       
       <guid>https://hemashushu.github.io/posts/2022-10-31-building-a-modern-computer-system-from-scratch-step-by-step/</guid>
       <description>&lt;h2 id=&#34;preface&#34;&gt;Preface&lt;/h2&gt;&lt;p&gt;RISC-V has become a popular computer instruction set in recent years, and many of you may have tried compiling the RISC-V version of the Linux kernel, following tutorials to write the RISC-V version toy operating systems, toy programming languages and compilers, or even toy CPU using the hardware description language (HDL).&lt;/p&gt;&lt;p&gt;Regardless of which path you chose, at the beginning, you were likely excited and eager, like a brave adventurer embarking on a new quest in an unknown world. However, as you progressed through the tutorial and reached the second chapter, you may have started to furrow your brow, grit your teeth, and struggled through a few more chapters before ultimately giving up. You may have thought, &amp;ldquo;I&amp;rsquo;ve been writing programs for several years, and I&amp;rsquo;m not even intimidated by various algorithm problems. Why can&amp;rsquo;t I understand these tutorials?&amp;rdquo;&lt;/p&gt;&lt;p&gt;The root of the problem is a lack of complete understanding of computer system techology (also known as &lt;em&gt;computer fundamentals&lt;/em&gt;, &lt;em&gt;low level techonlogy&lt;/em&gt;, or &lt;em&gt;core technology&lt;/em&gt;, collectively referred to as &lt;em&gt;system technology&lt;/em&gt; below).&lt;/p&gt;&lt;p&gt;You might argue, &amp;ldquo;System technology? I learned about that in computer fundamentals courses, and I passed the exams!&amp;rdquo; Indeed, computer science programs offer courses like &lt;em&gt;Computer Organization&lt;/em&gt;, &lt;em&gt;Compiliation Principles&lt;/em&gt; and &lt;em&gt;Operating Systems&lt;/em&gt;, which are often divided into multiple semesters to ensure you can understand. However, &lt;strong&gt;learning these subjects separately is a mistake&lt;/strong&gt; because system technology is interconnected.&lt;/p&gt;&lt;p&gt;&lt;img src=&#34;images/path.en.png&#34; alt=&#34;path&#34;&gt;&lt;em&gt;The spiral learning path&lt;/em&gt;&lt;/p&gt;&lt;p&gt;Computer systems consist of three major fundamental components: language, processor, and operating system. From afar, the processor and operating system may appear to be the same thing. Together, they build the most complex machine in human history &amp;ndash; the computer. The processor is responsible for implementing the invariant logical opeartions, while the operating system is a extension of the processor, responsible for implementing the variable parts. Language is used to express, encapsulate, and abstract the functionality of the machine, making communication between the machine and humans possible. They are different aspects of the same goal &amp;ndash; to make the machine solve problems.&lt;/p&gt;&lt;p&gt;Learning them separately will lead to a lack of understanding of the connections and reasons behind them. Imagine each of these subjects as a standing pillar. The better learning path is to &lt;strong&gt;spiral gradually up&lt;/strong&gt; around these pillars, rather than climbing up one pillar, then sliding down and climbing another.&lt;/p&gt;&lt;p&gt;Secondly, there are also issues with the learning methods. Most system technology is the result of continuous problem-solving and accumulation by engineers. In other words, theory does not play a dominant role, they are more about the best practices through various attempts. Therefore, a better approach to learning should starting with exploration and experimentation, learning by practicing, making mistakes, and summarizing, rather than starting with a lot of theory.&lt;/p&gt;&lt;p&gt;&lt;img src=&#34;images/way.en.png&#34; alt=&#34;way&#34;&gt;&lt;/p&gt;&lt;p&gt;Overall, although we may have learned almost all of the subjects related to system technology, we may not have truly mastered them because our learning process is far from the way the system is built and constructed. You can try designing the simplest instruction set without the help of the internet, then drawing the approximate data path of the microarchitecture by hand, or writing a boot loader for a given target hardware platform, or writing a simple syntax parser from scratch without any libraries. You will find that even though you have just learned these subjects, implementing them is very challenging.&lt;/p&gt;&lt;h2 id=&#34;characteristics&#34;&gt;Characteristics&lt;/h2&gt;&lt;p&gt;In fact, we have already accumulated some system technology in our daily study and work, but it is often fragmented and incomplete. I hope to connect them through a series of articles, so that they become truly knowledge and skills. This series has the following characteristics:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;It doesn&amp;rsquo;t follow the traditional approach &amp;ldquo;learn theory first, then do projects&amp;rdquo;. Instead, it starts with exploration and experimentation, interspersing theory in the process of practice. Also unlike many practical tutorials, this series not only shows you &lt;strong&gt;how to do&lt;/strong&gt;, but also explains &lt;strong&gt;why&lt;/strong&gt;. Many practical tutorials often ignore the latter point and list only the steps to follow, with screenshots and input parameters, or just show you a long operating videos. While following these tutorials may make it &amp;ldquo;work&amp;rdquo;, the underlying principles are often vague. Additionally, such instructions are highly dependent on the environment and tools, and sometimes steps change subtly due to changes in software and hardware environments or tool version updates, making them inconsistent with the tutorial and ultimately unsuccessful.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;It doesn&amp;rsquo;t divide the content by subject, but by multiple small stages according to the system construction process and our understanding level. Each stage will involve knowledge from multiple subjects.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;It doesn&amp;rsquo;t require any specified software or hardware&lt;/strong&gt;. Many professional system technology tutorials or training require various high-end and expensive proprietary software and hardware, this series only a few general open source and free software, and a few widely used and cheapest no more than hundred dollars   essential hardware modules are needed (of course, this series is free, and there will be no Ads or promotional links ). Besides saving money, the most important thing is that this series aims to enable you to create tools and build systems on your own, not to make you just an operator or user of a specific software or hardware.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;It doesn&amp;rsquo;t require any specified IDE, SDK, or library&lt;/strong&gt;. We will build everything from scratch, starting with a few general open source and free compilers and tools, and later using our own tools. By building our own tools, you can thoroughly understand every technical detail without leaving any blind spots.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;It&amp;rsquo;s not popular science or superficial observation, but rather a truly in-depth practice of computer systems. Through this series you will gain a correct understanding of the system, and you will not be confused by various fancy &amp;ldquo;knowledge&amp;rdquo; that are widely circulated but actually wrong, e.g. the belief that the core technology of computers is only chip manufacturing, solving this problem and all problems are solved, which is completely wrong.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;This series will use the RISC-V as the target architecture for learning and implementation. I chose RISC-V because:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;Its instruction set is relatively simple, which makes it possible for you to implement &amp;ldquo;the smallest working&amp;rdquo; compiler and processor by ourselves.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;There are a large number of related open source and free tools and documents that you can use to check and verify your work, which is very important for the exploration and learning process.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Finally, if you produce a product, there is no need to worry about licensing issues.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;&lt;p&gt;There is no doubt that system technology contains large amount of content. It represents the accumulation of the work of thousands of top engineers from around the world over several decades, and its breadth and depth are almost at the limit of what the human brain can comprehend. In fact, one could argue that it is the work of a group of people who have far surpassed our current era.&lt;/p&gt;&lt;p&gt;I realize that it is impossible to cover all of the content in just a few articles. That is why I have prepared four series, each consisting of several parts, and each part containing several chapters. In total, there will be about a hundred articles. The main focus of this series can be described in one sentence: &lt;strong&gt;Learn about existing tools and systems, create you own tools, and build new systems.&lt;/strong&gt; You may have already read books or articles like &amp;ldquo;Building Systems from Scratch&amp;rdquo;, but this series not only builds systems, but also makes tools for building systems, which I believe will still be refreshing for you .&lt;/p&gt;&lt;p&gt;&lt;img src=&#34;images/content.en.png&#34; alt=&#34;content&#34;&gt;&lt;/p&gt;&lt;p&gt;Although the content is vast, you do not have to worry about it is too difficult to complete. Each part, despite having a fancy name, only aims to achieve the level of &amp;ldquo;just enough to work&amp;rdquo;. Moreover, every small component of system technology is surprisingly simple than you think when analyzed and implemented individually. So as long as you follow step-by-step, you will not get stuck along the way. Of course, I will also strike a balance between &amp;ldquo;rudimentary&amp;rdquo; and &amp;ldquo;practical&amp;rdquo; to ensure that each &amp;ldquo;work&amp;rdquo; in the series has its value.&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Sometimes the system technology itself is not really difficult, it is just that you have encountered a lousy tutorial or have not meet a good teacher. I found that although there are many excellent and classic textbooks, they are often overshadowed by a huge amount of low-quality information. Choosing the right textbook is crucial.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;Mainstream modern system technology carries a heavy historical burden. For example, GCC has been around for more than thirty years as well, and the Linux kernel has been under development for thirty years as well. For beginner, it is difficult to comprehend, modify, and expand these systems, and many new concepts cannot be integrated. In contrast, our system is built from scratch, with no burden, making it relatively simple and easy to implement. Some stubborn problems can be solved fundamentally, and new concepts (which are not really new but just not well-known). The system we built has many highlights, for example:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Use one language for hardware development, system level development, application and web frontend development.&lt;/li&gt;&lt;li&gt;A user-friendly assembly language.&lt;/li&gt;&lt;li&gt;A functional script language for both Shell script and linking script.&lt;/li&gt;&lt;li&gt;A operating system that uses a microkernel, making it easy to develop, debug, install and deploy (develop driver programs just like regular programs). System updates do not require a reboot and can be rolled back.&lt;/li&gt;&lt;li&gt;A system security model based on capabilities rather than users and groups.&lt;/li&gt;&lt;li&gt;A Shell with structured data.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Of course, there are many other features, which will be detailed in spcific chapters.&lt;/p&gt;&lt;h2 id=&#34;like-share-and-donate&#34;&gt;Like, Share and Donate&lt;/h2&gt;&lt;p&gt;Although I have already put most of the content in this series into practice, I found it quite challenging to explain them. It was difficult to organize the vast and intertwined content, choose practice projects, achieve smooth transitions between chapters, ensure the knowledge is correct, and make it easy to understand for readers. It took me more than four months to writ just the first eight articles, revising them over and over again. I don&amp;rsquo;t know how many years it will take me to finish the last chapter .&lt;/p&gt;&lt;p&gt;On the other hand, while system technology is significant in terms of inheriting and innovating scientific and technological, and as the foundation of modern industry, it is not much value for individuals (), as most enterprises are engaged in application-level development. System technology is too distant for both ordinary people and developers.&lt;/p&gt;&lt;p&gt;Even though I do my best to write each article well, only a few readers will actually read them, and only an extremely small number of people will be interested. Therefore, if you happen to come across this series and find them helpful, please feel free to tip me, your a cup of cola or coffee is the driving force for my next article .&lt;/p&gt;&lt;p&gt;Finally, Although system technology is &amp;ldquo;almost useless&amp;rdquo; for individuals, it can satisfy your primal curiosity, exploration, and creativity very well. Imagine what could be cooler than &amp;ldquo;conquering the most complex machine with your bare hands&amp;rdquo;. When you finish the last chapter, I believe you will see a different world. Click on &lt;a href=&#34;../2022-11-01-building-a-modern-computer-system-from-scratch-index&#34;&gt;the series index&lt;/a&gt; to start your journey!&lt;/p&gt;&lt;div&gt;    &lt;img src=&#34;https://hemashushu.github.io/images/subscribe-and-donate.en.png&#34; class=&#34;block-image image-480px&#34;/&gt;&lt;/div&gt;</description>
     </item>
   
 </channel>
</rss>
