
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
 <channel>
   <title>riscv on 河马蜀黍真是的</title>
   <link>https://hemashushu.github.io/tags/riscv/</link>
   <description>Recent content in riscv on 河马蜀黍真是的</description>
   <generator>Hugo -- gohugo.io</generator>
   <language>en-us</language>
   <copyright>Copyright &amp;copy; 2022 - Hippospark</copyright>
   <lastBuildDate>Mon, 31 Oct 2022 14:34:52 +0800</lastBuildDate>
   
       <atom:link href="https://hemashushu.github.io/tags/riscv/index.xml" rel="self" type="application/rss+xml" />
   
   
     <item>
       <title>从零开始一步一步构建现代计算机系统 - 刨根问底的开始</title>
       <link>https://hemashushu.github.io/posts/2022-10-31-building-a-modern-computer-system-from-scratch-step-by-step/</link>
       <pubDate>Mon, 31 Oct 2022 14:34:52 +0800</pubDate>
       
       <guid>https://hemashushu.github.io/posts/2022-10-31-building-a-modern-computer-system-from-scratch-step-by-step/</guid>
       <description>&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&lt;p&gt;RISC-V 是最近几年热门的计算机指令集，相信已经有不少朋友已经尝试过编译 RISC-V 版的 Linux 内核，或者跟着教程编写玩具操作系统、制作玩具编程语言，甚至还有用 HDL（硬件描述语言）编写自己的玩具 CPU。&lt;/p&gt;&lt;p&gt;无论你是哪种，刚开始时肯定既激动又兴奋，就像要在一个异世界开始一段新冒险的勇者那样。不过翻到教程的第二章，可能大部分朋友就开始眉头紧锁，然后咬着牙又翻了几章，经过一番挣扎最后只能放弃。这时候你可能很疑惑：“明明写了几年的程序，各种算法题早已不放在眼里，怎么在这里就翻车了呢？！&amp;quot;&lt;/p&gt;&lt;p&gt;显然这是因为缺少对 &lt;em&gt;系统的底层技术&lt;/em&gt; 的了解（&lt;em&gt;系统的底层技术&lt;/em&gt; 也就是 &lt;em&gt;计算机基础技术&lt;/em&gt;，不过这个名称经常引起理工科之外的人误解，下面简称 &lt;em&gt;系统技术&lt;/em&gt;），你可能会反驳：”系统技术嘛，在计算机基础课程里我早就学过了，考试也通过了！“。是的，在计算机专业的课程设置里都有诸如 &lt;em&gt;组成原理&lt;/em&gt;、&lt;em&gt;编译原理&lt;/em&gt;、&lt;em&gt;操作系统&lt;/em&gt; 等课程，而且还担心你吸收不了于是一门一门地分几个学期教学。不过&lt;strong&gt;把这些科目分开学习是错误的&lt;/strong&gt;，计算机的系统技术相互交叉。&lt;/p&gt;&lt;p&gt;&lt;img src=&#34;images/path.png&#34; alt=&#34;path&#34;&gt;&lt;em&gt;螺旋式的学习路径&lt;/em&gt;&lt;/p&gt;&lt;p&gt;计算机系统包括了 &lt;em&gt;语言&lt;/em&gt;、&lt;em&gt;处理器&lt;/em&gt; 和 &lt;em&gt;操作系统&lt;/em&gt; 三个基本组成部分。如果从远距离来看，处理器和操作系统是同一回事，它们共同构建了一种人类文明当中最复杂的机器 ———— 计算机。处理器负责实现不变的逻辑运算，操作系统是处理器的自然延伸，负责实现需要变化的部分，而语言用于表达、封装和抽象机器的功能，使得机器和人类之间的交流成为可能。可见计算机系统的基本组成部分是 &lt;strong&gt;同一个目的 ———— 让机器解决问题&lt;/strong&gt; 的不同侧面，分开学习自然无法理解其中的联系和缘由。不妨把每一个领域想象成一根根立起来的柱子，正确的学习路径是围绕着这些柱子&lt;strong&gt;螺旋式地逐渐往上爬&lt;/strong&gt;，而不是一口气爬完一根柱子，然后滑下来再爬另一根柱子。&lt;/p&gt;&lt;p&gt;其次学习方式也存在问题，计算机系统技术大部分是工程师们在不断地解决问题之后得出的总结和积累，也就是说，这些技术当中理论并不是占主导作用，更多是为了解决问题而通过各种尝试后得出的 &lt;em&gt;最佳实践&lt;/em&gt;。因此较好的的学习方式应该是先从探索和实践开始入手，然后&lt;strong&gt;边实践边试错、边领会边总结&lt;/strong&gt;，而不是先学一大堆原理，做完一堆习题，再来实践。&lt;/p&gt;&lt;p&gt;&lt;img src=&#34;images/way.png&#34; alt=&#34;way&#34;&gt;&lt;/p&gt;&lt;p&gt;总的来说，虽然我们几乎都学过跟计算机系统相关的科目，但因为跟系统的构建方式和过程都相差甚远，所以实际上并没有真正掌握到这些技术。不妨试试在没有网络的帮助下，能否自己设计一套最简的指令集，然后手画微架构（microarchitecture）的大致数据通路（data path）；或者给定一个目标架构，编写一个冷启动的引导程序；又或者不依赖任何库，从零开始手写一个简单的语法解析器。&lt;/p&gt;&lt;h2 id=&#34;特点&#34;&gt;特点&lt;/h2&gt;&lt;p&gt;实际上我们在平时的工作和学习当中已经积累了一定的系统知识，只是它们在脑海里或者是松散说着是游离的状态，我希望能通过一系列文章，把这些知识有序地连接起来，从而成为你掌握的技术。这系列文章有如下特点：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;不再是 “讲原理然后做项目”，而是从探索和实践入手，在实践和试错过程中再穿插原理（为了给你解闷，有时还会穿插一些我知道的小典故小故事）。&lt;/li&gt;&lt;li&gt;不再根据学科分类，而是根据系统的构建过程以及我们能理解的程度，把整个系列切分为多个小阶段。每个小阶会同时涉及多个领域（学科）的知识，每个领域都是够用为止，不会过度深入，完成一个阶段再进入下一个阶段。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;不需要任何专门的 IDE、工具、SDK 或者库&lt;/strong&gt;，从零开始构建。开始阶段只需几个通用的开源免费的编译器和工具，后面则使用自己的工具，因此可以彻底弄明白每一个技术细节（毕竟就连工具都是自己构建的）。&lt;/li&gt;&lt;li&gt;无需昂贵的软件和硬件，只使用几个通用的开源免费的软件，和几个最广泛使用的（久经考验的）最廉价的硬件模块，即可以完成到最后一章。很多专业的系统技术教程或者培训需要各种昂贵的高大上的专业软件和硬件，而我们这个系列只有硬件模块需要开销，而且一共只需一两百来块钱，最重要的是这个系列不是为了让你成为某个软件或者硬件的操作工和应用者，而是让你创造工具、构建系统。（为打消你的疑虑我先说明，这系列文章是免费的，文章当中也不会有任何广告或者推广链接）&lt;/li&gt;&lt;li&gt;不是科普或者走马观花式的观摩，而是深入地对计算机系统的完整实践。通过这一系列文章你会对系统有正确的认识和理解，可以不被那些广泛流传的实则错误的 “知识” 所迷惑（比如很多人认为计算机核心技术只有芯片制造机器，似乎解决这一项其它都不是问题，而事实上这是完全错误的，制造机器处于末端环节，跟系统真正的核心和源头相差十万八千里）。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;这一系列文章会以 RISC-V 指令集作为学习和实现的目标架构，之所以选择 RISC-V 原因有：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;它的指令集相对比较简单，这使得我们自己动手实现 &amp;ldquo;最小的能工作的&amp;rdquo; 汇编器及处理器成为可能；&lt;/li&gt;&lt;li&gt;有大量相关的开源免费的工具和文档，可以享用现有的工具来检查和验证我们的 &amp;ldquo;作品&amp;rdquo; 是否正确，这对摸索和学习过程非常重要；&lt;/li&gt;&lt;li&gt;最后如果我们做出了产品，也无需顾忌授权问题。&lt;/li&gt;&lt;/ul&gt;&lt;h2 id=&#34;内容简介&#34;&gt;内容简介&lt;/h2&gt;&lt;p&gt;无可否认计算机系统的内容非常之多，它是几十年以来成千上万全球最顶尖工程师的总结和积累，无论是知识面广度和深度都几乎逼近人脑的极限，从某个角度甚至可以说，它是一群思维&lt;strong&gt;远超越我们当前时代&lt;/strong&gt;的人的作品。河马蜀黍知道无法简单地通过几篇文章就能讲完，所以准备了四个系列（series），每个系列分为若干部（part），每部含若干篇文章（chapter），一共也就百来篇长文。下面简单介绍一下：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;一步一步深入 RISC-V 系统&lt;/em&gt;。这个系列分为五部：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;第一部：了解编译器、链接器、调试器以及一些常用二进制工具的使用方法，了解程序的组成，构建最小独立式可执行程序（freestanding，也叫 &lt;em&gt;裸机程序&lt;/em&gt;）等；&lt;/li&gt;&lt;li&gt;第二部：通过微控制器（MCU）来简单地了解软件和硬件之间的交互原理，通过不使用 SDK 或者硬件抽象库（HAL），而是直接读写寄存器的方式编写裸机程序（固件），控制电信号的输入输出（GPIO），实现串口通信等；&lt;/li&gt;&lt;li&gt;第三部：了解现代系统的程序加载、动态链接的原理，了解 RISC-V 的函数调用规程以及基本指令，使用汇编语言编写简单的程序；&lt;/li&gt;&lt;li&gt;第四部：设计一门目标架构为 RISC-V 的汇编语言，实现其汇编器，同时了解简单的语法解析器的原理；&lt;/li&gt;&lt;li&gt;第五部：设计一门链接脚本语言，实现其链接器，同时了解脚本解析器的原理。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;一步一步实现一门现代语言及其编译器&lt;/em&gt;。这个系列分六部：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;第一部：设计一门中间语言（IR），实现从中间语言到汇编语言的代码生成器（code generator）；&lt;/li&gt;&lt;li&gt;第二部：设计一门现代的静态类型的语言，实现高级语言到中间语言的代码生成器，至此完成了一个 &lt;em&gt;简单的完整的编译系统&lt;/em&gt;；&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img src=&#34;images/compiler.png&#34; alt=&#34;compiler system&#34;&gt;&lt;em&gt;自己的编译系统&lt;/em&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;第三部：实现 &lt;a href=&#34;https://webassembly.org/&#34;&gt;WASM&lt;/a&gt; 虚拟机（VM），然后实现中间语言到 WASM 的代码生成器。实现 WASM VM 的同时可以大致地认识一个处理器是如何工作的，另一方面有了 WASM 代码生成器，意味着我们的语言能在浏览器中运行；&lt;/li&gt;&lt;li&gt;第四部：实现中间语言到 &lt;a href=&#34;https://llvm.org/docs/LangRef.html&#34;&gt;LLVM IR&lt;/a&gt; 的代码生成器，让我们的语言能生成目标架构为 &lt;code&gt;x86&lt;/code&gt; 和 &lt;code&gt;arm&lt;/code&gt; 的程序。&lt;/li&gt;&lt;li&gt;第五部：实现项目构建器及包管理器，这是任何现代语言都必备的。&lt;/li&gt;&lt;li&gt;第六部：用当前语言重写编译器，实现语言自托管（self-hosting），即编译器可以编译自己的源代码，从此我们开始使用自己的工具来构建系统。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;一步一步实现一个实用型的 RISC-V CPU&lt;/em&gt;。这个系列分五部：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;第一部：设计一个最小的指令集，实现数字累加和内存加载和存储功能；然后通过数字电路仿真软件实现一个最简处理器，该处理器包含了 ROM、RAM、寄存器堆（register file）、译码器、控制器及算术逻辑单元（ALU）等基本处理器要素，能执行我们的指令集。通过这一部来了解处理器的基本运作原理，以及软件如何变成电信号。&lt;/li&gt;&lt;li&gt;第二部：从我们的语言派生出一门 HDL 语言，实现该门语言的数字逻辑电路模拟器以及测试（验证）框架；实现从这门语言到 &lt;a href=&#34;https://en.wikipedia.org/wiki/SystemVerilog&#34;&gt;SystemVerilog&lt;/a&gt; 的代码生成器，然后用这门语言重新实现上一部的基础组件以及处理器，并下载到 FPGA 硬件上通电测试；&lt;/li&gt;&lt;li&gt;第三部：使用自己的 HDL 语言实现一个多时钟周期的 RV64I 处理器，并下载到 FPGA 硬件上通电测试；&lt;/li&gt;&lt;li&gt;第四部：实现常见的通信协议（比如 UART、$I^2C$、SPI），书写常见的外设（比如 GPIO 接口、SPI Flash、SD 卡、SSD 1306 显示屏等）的驱动。整合我们的处理器，实现一个完整的硬件系统；&lt;/li&gt;&lt;li&gt;第五部：将处理器微架构升级为多级流水线设计。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;一步一步实现一个实用的微内核操作系统&lt;/em&gt;。这个系列分六部：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;第一部：为我们的处理器添加内存管理单元（MMU）以及特权相关的模块；&lt;/li&gt;&lt;li&gt;第二部：实现最小的内核，即实现基本的串口输入输出，多级页表，内存管理，程序的加载及进程的简单分时切换，以及消息机制等；&lt;/li&gt;&lt;li&gt;第三部：实现简化版的 &lt;code&gt;ext4&lt;/code&gt; 文件系统；&lt;/li&gt;&lt;li&gt;第四部：实现简单的用户交互界面（shell）以及一个包管理器；&lt;/li&gt;&lt;li&gt;第五部：实现一个简单的图形加速协处理器（coprocessor）；&lt;/li&gt;&lt;li&gt;第六部：实现一个简单的图形库，实现一个复古风格的横向卷轴动作游戏。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;一句话描述这一系列文章的主要内容就是：&lt;strong&gt;学习现有的工具和系统 -&amp;gt; 制作自己的工具 -&amp;gt; 打造新的系统&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;&lt;img src=&#34;images/content.png&#34; alt=&#34;content&#34;&gt;&lt;/p&gt;&lt;p&gt;其中的内容非常多，不过你不用担心难度过高而无法完成，因为每一个部分虽然名堂很大，但都是仅实现最基本的程度，也就是 &amp;ldquo;刚好能用&amp;rdquo; 的程度即止，所以只需一步步跟着来，就不会发生在中途就被卡住的情况。不过我也会在 “简陋” 和 “实用” 之间平衡，让每一部的 “作品” 都有有实用价值。&lt;/p&gt;&lt;p&gt;现代主流的计算机系统都有沉重的历史包袱，比如 GCC 已有三十多年的历史，Linux 内核也修修补补三十年，导致无论是阅读理解、修改、扩充都非常繁杂，而且很多新观念无法整合。而我们的系统因为是从零开始，完全没有包袱，所以实现起来相对会简单轻松，有些问题也可以 &lt;strong&gt;从根本上解决&lt;/strong&gt;（比如内存安全问题，从指令到操作系统到编译器一起配合即能在兼顾性能和安全的前提下解决）；新理念（严格来说并不是新的，只是因为没有融入现有系统而鲜有人认识）也能无所顾忌地加入，比如可以使用同一门语言实现硬件开发、底层开发、后端开发和前端开发；设计一门阅读友好的汇编语言；设计一门描述型的链接脚本语言；使用微内核，驱动能像普通程序一样开发、调试和安装；系统永不需关机和重启，可回滚的更新；系统基于能力（capability）而不是 &lt;em&gt;用户和组&lt;/em&gt; 的安全模型等等。&lt;/p&gt;&lt;p&gt;所以这套系统有相当多的特点和优点，即使你能看到类似 “从零开始构建系统” 的书籍或文章，我们这个系列仍让你耳目一新 😁。&lt;/p&gt;&lt;h2 id=&#34;点赞转发打赏&#34;&gt;点赞、转发、打赏&lt;/h2&gt;&lt;p&gt;虽然这系列文章的大部分内容我都已经实践过，不过我发现要把它们从头到尾讲解起来相当有挑战性：庞大而交叉的内容如何组织才能做到由易到难，如何挑选实践的内容，如何做到篇章之间内容的自然过渡和衔接，如何确保内容的准确，如何保证读者看得明白不卡顿等等，单单第一个系列的前两部共 8 篇文章，前前后后反复琢磨和修改，居然用了四个多月的时间。我不知道要几年时间才能把最后一章写完。&lt;/p&gt;&lt;p&gt;而另一方面，虽然从宏观上来说计算机系统技术承载着科学技术的传承和创新，承载者现代工业的基础等重要意义，但对于个人来说，却很 &amp;ldquo;现实地&amp;rdquo; 几乎没有任何用处（💰），毕竟几乎所有企业都从事应用层面的开发，系统技术无论是对普通人还是对开发人员都太过遥远了。虽然作者很努力地想写好每一篇文章，但阅读的人显然是寥寥可数的，这是极其少数人才会感兴趣的内容。因此，如果你碰巧看到这一系列文章，如果觉得有收获，请毫不犹豫地打赏作者吧 😄！你的一瓶可乐一杯冰红茶的打赏就是下一篇文章的写作动力 😭。&lt;/p&gt;&lt;div&gt;    &lt;img src=&#34;https://hemashushu.github.io/images/subscribe-and-donate.png&#34; class=&#34;block-image image-480px&#34;/&gt;&lt;/div&gt;&lt;p&gt;最后，虽然系统技术没有现实上的用处，但它可以很好地满足人类原始的 “好奇、探索、创造” 的本能。试想一下，还有什么比 “独自一人徒手征服人类文明史上最复杂的机器” 更酷的事情呢？！当你完成最后一章时，相信会看到一个不同的世界。点击下面的目录标题开始异世界之旅吧！&lt;/p&gt;&lt;hr&gt;&lt;h2 id=&#34;目录&#34;&gt;目录&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;系列 1: 一步一步深入 RISC-V 系统&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;Part 1&lt;/em&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&#34;risc-v-gcc-quick-start/&#34;&gt;S01C01 RISC-V GCC 快速入门&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;build-minimal-risc-v-program/&#34;&gt;S01C02 构建最小的 RISC-V 程序&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;qemu-and-debug/&#34;&gt;S01C03 QEMU 模拟器及程序的调试&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;em&gt;Part 2&lt;/em&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&#34;xx/&#34;&gt;S01C04 XX&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;更新中&amp;hellip;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;系列 2: 一步一步实现一门现代语言及其编译器&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;待更新&lt;/p&gt;&lt;p&gt;&lt;strong&gt;系列 3: 一步一步实现一个实用型的 RISC-V CPU&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;待更新&lt;/p&gt;&lt;p&gt;&lt;strong&gt;系列 4: 一步一步实现一个实用的微内核操作系统&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;待更新&lt;/p&gt;</description>
     </item>
   
     <item>
       <title></title>
       <link>https://hemashushu.github.io/posts/2022-11-06-risc-v-gcc-quick-start/readme/</link>
       <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
       
       <guid>https://hemashushu.github.io/posts/2022-11-06-risc-v-gcc-quick-start/readme/</guid>
       <description>&lt;h1 id=&#34;risc-v-gcc-quick-start&#34;&gt;RISC-V GCC Quick Start&lt;/h1&gt;</description>
     </item>
   
     <item>
       <title></title>
       <link>https://hemashushu.github.io/posts/2022-11-06-risc-v-gcc-quick-start/readme.zh-hans/</link>
       <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
       
       <guid>https://hemashushu.github.io/posts/2022-11-06-risc-v-gcc-quick-start/readme.zh-hans/</guid>
       <description>&lt;h1 id=&#34;risc-v-gcc-快速入门&#34;&gt;RISC-V GCC 快速入门&lt;/h1&gt;&lt;p&gt;XiaoXuan Assembler 需要其它编译器的编译结果作为参照物，而 &lt;a href=&#34;https://github.com/riscv-collab/riscv-gnu-toolchain&#34;&gt;RISC-V GCC&lt;/a&gt; 是比较完善和成熟的 RISC-V 编译器，因此 XiaoXuan Assembler 默认选用它对编译、汇编和链接的结果进行参考、验证和测试。&lt;/p&gt;&lt;p&gt;本篇文章将会构建两个非常简单的程序：一个 &amp;ldquo;Hello World!&amp;rdquo; 程序和一个裸机程序，通过构建的过程以简单了解 RISC-V GCC 的基本使用方法。&lt;/p&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&#34;#risc-v-gcc-%E4%BB%8B%E7%BB%8D&#34;&gt;RISC-V GCC 介绍&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#qemu-%E6%A8%A1%E6%8B%9F%E5%99%A8&#34;&gt;QEMU 模拟器&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F&#34;&gt;第一个程序&lt;/a&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&#34;#%E7%BC%96%E8%AF%91&#34;&gt;编译&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6&#34;&gt;可执行文件&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%B7%A5%E5%85%B7&#34;&gt;二进制工具&lt;/a&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&#34;#size&#34;&gt;&lt;code&gt;size&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#readelf&#34;&gt;&lt;code&gt;readelf&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#objdump&#34;&gt;&lt;code&gt;objdump&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#%E8%BF%90%E8%A1%8C&#34;&gt;运行&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#%E5%88%86%E9%98%B6%E6%AE%B5%E7%BC%96%E8%AF%91&#34;&gt;分阶段编译&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#%E5%B8%B8%E7%94%A8%E7%9A%84%E7%BC%96%E8%AF%91%E5%8F%82%E6%95%B0&#34;&gt;常用的编译参数&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#%E8%A3%B8%E6%9C%BA%E7%A8%8B%E5%BA%8F&#34;&gt;裸机程序&lt;/a&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&#34;#%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BB%84%E6%88%90&#34;&gt;程序的组成&lt;/a&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&#34;#%E5%9F%BA%E7%A1%80%E5%BA%93&#34;&gt;基础库&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#%E8%AE%A1%E7%AE%97%E5%BA%93&#34;&gt;计算库&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#%E4%B8%BB%E7%A8%8B%E5%BA%8F&#34;&gt;主程序&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#%E5%90%AF%E5%8A%A8%E5%99%A8&#34;&gt;启动器&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#%E7%BC%96%E8%AF%91-1&#34;&gt;编译&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#%E6%89%93%E5%8C%85%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6&#34;&gt;打包目标文件&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#%E9%93%BE%E6%8E%A5&#34;&gt;链接&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#%E8%BF%90%E8%A1%8C-1&#34;&gt;运行&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;!-- raw HTML omitted --&gt;&lt;h2 id=&#34;risc-v-gcc-介绍&#34;&gt;RISC-V GCC 介绍&lt;/h2&gt;&lt;p&gt;假设我们工作环境的架构是 &lt;em&gt;x86_64&lt;/em&gt;，现在需要把程序（的源代码）编译成可以在 RISC-V 架构上运行的程序，这种编译叫做 &lt;em&gt;交叉编译&lt;/em&gt;。相对地，在 “当前架构” 里编译出给 &amp;ldquo;当前架构&amp;rdquo; 运行的程序，这种编译叫 &lt;em&gt;本地编译&lt;/em&gt;，或者简称编译。交叉编译本质上是 &amp;ldquo;根据源代码生成目标架构的一系列指令&amp;rdquo;，交叉编译器在的实现方法跟普通的编译器是一样的，只是生成的指令不是当前架构，而是目标架构的指令。&lt;/p&gt;&lt;p&gt;在进行交叉编译时，通常需要确定 &lt;em&gt;目标架构&lt;/em&gt; 和 &lt;em&gt;目标平台&lt;/em&gt;。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;em&gt;目标架构&lt;/em&gt; 是指目标机器的 CPU 指令集架构（ISA，有时简称为 &lt;em&gt;指令集&lt;/em&gt; 也是可以的），比如常用的 Intel 和 AMD CPU 的指令集是 &lt;em&gt;x86_64&lt;/em&gt;，移动电话用的 ARM CPU 指令集是 &lt;em&gt;aarch64&lt;/em&gt;，以及项目 XiaoXuan Assembly - RISCV 的目标 CPU 的指令集是 &lt;em&gt;rv64g&lt;/em&gt; 等等。&lt;/li&gt;&lt;li&gt;&lt;em&gt;目标平台&lt;/em&gt; 是指 &lt;em&gt;目标操作系统&lt;/em&gt;，当然在开发程序时，可能还得考虑目标平台更细化的一些信息，比如目标平台是哪个 Linux 发行版，因为不同的发行版的文件系统层次结构（FHS，Filesystem Hierarchy Standard）往往有细微的差别，这会导致诸如共享库等文件的所在位置有所不同。但对于编译器来说，它只需确定目标架构和目标平台即可。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;对于 &lt;em&gt;裸机程序&lt;/em&gt;，即在 &amp;ldquo;无操作系统&amp;rdquo; 的环境里运行的程序，比如在微控制器（MCU）里运行的程序，或者内核程序，在编译时则只需确认 &lt;em&gt;目标架构&lt;/em&gt; 即可。&lt;/p&gt;&lt;p&gt;GCC 是一套常用编译工具（另一个是 LLVM），而 RISC-V GCC 则是基于 GCC 且目标架构设定为 RISC-V 的交叉编译工具。在大部分 Linux 发行版里都可以通过包管理器找到它并安装它。注意在通过包管理器安装 RISC-V GCC 的时候，可能会发现有两套名称相近的工具，比如在 &lt;em&gt;Arch Linux&lt;/em&gt; 里，有 &lt;code&gt;riscv64-elf-gcc&lt;/code&gt;、&lt;code&gt;riscv64-elf-gdb&lt;/code&gt;、&lt;code&gt;riscv64-elf-binutils&lt;/code&gt; 和 &lt;code&gt;riscv64-linux-gnu-gcc&lt;/code&gt;、&lt;code&gt;riscv64-linux-gnu-gdb&lt;/code&gt;、&lt;code&gt;riscv64-linux-gnu-binutils&lt;/code&gt;（在 &lt;em&gt;Ubuntu&lt;/em&gt; 里，它们分别叫 &lt;code&gt;gcc-riscv64-unknown-elf&lt;/code&gt;、&lt;code&gt;gcc-riscv64-linux-gnu&lt;/code&gt; 和 &lt;code&gt;gdb-multiarch&lt;/code&gt;）。前者用于编译 &amp;ldquo;裸机&amp;rdquo; 程序，后者用于编译在 Linux 环境中运行的程序，也就是我们平常所接触到的程序。条件允许的话，建议两套工具都安装。如果你系统的包仓库里没有 RISC-V GCC，则可以从 &lt;a href=&#34;https://github.com/riscv-collab/riscv-gcc&#34;&gt;官方的仓库&lt;/a&gt; 下载源码并通过源码的方式安装。&lt;/p&gt;&lt;h2 id=&#34;qemu-模拟器&#34;&gt;QEMU 模拟器&lt;/h2&gt;&lt;p&gt;对于 RISC-V GCC 生成的程序，当然需要在 RISC-V 架构的机器上运行，不过至书写本文的时间（2022 年）为止，尚未有成熟且经济的 RISC-V 硬件，大部分 RISC-V 计算机仍以开发板的形式提供。所以为了便于测试程序，XiaoXuan Assembler 是通过 &lt;a href=&#34;https://www.qemu.org/&#34;&gt;QEMU&lt;/a&gt; 模拟器来运行和测试 RISC-V 程序的。&lt;/p&gt;&lt;p&gt;大部分 Linux 发行版里的包仓库里都包含有 QEMU，所以只需使用系统的包管理器就可以安装 QEMU，比如在 &lt;em&gt;Arch Linux&lt;/em&gt; 里，需要安装包 &lt;code&gt;qemu-system-riscv&lt;/code&gt;、&lt;code&gt;qemu-user&lt;/code&gt; 和 &lt;code&gt;qemu-user-static&lt;/code&gt;（在 &lt;em&gt;Ubuntu&lt;/em&gt; 里，包名分别为 &lt;code&gt;qemu-system&lt;/code&gt;，&lt;code&gt;qemu-user&lt;/code&gt; 和 &lt;code&gt;qemu-user-static&lt;/code&gt;）。对于包仓库里没有 QEMU 的发行版，可以下载 QEMU 的源码，然后根据&lt;a href=&#34;https://wiki.qemu.org/Documentation/Platforms/RISCV&#34;&gt;这篇指引&lt;/a&gt;编译安装。&lt;/p&gt;&lt;p&gt;QEMU 可以模拟一整套完整的硬件，包括 CPU、内存、磁盘、网络接口、USB 接口等组件，除此之外，QEMU 还可以模拟一个 Linux 系统。也就是说，QEMU 有两种工作模式，前者称为 &lt;em&gt;全系统模式&lt;/em&gt;，在这种模式下可以执行所有 CPU 指令，可以运行裸机程序。后者称为 &lt;em&gt;用户模式&lt;/em&gt;，可以直接运行编译目标平台为 Linux 的程序。&lt;/p&gt;&lt;p&gt;全系统模式使用程序 &lt;code&gt;qemu-system-riscv64&lt;/code&gt; 来启动，可以通过参数指定机器类型、CPU 核心的数量、内存的容量、虚拟磁盘等。用户模式使用程序 &lt;code&gt;qemu-riscv64&lt;/code&gt; 来启动，把我们写的应用程序（可执行文件）的文件路径作为参数传给这个程序即可，在这种模式下，QEMU 会把应用程序转换为主机平台支持的程序，所以如果要写了一个向控制台打印一行字符的 &amp;ldquo;Hello world&amp;rdquo; 程序，让它跑起来的最快方法是使用 &lt;code&gt;riscv64-linux-gnu-gcc&lt;/code&gt; 编译，然后使用 &lt;code&gt;qemu-riscv64&lt;/code&gt; 来运行。&lt;/p&gt;&lt;h2 id=&#34;第一个程序&#34;&gt;第一个程序&lt;/h2&gt;&lt;p&gt;第一个程序是一个非常简单的程序，其功能是向屏幕打印一行文字 &amp;ldquo;Hello world!&amp;quot;。下面快速地过一遍编译、链接、运行的过程。&lt;/p&gt;&lt;p&gt;第一个程序的源代码文件位于目录 &lt;a href=&#34;./resources/hello-world/&#34;&gt;resources/hello-world&lt;/a&gt; 里，文件名为 &lt;code&gt;app.c&lt;/code&gt;，其内容如下：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Hello world!&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;编译&#34;&gt;编译&lt;/h3&gt;&lt;p&gt;首先切换到文本所在的目录的子目录 &lt;a href=&#34;./resources/hello-world/&#34;&gt;resources/hello-world&lt;/a&gt;：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ cd resources/hello-world&lt;/code&gt;&lt;/p&gt;&lt;p&gt;因为这不是 &amp;ldquo;裸机&amp;rdquo; 程序，因此需要使用 &lt;code&gt;riscv64-linux-gnu-gcc&lt;/code&gt; 来编译：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ riscv64-linux-gnu-gcc -g -Wall -o app.out app.c&lt;/code&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;参数 &lt;code&gt;-g&lt;/code&gt; 用于生成额外的调试信息（可供 GDB 使用）；&lt;/li&gt;&lt;li&gt;参数 &lt;code&gt;-Wall&lt;/code&gt; 用于报告编译过程中的所有警告和错误信息；&lt;/li&gt;&lt;li&gt;参数 &lt;code&gt;-o app.out&lt;/code&gt; 用于指定输出的文件的名称，如果缺省这个参数，默认的输出文件名为 &lt;code&gt;a.out&lt;/code&gt;。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;编译完成后得到文件 &lt;code&gt;app.out&lt;/code&gt;。&lt;/p&gt;&lt;h3 id=&#34;可执行文件&#34;&gt;可执行文件&lt;/h3&gt;&lt;p&gt;使用 &lt;code&gt;file&lt;/code&gt; 命令可以查看该文件的格式：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ file app.out&lt;/code&gt;&lt;/p&gt;&lt;p&gt;输出结果如下：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;app.out: ELF 64-bit LSB pie executable, UCB RISC-V, RVC, double-float ABI, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux-riscv64-lp64d.so.1, BuildID[sha1]=eb3dabb395852de771d6ac7129d1da24ca574350, for GNU/Linux 4.15.0, with debug_info, not stripped&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;ELF&lt;/code&gt; 和 &lt;code&gt;executable&lt;/code&gt;，表明当前文件是一个 ELF 格式当中的 &lt;em&gt;可执行文件&lt;/em&gt;。ELF 格式的文件主要有 3 种类型：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;code&gt;executable&lt;/code&gt; 是 &lt;em&gt;可执行文件&lt;/em&gt;；&lt;/li&gt;&lt;li&gt;&lt;code&gt;shared object&lt;/code&gt; 是 &lt;em&gt;共享对象文件&lt;/em&gt;，也就是共享库，用于在运行时动态地被可执行文件链接（或者说 &lt;em&gt;调用&lt;/em&gt;）。&lt;/li&gt;&lt;li&gt;&lt;code&gt;relocatable&lt;/code&gt; 是 &lt;em&gt;可重定向文件&lt;/em&gt;，即编译任务中途产生的 &lt;em&gt;目标文件&lt;/em&gt;，当只编译而不链接一个 C 源代码文件时，产生的正是这种类型的文件。这种 &amp;ldquo;中间阶段产生&amp;rdquo; 的文件主要用来链接，以产生最后的结果 ———— 可执行文件或者共享库。&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;dynamically linked&lt;/code&gt;, &lt;code&gt;interpreter ...&lt;/code&gt;，表明当前可执行文件是 &lt;em&gt;动态链接&lt;/em&gt; 类型，也就是说它在运行时，要需要其它共享库的帮忙才能完成所有工作。而这些库的加载任务则由 &lt;code&gt;interpreter&lt;/code&gt; 指定的程序来完成，或者说 &lt;code&gt;interpreter&lt;/code&gt; 指定的是一个 &lt;em&gt;运行时动态链接器&lt;/em&gt;，或者简单理解为 &lt;em&gt;应用程序初始化器，共享库加载器&lt;/em&gt;。可执行文件还可以是 &lt;em&gt;静态链接&lt;/em&gt; 类型，表示它在运行时不需要其它共享库帮忙，只需操作系统的支持，其它的工作全部自己完成。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;pie&lt;/code&gt;，表明当前的可执行文件是 &lt;code&gt;位置无关的可执行文件&lt;/code&gt;（&lt;code&gt;Position Independent Executables&lt;/code&gt;），这部分内容将会在本项目的其它文章里讲解。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;64-bit&lt;/code&gt;, &lt;code&gt;RISC-V&lt;/code&gt;, &lt;code&gt;double-float ABI&lt;/code&gt;，&lt;code&gt;GNU/Linux 4.15.0&lt;/code&gt;，这些零散的信息表明当前可执行文件的目标架构、目标平台以及目标平台的一些细化信息，这些内容将会在本项目的其它文章里讲解。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;LSB&lt;/code&gt;，表明当前可执行文件里的数据是 &amp;ldquo;低端字节优先&amp;rdquo;（&amp;ldquo;least-significant byte first&amp;rdquo;）的，相当于平常说的 &amp;ldquo;低端序&amp;rdquo;（&amp;ldquo;little-endian&amp;rdquo;）。相对的，还有 &lt;code&gt;MSB&lt;/code&gt;，即 &amp;ldquo;高端字节优先&amp;rdquo;（&amp;ldquo;most-significant byte&amp;rdquo;），相当于 &amp;ldquo;高端序&amp;rdquo;（&amp;ldquo;big-endian&amp;rdquo;）。这决定了一个整数在内存或者磁盘种如何储存，比如数字 &lt;code&gt;0x11223344&lt;/code&gt;，在内存中如果使用 &lt;code&gt;LSB&lt;/code&gt;，则被储存为 &amp;ldquo;(低地址) 44 33 22 11 （高地址）&amp;quot;，如果使用 &lt;code&gt;MSB&lt;/code&gt;，则会被储存为 &amp;ldquo;(低地址) 11 22 33 44（高地址）&amp;quot;。用十六进制查看器查看 &lt;code&gt;LSB&lt;/code&gt; 类型的可执行文件的内容时，如果看的内容是数字，那么需要在脑海里把数字反过来再组合才是它的真实值，而如果看的内容是字符串，则可以很自然地顺序阅读。简单来说，看数字很头痛，看文本很舒畅，而 &lt;code&gt;MSB&lt;/code&gt; 则刚好相反。不过这都是人类才有的烦恼，对于计算机来说都是一样的哦。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;with debug_info&lt;/code&gt;, &lt;code&gt;not stripped&lt;/code&gt;，表明当前可执行文件里包含调试信息。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;code&gt;file&lt;/code&gt; 命令只能非常粗略地查看文件的格式和类型，如果想详细了解 &lt;code&gt;ELF&lt;/code&gt; 的内容，还需要下面的二进制工具。&lt;/p&gt;&lt;h3 id=&#34;二进制工具&#34;&gt;二进制工具&lt;/h3&gt;&lt;p&gt;在安装 RISC-V GCC 时，还同时安装了 RISC-V Binutils，这套工具链提供了跟 &lt;a href=&#34;https://www.gnu.org/software/binutils/&#34;&gt;GNU Binutils&lt;/a&gt; 对应的工具。&lt;/p&gt;&lt;h4 id=&#34;size&#34;&gt;&lt;code&gt;size&lt;/code&gt;&lt;/h4&gt;&lt;p&gt;首先是查看程序大小的工具 &lt;code&gt;size&lt;/code&gt;：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ riscv64-linux-gnu-size app.out&lt;/code&gt;&lt;/p&gt;&lt;p&gt;输出结果如下：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   text    data     bss     dec     hex filename&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   1123     584       8    1715     6b3 app.out&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;text&lt;/code&gt; 表示程序的指令序列；&lt;/li&gt;&lt;li&gt;&lt;code&gt;data&lt;/code&gt; 表示程序的初始数据；&lt;/li&gt;&lt;li&gt;&lt;code&gt;bss&lt;/code&gt; 表示未初始化的（或者初始值为 &lt;code&gt;0&lt;/code&gt; 的）全局变量。&lt;/li&gt;&lt;li&gt;&lt;code&gt;dec&lt;/code&gt; 和 &lt;code&gt;hex&lt;/code&gt; 是前面三项内容的大小（单位为字节）的总和的十进制和十六进制。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;需要注意的是 &lt;code&gt;bss&lt;/code&gt; 的数值用于在内存里提前分配空间，除了一个整数之外，本身不占文件任何空间，但在统计时，仍然把它也加上了。&lt;/p&gt;&lt;p&gt;根据上面显示的数值可知，编译器在我们写的应用程序里塞入了不少的额外的内容，毕竟当前程序只有一个只包含一条 &lt;code&gt;printf&lt;/code&gt; 语句的函数，这样的一条语句不太可能对应 1000 多个字节的指令，而且文本内容 &amp;ldquo;Hello world!\n&amp;rdquo; 也没有 500 多字节。&lt;/p&gt;&lt;h4 id=&#34;readelf&#34;&gt;&lt;code&gt;readelf&lt;/code&gt;&lt;/h4&gt;&lt;p&gt;工具 &lt;code&gt;readelf&lt;/code&gt; 可以查看该 ELF 文件的详细信息：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ riscv64-linux-gnu-readelf -l app.out&lt;/code&gt;&lt;/p&gt;&lt;p&gt;输出的（部分）结果如下：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Elf file type is DYN (Position-Independent Executable file)&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Entry point 0x5b0&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;There are 10 program headers, starting at offset 64&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Program Headers:&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  Type           Offset             VirtAddr           PhysAddr&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                 FileSiz            MemSiz              Flags  Align&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  LOAD           0x0000000000000000 0x0000000000000000 0x0000000000000000&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                 0x00000000000006e4 0x00000000000006e4  R E    0x1000&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  LOAD           0x0000000000000e08 0x0000000000001e08 0x0000000000001e08&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                 0x0000000000000248 0x0000000000000250  RW     0x1000&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; Section to Segment mapping:&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  Segment Sections...&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   03     .interp .note.gnu.build-id .note.ABI-tag .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn .rela.plt .plt .text .rodata .eh_frame_hdr .eh_frame&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   04     .preinit_array .init_array .fini_array .dynamic .data .got .bss&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;下面简单讲解上面的内容：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;LOAD&lt;/code&gt; 表示将会被加载进内存的 segment（因为 &lt;code&gt;segment&lt;/code&gt; 和 &lt;code&gt;section&lt;/code&gt; 在中文里都叫作 &lt;code&gt;段&lt;/code&gt;，所以这里直接使用英文名称。一般情况下 &lt;code&gt;段&lt;/code&gt; 是指 &lt;code&gt;section&lt;/code&gt;），下方的 &lt;code&gt;Section to Segment mapping&lt;/code&gt; 列举了每个 segment 由哪些 section 组成。&lt;/p&gt;&lt;p&gt;ELF 文件的主要内容由多个段（section）组成，这些段可以形成两个视图：从程序加载器的角度看，有一个叫 &lt;code&gt;segments&lt;/code&gt; 的视图；从编译器、链接器角度看有一个叫 &lt;code&gt;sections&lt;/code&gt; 的视图。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;LOAD&lt;/code&gt; 项目显示了 segment 的文件偏移地址、虚拟地址、物理地址、在文件中的大小、在内存中的大小、标记等信息（这些内容会在本项目的其它文章种讲解）。这些信息会决定程序加载器如何处理 segment，比如 &lt;code&gt;RE&lt;/code&gt; 标记表示这段内容在内存中具有 &amp;ldquo;read, execute&amp;rdquo; 权限，&lt;code&gt;RW&lt;/code&gt; 标记表示这段内容在内存中具有 &amp;ldquo;read, write&amp;rdquo; 权限。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote&gt;&lt;p&gt;在现代的 CPU 内存管理单元里，物理内存被虚拟化，并以固定的大小（比如 4KB）划分为一个个区块（叫作 &lt;em&gt;页面&lt;/em&gt;），每个内存页面都可以有不同的权限，比如有些内存页面只可读、有些可读写、有些可执行。&lt;/p&gt;&lt;/blockquote&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;Entry point 0x5b0&lt;/code&gt; 表示程序的入口，即程序第一个会被执行的指令，位于地址 &lt;code&gt;0x5b0&lt;/code&gt;，。&lt;/li&gt;&lt;/ul&gt;&lt;h4 id=&#34;objdump&#34;&gt;&lt;code&gt;objdump&lt;/code&gt;&lt;/h4&gt;&lt;p&gt;工具 &lt;code&gt;objdump&lt;/code&gt; 可以反汇编可执行文件当中的代码段，查看位置 &lt;code&gt;0x5b0&lt;/code&gt; 的内容：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ riscv64-linux-gnu-objdump -d app.out&lt;/code&gt;&lt;/p&gt;&lt;p&gt;输出（部分）结果如下：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Disassembly of section .text:&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;...&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;00000000000005b0 &amp;lt;_start&amp;gt;:&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 5b0:   022000ef                jal     ra,5d2 &amp;lt;load_gp&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 5b4:   87aa                    mv      a5,a0&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 5b6:   00002517                auipc   a0,0x2&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 5ba:   a8253503                ld      a0,-1406(a0) # 2038 &amp;lt;_GLOBAL_OFFSET_TABLE_+0x10&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 5be:   6582                    ld      a1,0(sp)&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 5c0:   0030                    addi    a2,sp,8&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 5c2:   ff017113                andi    sp,sp,-16&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 5c6:   4681                    li      a3,0&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 5c8:   4701                    li      a4,0&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 5ca:   880a                    mv      a6,sp&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 5cc:   fc5ff0ef                jal     ra,590 &amp;lt;__libc_start_main@plt&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 5d0:   9002                    ebreak&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;看到这里你可能感到很惊讶，原来程序的入口（即最先开始执行的指令）并不是 &lt;code&gt;main&lt;/code&gt; 函数，而是一个名为 &lt;code&gt;_start&lt;/code&gt; 的过程（大部分 C 语言的教科书或者教程都跟我们说：程序的入口是 &lt;code&gt;main&lt;/code&gt; 函数，这是一个善意的谎言）。&lt;code&gt;_start&lt;/code&gt; 过程会做一系列的初始化工作，然后才会调用 &lt;code&gt;main&lt;/code&gt; 函数，在 &lt;code&gt;main&lt;/code&gt; 函数执行完毕之后，它还会做一些清理工作。&lt;/p&gt;&lt;p&gt;在上一个输出的结果里往下翻，就可以找到函数 &lt;code&gt;main&lt;/code&gt; 的内容：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;0000000000000668 &amp;lt;main&amp;gt;:&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 668:   1141                    addi    sp,sp,-16&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 66a:   e406                    sd      ra,8(sp)&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 66c:   e022                    sd      s0,0(sp)&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 66e:   0800                    addi    s0,sp,16&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 670:   00000517                auipc   a0,0x0&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 674:   02050513                addi    a0,a0,32 # 690 &amp;lt;_IO_stdin_used+0x8&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 678:   f29ff0ef                jal     ra,5a0 &amp;lt;puts@plt&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 67c:   0001                    nop&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 67e:   60a2                    ld      ra,8(sp)&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 680:   6402                    ld      s0,0(sp)&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 682:   0141                    addi    sp,sp,16&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 684:   8082                    ret&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;该段指令包含了普通函数的 &lt;em&gt;开场白&lt;/em&gt; 和 &lt;em&gt;收场白&lt;/em&gt; 模板代码，以及一句对函数 &lt;code&gt;puts&lt;/code&gt; 的调用。&lt;/p&gt;&lt;h3 id=&#34;运行&#34;&gt;运行&lt;/h3&gt;&lt;p&gt;因为 &lt;code&gt;app.out&lt;/code&gt; 不是 &amp;ldquo;裸机&amp;rdquo; 程序，它依赖平台（即操作系统，平台提供了包括程序加载、内存分配和系统调用等功能）才能运行，为了简单起见，可以使用 QEMU 模拟器的 &lt;em&gt;用户模式&lt;/em&gt; 程序 &lt;code&gt;qemu-riscv64&lt;/code&gt; 来运行：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ qemu-riscv64 app.out&lt;/code&gt;&lt;/p&gt;&lt;p&gt;运行的结果是：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;qemu-riscv64: Could not open &amp;#39;/lib/ld-linux-riscv64-lp64d.so.1&amp;#39;: No such file or directory&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;显然程序并没有正确地运行，这是因为当前应用程序调用了 &lt;code&gt;printf&lt;/code&gt; 函数，而这个函数实际上是调用了标准库的函数 &lt;code&gt;puts&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;RISC-V GCC 默认产生动态链接类型的程序，在运行这种程序时需要一个 &lt;em&gt;运行时动态链接器&lt;/em&gt;（在当前的例子里，它就是 &lt;code&gt;ld-*.so&lt;/code&gt;）加载程序所需的共享库，以及进行一系列的初始化工作（比如寻找标准库当中函数 &lt;code&gt;puts&lt;/code&gt; 的地址）。然而不幸的是 &lt;code&gt;qemu-riscv64&lt;/code&gt; 好像不能正确地定位 &lt;code&gt;ld-*.so&lt;/code&gt;。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;虽然 &lt;em&gt;动态链接&lt;/em&gt; 概念对操作系统来说是不错的主意，但对于普通用户来说，应用程序的动态链接导致的问题令人相当头痛。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;河马蜀黍暂时没找到优雅地解决该问题的方法，因此下面换一种方式：生成静态链接类型的可执行文件。即在用 GCC 编译时传入 &lt;code&gt;-static&lt;/code&gt; 参数，用于指示 GCC 生成静态链接的程序，也就是说，GCC 会把被调用的外部函数的二进制代码（即指令序列）复制进我们的可执行文件里，这样程序在运行时就不需要其它共享库了，自然也不需要 &lt;code&gt;ld.so&lt;/code&gt; 了，它直接跟操作系统打交道：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ riscv64-linux-gnu-gcc -static -o app.static.out app.c&lt;/code&gt;&lt;/p&gt;&lt;p&gt;先看看文件格式：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ file app.static.out&lt;/code&gt;&lt;/p&gt;&lt;p&gt;输出结果：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;app.static.out: ELF 64-bit LSB executable, UCB RISC-V, RVC, double-float ABI, version 1 (SYSV), statically linked, BuildID[sha1]=e5483614d4b600c22bdada95913a953eae577965, for GNU/Linux 4.15.0, with debug_info, not stripped&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;原先的 &amp;ldquo;dynamically linked&amp;rdquo; 已经变为 &amp;ldquo;statically linked&amp;rdquo;。再看看文件的大小：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ riscv64-linux-gnu-size app.static.out&lt;/code&gt;&lt;/p&gt;&lt;p&gt;输出结果如下：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   text    data     bss     dec     hex filename&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 387532   22024   21760  431316   694d4 app.static.out&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;代码段的大小从 1KB 多增长到近 400KB，这是因为链接器把所用到的函数的二进制代码都复制过来了，如果反汇编 &lt;code&gt;app.static.out&lt;/code&gt; 将会得到超长的文本，因此这里就略过了，下面运行这个静态链接的可执行文件：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ qemu-riscv64 app.static.out&lt;/code&gt;&lt;/p&gt;&lt;p&gt;这次得到了预期的结果：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Hello world!&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;那么究竟有没办法用 &lt;code&gt;qemu-riscv64&lt;/code&gt; 运行动态链接的程序呢？方法当然是有的，只需让 &lt;code&gt;qemu-riscv64&lt;/code&gt; 找到 &lt;code&gt;ld.so&lt;/code&gt; 的正确路径就可以了！&lt;/p&gt;&lt;p&gt;如果你的系统是 &lt;em&gt;Arch Linux&lt;/em&gt;，会发现文件 &lt;code&gt;ld-linux-riscv64-lp64d.so.1&lt;/code&gt; 的正确目录是 &lt;code&gt;/usr/riscv64-linux-gnu/lib&lt;/code&gt;，按照 &lt;code&gt;qemu-riscv64&lt;/code&gt; 的说明，只要把这个路径通过参数 &lt;code&gt;-L /path/to/ld.so&lt;/code&gt; 或者环境变量 &lt;code&gt;QEMU_LD_PREFIX&lt;/code&gt; 传入即可，然而河马蜀黍并没有成功（原因未知）。下面演示另一种解决方法，即指定程序的 &lt;em&gt;运行时动态链接器&lt;/em&gt;，操作步骤如下：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;p&gt;在链接时传入参数 &lt;code&gt;--dynamic-linker /path/to/ld.so&lt;/code&gt; 更改程序的 &lt;code&gt;interpreter&lt;/code&gt;，命令如下：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ riscv64-linux-gnu-gcc -g -Wall -Wl,--dynamic-linker,/usr/riscv64-linux-gnu/lib/ld-linux-riscv64-lp64d.so.1 -o app.out app.c -L /usr/riscv64-linux-gnu/lib -lc&lt;/code&gt;&lt;/p&gt;&lt;p&gt;编译完毕之后，可以使用 &lt;code&gt;file&lt;/code&gt; 命令检查程序：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ file app.out&lt;/code&gt;&lt;/p&gt;&lt;p&gt;输出结果如下：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;app.out: ELF 64-bit LSB pie executable, UCB RISC-V, RVC, double-float ABI, version 1 (SYSV), dynamically linked, interpreter /usr/riscv64-linux-gnu/lib/ld-linux-riscv64-lp64d.so.1, BuildID[sha1]=973ca74e3c1f08bde10d29d173aa6370ab947b2b, for GNU/Linux 4.15.0, with debug_info, not stripped&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可见 &lt;code&gt;interpreter&lt;/code&gt; 已经成功更改为指定的路径。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;在运行程序的时候，添加 RISC-V Linux GNU 共享库的位置：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ LD_LIBRARY_PATH=/usr/riscv64-linux-gnu/lib qemu-riscv64 app.out&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;如此一来就能正确运行程序了。&lt;/p&gt;&lt;p&gt;上面的命令的参数非常多，具体的含义，以及优雅的编译和运行动态链接程序的方法，请看本项目的另一篇文章 &lt;a href=&#34;../dynamic-linking/README.zh-Hans.md&#34;&gt;动态链接的原理&lt;/a&gt;。&lt;/p&gt;&lt;h3 id=&#34;分阶段编译&#34;&gt;分阶段编译&lt;/h3&gt;&lt;p&gt;当执行命令 &lt;code&gt;riscv64-linux-gnu-gcc&lt;/code&gt; 将一个 C 源代码编译为一个可执行文件时，实际上 GCC 是分 4 个阶段（或者说步骤）来完成的：&lt;/p&gt;&lt;p&gt;&lt;img src=&#34;images/gcc-compile-stage.png&#34; alt=&#34;GCC compile stages&#34;&gt;&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;p&gt;预处理&lt;/p&gt;&lt;p&gt;将源代码里的 &lt;code&gt;include&lt;/code&gt; 文件包含进来，解析其中的条件编译指令（&lt;code&gt;#ifdef&lt;/code&gt;），展开宏（&lt;code&gt;macro&lt;/code&gt;）等。相当于命令：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ riscv64-linux-gnu-cpp app.c &amp;gt; app.i&lt;/code&gt;&lt;/p&gt;&lt;p&gt;或者&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ riscv64-linux-gnu-gcc -E app.c &amp;gt; app.i&lt;/code&gt;&lt;/p&gt;&lt;p&gt;注意上面程序 &lt;code&gt;riscv64-linux-gnu-cpp&lt;/code&gt; 当中的 &amp;ldquo;cpp&amp;rdquo; 是指 &amp;ldquo;C Preprocessor&amp;rdquo;，而不是 &amp;ldquo;C++&amp;rdquo; 的意思。经过预处理的 C 语言源代码文件的扩展名为 &lt;code&gt;*.i&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;编译&lt;/p&gt;&lt;p&gt;将 C 代码编译为汇编代码，相当于命令：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ riscv64-linux-gnu-gcc -S app.i&lt;/code&gt;&lt;/p&gt;&lt;p&gt;第 1 到第 2 步也可以一步完成：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ riscv64-linux-gnu-gcc -S app.c&lt;/code&gt;&lt;/p&gt;&lt;p&gt;生成的汇编源代码文件的扩展名为 &lt;code&gt;*.s&lt;/code&gt;，注意这跟我们手写的汇编源代码文件扩展名 &lt;code&gt;*.S&lt;/code&gt; 不同。大写 &lt;code&gt;S&lt;/code&gt; 表示会经过预处理（比如处理 &lt;code&gt;.include&lt;/code&gt; 指令）在进入下一步的汇编处理，而小写的 &lt;code&gt;s&lt;/code&gt; 表示不会进行预处理。具体的扩展名和 GCC 参数可以参考&lt;a href=&#34;https://gcc.gnu.org/onlinedocs/gcc/Overall-Options.html&#34;&gt;这篇文章&lt;/a&gt;。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;汇编&lt;/p&gt;&lt;p&gt;将汇编代码转换为机器指令序列，并生成目标文件，相当于命令：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ riscv64-linux-gnu-as -o app.o app.s&lt;/code&gt;&lt;/p&gt;&lt;p&gt;第 1 到第 3 步也可以一步完成：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ riscv64-linux-gnu-gcc -c -o app.o app.c&lt;/code&gt;&lt;/p&gt;&lt;p&gt;参数 &lt;code&gt;-c&lt;/code&gt; 表示只编译但不链接。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;链接&lt;/p&gt;&lt;p&gt;将多个目标文件链接起来，并重新定位其中的全局变量和函数的地址，最后生成 ELF 格式的可执行文件，相当于命令：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ riscv64-linux-gnu-ld -o app.out app_startup.o app.o&lt;/code&gt;&lt;/p&gt;&lt;p&gt;上面的命令会将 &lt;code&gt;app_startup.o&lt;/code&gt; 和 &lt;code&gt;app.o&lt;/code&gt; 两个目标文件链接起来并生成（动态链接类型的）可执行文件 &lt;code&gt;app.out&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;注意，上面的 &lt;code&gt;app_startup.o&lt;/code&gt; 是一个假象的应用程序启动器（提供应用的入口 &lt;code&gt;_start&lt;/code&gt; 过程以及做一些初始化和清理工作），在当前示例的源代码目录里并不存在，所以上面的命令并不能成功地运行。&lt;/p&gt;&lt;p&gt;上面的第 1 到 第 4 个步骤可以一步完成：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ riscv64-linux-gnu-gcc -o app.out app.c&lt;/code&gt;&lt;/p&gt;&lt;p&gt;如果你想知道 GCC 在编译过程中的每个步骤以及细节，可以传入 &lt;code&gt;-v&lt;/code&gt; 参数，比如 &lt;code&gt;$ riscv64-linux-gnu-gcc -v -o app.out app.c&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote&gt;&lt;p&gt;在平常的编译程序任务中，我们并不需要分成 4 步，一般只需分成 &lt;em&gt;编译&lt;/em&gt; 和 &lt;em&gt;链接&lt;/em&gt; 2 步，而且一般都是借助诸如 &lt;code&gt;make&lt;/code&gt; 等构建工具来完成。但我们仍然需要清楚知道编译器的各个阶段的作用，理解这些概念有助于解决在编译过程遇到的各种问题。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 id=&#34;常用的编译参数&#34;&gt;常用的编译参数&lt;/h3&gt;&lt;p&gt;除了上面已经演示过的，GCC 还有一些其它常用的参数：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;-I&lt;/code&gt; 用于指定头文件的路径&lt;/p&gt;&lt;p&gt;有时头文件（&lt;code&gt;*.h&lt;/code&gt;）分布在多个目录，这时可以用参数 &lt;code&gt;-I&lt;/code&gt; 把额外的头文件的路径包含进来，比如当前的路径为 &lt;code&gt;/home/yang/hello-world/app.c&lt;/code&gt;，假如有额外的头文件位于 &lt;code&gt;/home/yang/hello-world/include/&lt;/code&gt;，则可以这样传入参数：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ riscv64-linux-gnu-gcc -I /home/yang/hello-world/include app.c&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;-L&lt;/code&gt; 和 &lt;code&gt;-l&lt;/code&gt; 用于指定额外库的路径和名称&lt;/p&gt;&lt;p&gt;接着上一个例子，如果应用程序需要使用到库 &lt;code&gt;/home/yang/hello-world/lib/libmymath.a&lt;/code&gt;，则可以这样传入参数：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ riscv64-linux-gnu-gcc app.c -L /home/yang/hello-world/lib -lmymath&lt;/code&gt;&lt;/p&gt;&lt;p&gt;其中参数 &lt;code&gt;-lmymath&lt;/code&gt; 的 &lt;code&gt;-l&lt;/code&gt; 是参数名称，&lt;code&gt;mymath&lt;/code&gt; 是参数值，等效于 &lt;code&gt;-l mymath&lt;/code&gt;。这个参数表示编译过程会使用到库文件 &lt;code&gt;libmymath.a&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;注意参数 &lt;code&gt;-l&lt;/code&gt; 的值是库的 &lt;code&gt;soname&lt;/code&gt;，比如上例种库文件的真实名称是 &lt;code&gt;libmymath.a&lt;/code&gt;，去除了前缀 &lt;code&gt;lib&lt;/code&gt; 和后缀 &lt;code&gt;.a&lt;/code&gt;（或者 &lt;code&gt;.so&lt;/code&gt;）之后就是 &lt;code&gt;soname&lt;/code&gt; 了。更多的例子，比如 &lt;code&gt;libm.so&lt;/code&gt; 的 &lt;code&gt;soname&lt;/code&gt; 是单独一个字母 &lt;code&gt;m&lt;/code&gt;，&lt;code&gt;libpthread.so&lt;/code&gt; 的是 &lt;code&gt;pthread&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote&gt;&lt;p&gt;注意：一般需要把参数 &lt;code&gt;-L ... -l ...&lt;/code&gt; 放在命令的末尾，也就是依赖项的顺序必须遵循 &amp;ldquo;被依赖的放在后面&amp;rdquo; 的原则，如果顺序不对有可能导致链接失败。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;GCC 的编译过程是松散的，它由上一节所述的 4 个相对独立的阶段组成，显然头文件是在预处理阶段使用，而库文件则是在链接阶段使用，当使用一个 GCC 命令编译一个程序时，参数 &lt;code&gt;-I -L -l&lt;/code&gt; 需要全部填上。&lt;/p&gt;&lt;h2 id=&#34;裸机程序&#34;&gt;裸机程序&lt;/h2&gt;&lt;p&gt;裸机程序是指在 &amp;ldquo;无操作系统&amp;rdquo; 的环境中运行的程序，听起来可能会觉得很神奇：一个机器不用安装操作系统也能运行应用程序？是的，很显然诸如操作系统的引导器，以及操作系统本身就是裸机程序。&lt;/p&gt;&lt;p&gt;裸机程序跟普通应用程序并没有太大的区别，其中的数值计算、流程控制、程序的结构等跟普通应用程序是一摸一样的，只是在进行一些特权或者 I/O 操作时，需要直接跟硬件（包括 CPU 和外设）打交道，而不能让操作系统代劳（一般的程序是通过调用标准库，标准库再向操作系统发起 &lt;em&gt;系统调用&lt;/em&gt; 等一系列过程实现）。&lt;/p&gt;&lt;p&gt;幸好跟硬件打交道都不算太复杂，有些硬件在电路里被映射到某段内存地址，比如串口控制台，你只需把它们当作内存来读写，再稍微经过位运算等处理，即可获取这些硬件的状态数据或者更改它们的状态；有些硬件有专门的 CPU 指令来操作，裸机程序只需编写相应的汇编代码即可。&lt;/p&gt;&lt;p&gt;下面是一个 &amp;ldquo;裸机&amp;rdquo; 版的 &amp;ldquo;Hello world!&amp;rdquo; 程序，该程序实现 3 个功能：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;向串口控制台打印一行 &amp;ldquo;Hello world!&amp;rdquo; 文本；&lt;/li&gt;&lt;li&gt;计算两个整数的和并显示其结果；&lt;/li&gt;&lt;li&gt;计算一个整数加上 10 之后的值，并显示其结果。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;该程序的源文件数量比较多，涉及的新鲜概念也比较多，在这篇文章里暂时不会作细致的分析，如果对其中的细节或者原理有疑惑，可以暂时忽略。后续的文章会有详细的讲解，你可以在阅读完后续的文章之后再回来看该程序的内容。&lt;/p&gt;&lt;p&gt;这个章节仅为了简单介绍用 GCC 编译裸机程序的过程。&lt;/p&gt;&lt;h3 id=&#34;程序的组成&#34;&gt;程序的组成&lt;/h3&gt;&lt;p&gt;程序由下列几个部分组成：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;基础库 &lt;code&gt;put_char.S&lt;/code&gt; 和 &lt;code&gt;libprint.c&lt;/code&gt;&lt;/li&gt;&lt;li&gt;计算库 &lt;code&gt;liba.c&lt;/code&gt; 和 &lt;code&gt;libb.c&lt;/code&gt;&lt;/li&gt;&lt;li&gt;主程序 &lt;code&gt;app.c&lt;/code&gt;&lt;/li&gt;&lt;li&gt;启动器 &lt;code&gt;app_startup.S&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 id=&#34;基础库&#34;&gt;基础库&lt;/h4&gt;&lt;p&gt;因为没有操作系统的支持，显然无法直接使用 &lt;code&gt;printf&lt;/code&gt; 函数，但我们可以编写一个功能相近的简单函数。&lt;/p&gt;&lt;p&gt;具体来说，该应用程序准备在虚拟机 RISC-V QEMU 中运行，通过查看 &lt;a href=&#34;https://github.com/qemu/qemu/blob/master/hw/riscv/virt.c&#34;&gt;QEMU RISC-V virt 的源代码&lt;/a&gt; 可以找到一些基本硬件的内存映射关系：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; MemMapEntry virt_memmap[] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ...&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    [VIRT_MROM] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;         {     &lt;span style=&#34;color:#ae81ff&#34;&gt;0x1000&lt;/span&gt;,        &lt;span style=&#34;color:#ae81ff&#34;&gt;0xf000&lt;/span&gt; },&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    [VIRT_UART0] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;        { &lt;span style=&#34;color:#ae81ff&#34;&gt;0x10000000&lt;/span&gt;,         &lt;span style=&#34;color:#ae81ff&#34;&gt;0x100&lt;/span&gt; },&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    [VIRT_FLASH] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;        { &lt;span style=&#34;color:#ae81ff&#34;&gt;0x20000000&lt;/span&gt;,     &lt;span style=&#34;color:#ae81ff&#34;&gt;0x4000000&lt;/span&gt; },&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    [VIRT_DRAM] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;         { &lt;span style=&#34;color:#ae81ff&#34;&gt;0x80000000&lt;/span&gt;,           &lt;span style=&#34;color:#ae81ff&#34;&gt;0x0&lt;/span&gt; },&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ...&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其中串口通信 UART 被映射到 &lt;code&gt;0x1000_0000&lt;/code&gt;，这表明只需向该内存地址写入一个 byte 类型整数，该整数对应的 ASCII 字符就会被重定向到虚拟终端。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;并非所有的硬件读写都是这种方式，后续的文章会详细讲解如何用汇编写驱动，比如 GPIO，I2C 等控制。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;所以要实现打印单个字符的函数是很简单的，在目录 &lt;a href=&#34;./resources/bare-metal/&#34;&gt;resources/bare-metal&lt;/a&gt; 里有源代码文件 &lt;code&gt;put_char.S&lt;/code&gt;，其内容如下：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-S&#34; data-lang=&#34;S&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.equ VIRT_UART0, &lt;span style=&#34;color:#ae81ff&#34;&gt;0x10000000&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.section .text.put_char&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.globl put_char&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;put_char&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    li s1, VIRT_UART0&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    mv s2, a0&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    sb s2, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;(s1)&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ret&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;&lt;p&gt;因为这段程序在虚拟机上运行，所以这里忽略了 UART 发送所需的延迟。如果是在真实硬件上编写发送字符的程序，应该检查 UART TX FIFO 的值，仅当上一个字符发送完毕之后（即 TX 空闲之后）再发送下一个字符，毕竟 CPU 的工作频率比 UART 的高很多。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;打印字符函数也可以用 C 语言实现，源代码文件是 &lt;code&gt;put_char.c&lt;/code&gt;，其内容如下：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#define VIRT_UART0 0x10000000&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;volatile&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; VIRT_UART0_PTR &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;)VIRT_UART0;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;put_char&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; c)&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;VIRT_UART0_PTR &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; c;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;因为这段 C 代码所表达的意思不够汇编的那么明确，所以选用了汇编版本。&lt;/p&gt;&lt;p&gt;在此基础之上，可以用 C 语言实现 &lt;code&gt;print_char&lt;/code&gt;，&lt;code&gt;print_string&lt;/code&gt; 和 &lt;code&gt;print_int&lt;/code&gt; 等函数，以方便后续的调用。源代码文件为 &lt;code&gt;libprint.c&lt;/code&gt;，其内容如下：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;#34;put_char.h&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;print_char&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; c)&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    put_char((&lt;span style=&#34;color:#66d9ef&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;)c);&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;print_string&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;str)&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;str &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;\0&amp;#39;&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        print_char(&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;str);&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        str&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;print_int&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i)&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; s[&lt;span style=&#34;color:#ae81ff&#34;&gt;21&lt;/span&gt;];&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    itoa(i, s, &lt;span style=&#34;color:#ae81ff&#34;&gt;21&lt;/span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    print_string(s);&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;至此，应用程序已经有打印字符、字符串和数字的能力了。&lt;/p&gt;&lt;h4 id=&#34;计算库&#34;&gt;计算库&lt;/h4&gt;&lt;p&gt;接下来实现整数相加等数学函数，源代码文件分别为 &lt;code&gt;liba.c&lt;/code&gt; 和 &lt;code&gt;libb.c&lt;/code&gt;，其内容如下：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// liba.c&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;add&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; a, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; b)&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; a &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; b;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// libb.c&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;#34;liba.h&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;add10&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i)&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; add(i, &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;&lt;p&gt;之所以把函数划分到两个文件，是因为接下来的章节会讲述 &lt;em&gt;打包目标文件&lt;/em&gt; 的功能，即把 &lt;code&gt;liba.o&lt;/code&gt; 和 &lt;code&gt;libb.o&lt;/code&gt; 打包为 &lt;code&gt;libmath.a&lt;/code&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h4 id=&#34;主程序&#34;&gt;主程序&lt;/h4&gt;&lt;p&gt;然后再看看主程序，源代码文件 &lt;code&gt;app.c&lt;/code&gt;，其内容如下：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;#34;libmath.h&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;#34;libprint.h&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;bare_main&lt;/span&gt;()&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; a &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; b &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; m &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; add(a, b);&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; n &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; add10(a);&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    print_string(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Hello world!&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    print_int(m);&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    print_char(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;\n&amp;#39;&lt;/span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    print_int(n);&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    print_char(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;\n&amp;#39;&lt;/span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;因为这个是 &amp;ldquo;裸机&amp;rdquo; 程序，为了跟标准程序区分，这里把主函数 &lt;code&gt;main&lt;/code&gt; 命名为 &lt;code&gt;bare_main&lt;/code&gt;（随意的名称）。&lt;/p&gt;&lt;h4 id=&#34;启动器&#34;&gt;启动器&lt;/h4&gt;&lt;p&gt;由上一节知道，可执行文件的入口（即最先开始执行的指令）是由编译器自动生成的 &lt;code&gt;_start&lt;/code&gt; 过程，经过一系列初始化之后才调用函数 &lt;code&gt;main&lt;/code&gt;。但这些事情仅在编译为标准 Linux 程序时才会发生，现在编译裸机程序，编译器是不会自作主张地添加这些过程的，所以还得写一个 &amp;ldquo;程序的启动程序&amp;rdquo;，源代码文件为 &lt;code&gt;app_startup.S&lt;/code&gt;，其内容如下：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-S&#34; data-lang=&#34;S&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.section .text.entry&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.globl _start&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;_start&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    la sp, stack_top&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    call bare_main&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;_loop&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    nop&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    j _loop&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上面的程序的功能很简单：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;因为程序有嵌套的函数调用，所以需要用到 &lt;em&gt;栈&lt;/em&gt;。通过向 &amp;ldquo;stack pointer&amp;rdquo; 寄存器写入一个地址即可设置栈底（高地址），这样一来 &lt;em&gt;栈&lt;/em&gt; 就搭建好了。（代码中的 &lt;code&gt;stack_top&lt;/code&gt; 是链接脚本 &lt;code&gt;app.lds&lt;/code&gt; 导出的符号）&lt;/li&gt;&lt;li&gt;调用主程序的主函数 &lt;code&gt;bare_main&lt;/code&gt;。&lt;/li&gt;&lt;/ol&gt;&lt;h3 id=&#34;编译-1&#34;&gt;编译&lt;/h3&gt;&lt;p&gt;编译各个源文件，但暂时不需要链接：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ riscv64-elf-as -o app_startup.o app_startup.S&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ riscv64-elf-gcc -I . -Wall -fPIC -c -o app.o app.c&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ riscv64-elf-gcc -I . -Wall -fPIC -c -o liba.o liba.c&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ riscv64-elf-gcc -I . -Wall -fPIC -c -o libb.o libb.c&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ riscv64-elf-gcc -I . -Wall -fPIC -c -o libprint.o libprint.c&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ riscv64-elf-as -o put_char.o put_char.S&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;现在看第二条命令，即编译 &lt;code&gt;app.c&lt;/code&gt; 的那条命令，你可能会感到疑惑，在 &lt;code&gt;app.c&lt;/code&gt; 里既调用了函数 &lt;code&gt;add&lt;/code&gt;、&lt;code&gt;add10&lt;/code&gt;，还调用了 &lt;code&gt;print_*&lt;/code&gt;，但这些函数都还没编译，而且在 &lt;code&gt;app.c&lt;/code&gt; 里也找不到任何跟 &lt;code&gt;liba.c&lt;/code&gt; 和 &lt;code&gt;libb.c&lt;/code&gt; 联系的代码，那么为什么还能成功编译呢？&lt;/p&gt;&lt;p&gt;这正是 GCC 编译的工作原理，在编译一个源文件时，如果代码里有调用外部函数，编译器实际上不管这个外部函数是否存在（是否已经编译），也不管它在哪里，你只需提供这个函数的签名即可（函数签名位于 &lt;code&gt;libmath.h&lt;/code&gt; 和 &lt;code&gt;libprint.h&lt;/code&gt;），这也是为什么各个源文件可以各自单独编译，甚至多个源文件可以并行编译的原因（想一想平时输入的类似 &lt;code&gt;$ make -j $(nproc)&lt;/code&gt; 这样的命令，它表示有多条进程并行编译哦）。&lt;/p&gt;&lt;h3 id=&#34;打包目标文件&#34;&gt;打包目标文件&lt;/h3&gt;&lt;p&gt;可以打包多个 &lt;em&gt;目标文件&lt;/em&gt; 以形成一个 &lt;em&gt;库&lt;/em&gt; 文件，这样可以方便以后使用。&lt;/p&gt;&lt;p&gt;下面的命令将 &lt;code&gt;liba.o&lt;/code&gt; 和 &lt;code&gt;libb.o&lt;/code&gt; 打包为 &lt;code&gt;libmath.a&lt;/code&gt;：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ riscv64-elf-ar -crs libmath.a liba.o libb.o&lt;/code&gt;&lt;/p&gt;&lt;p&gt;参数：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;-c&lt;/code&gt; 如果静态库文件已存在也不发出警告提示。&lt;/li&gt;&lt;li&gt;&lt;code&gt;-r&lt;/code&gt; 表示替换静态库中已存在的源目标文件，或者插入新的源目标文件。&lt;/li&gt;&lt;li&gt;&lt;code&gt;-s&lt;/code&gt; 表示为静态库创建索引，相当于创建完静态库之后执行了一次 &lt;code&gt;$ riscv64-elf-ranlib libmath.a&lt;/code&gt; 命令。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;命令运行之后将得到包文件 &lt;code&gt;libmath.a&lt;/code&gt;（一般称为 &lt;em&gt;静态库&lt;/em&gt;）。程序 &lt;code&gt;riscv64-elf-ar&lt;/code&gt; 除了可以创建包文件，还可以查看或者修改包文件，比如下面的命令用于查看包文件里含有哪些目标文件：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ riscv64-elf-ar -t libmath.a&lt;/code&gt;&lt;/p&gt;&lt;p&gt;输出结果如下：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;liba.o&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;libb.o&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;包文件也能够使用 &lt;code&gt;riscv64-elf-nm&lt;/code&gt; 程序列出符号列表：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ riscv64-elf-nm libmath.a&lt;/code&gt;&lt;/p&gt;&lt;p&gt;输出结果如下：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;liba.o:&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;0000000000000000 T add&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;libb.o:&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                 U add&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;0000000000000000 T add10&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;当然也能用 &lt;code&gt;riscv64-elf-objdump&lt;/code&gt; 反汇编包文件：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ riscv64-elf-objdump -d libmath.a&lt;/code&gt;&lt;/p&gt;&lt;p&gt;输出（部分）结果如下：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;In archive libmath.a:&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;liba.o:     file format elf64-littleriscv&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Disassembly of section .text:&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;0000000000000000 &amp;lt;add&amp;gt;:&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   0:   1101                    addi    sp,sp,-32&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;...&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  26:   6105                    addi    sp,sp,32&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  28:   8082                    ret&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;libb.o:     file format elf64-littleriscv&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Disassembly of section .text:&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;0000000000000000 &amp;lt;add10&amp;gt;:&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   0:   1101                    addi    sp,sp,-32&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;...&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  26:   6105                    addi    sp,sp,32&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  28:   8082                    ret&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;通过反汇编会发现，包文件（即静态库）仅仅是把原先的多个目标文件 &lt;strong&gt;原样&lt;/strong&gt; 合并起来，其中的内容均未改变。这跟链接程序把多个目标文件链接起来的情况不同，链接程序会修改部分内容（主要是会解决各个符号的地址，本项目的其它文章会讲解）。&lt;/p&gt;&lt;h3 id=&#34;链接&#34;&gt;链接&lt;/h3&gt;&lt;p&gt;由于当前这个程序是一个裸机程序，而且 QEMU RISC-V 对程序的入口地址有要求，所以不能使用默认的链接脚本来链接目标文件，目录 &lt;a href=&#34;./resources/bare-metal/&#34;&gt;resources/bare-metal&lt;/a&gt; 里有链接脚本 &lt;code&gt;app.lds&lt;/code&gt;，其内容如下：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;OUTPUT_ARCH(riscv)&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ENTRY(_start)&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;BASE_ADDRESS = 0x80000000;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;SECTIONS&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  . = BASE_ADDRESS;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  .text : {&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    *(.text.entry)&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    *(.text .text.*)&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  .rodata : {&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    *(.rodata .rodata.*)&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  . = ALIGN(4096);&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  .data : {&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    *(.sdata .sdata.*)&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    *(.data .data.*)&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  .bss :{&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    *(.sbss .sbss.*)&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    *(.bss .bss.*)&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  . = ALIGN(8);&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  /* a 4KB stack */&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  stack_bottom = .;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  . += 4096;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  stack_top = .;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;有关链接脚本的具体内容可以参阅 &lt;a href=&#34;https://sourceware.org/binutils/docs/ld/Scripts.html&#34;&gt;Linker Scripts&lt;/a&gt; 或者 &lt;a href=&#34;https://blog.csdn.net/m0_47799526/article/details/108765403&#34;&gt;中文翻译版&lt;/a&gt; 。&lt;/p&gt;&lt;p&gt;下面将 &lt;code&gt;app_startup.o&lt;/code&gt;，&lt;code&gt;app.o&lt;/code&gt;，&lt;code&gt;libmath.a&lt;/code&gt;，&lt;code&gt;libprint.o&lt;/code&gt; 和 &lt;code&gt;put_char.o&lt;/code&gt; 链接起来：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ riscv64-elf-ld -T app.lds -o app.out app_startup.o app.o libmath.a libprint.o put_char.o&lt;/code&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;参数 &lt;code&gt;-T app.lds&lt;/code&gt; 表示使用指定的链接脚本 &lt;code&gt;app.lds&lt;/code&gt;。&lt;/li&gt;&lt;li&gt;参数 &lt;code&gt;-o app.out&lt;/code&gt; 指示输出的文件名。&lt;/li&gt;&lt;li&gt;参数 &lt;code&gt;app_startup.o app.o libmath.a libprint.o put_char.o&lt;/code&gt; 表示待链接的文件列表（友情提示：文件列表尽量按照这样的顺序列出：被依赖的文件排在后面。有时编译器会因为顺序问题而出现莫名其妙的错误）。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;链接命令中的参数 &lt;code&gt;libmath.a&lt;/code&gt; 是静态库文件，可见其实静态库文件可以简化链接命令（假设静态库是由非常多的目标文件组成的话）。&lt;/p&gt;&lt;p&gt;命令运行之后得到 ELF 格式的可执行文件 &lt;code&gt;app.out&lt;/code&gt;。&lt;/p&gt;&lt;h3 id=&#34;运行-1&#34;&gt;运行&lt;/h3&gt;&lt;p&gt;下面使用 QEMU 的 &lt;em&gt;系统模式&lt;/em&gt; 运行该文件：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ qemu-system-riscv64 &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;    -machine virt &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;    -nographic &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;    -bios none &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;    -kernel app.out&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如无意外，应该能看到正确的输出结果：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Hello world!&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;8&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;13&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;按 &lt;code&gt;Ctrl+a&lt;/code&gt;，再按 &lt;code&gt;x&lt;/code&gt; 结束 QEMU 模拟程序。&lt;/p&gt;&lt;p&gt;下一篇文章 &lt;a href=&#34;../build-risc-v-program-from-assembly-code/README.zh-Hans.md&#34;&gt;通过汇编代码构建 RISC-V 程序&lt;/a&gt; 我们将会讲解 RISC-V 程序的组成和运行原理。&lt;/p&gt;</description>
     </item>
   
     <item>
       <title></title>
       <link>https://hemashushu.github.io/posts/2022-11-07-build-minimal-risc-v-program/readme/</link>
       <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
       
       <guid>https://hemashushu.github.io/posts/2022-11-07-build-minimal-risc-v-program/readme/</guid>
       <description>&lt;h1 id=&#34;building-risc-v-program-from-assembly-code&#34;&gt;Building RISC-V Program from Assembly Code&lt;/h1&gt;</description>
     </item>
   
     <item>
       <title></title>
       <link>https://hemashushu.github.io/posts/2022-11-07-build-minimal-risc-v-program/readme.zh-hans/</link>
       <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
       
       <guid>https://hemashushu.github.io/posts/2022-11-07-build-minimal-risc-v-program/readme.zh-hans/</guid>
       <description>&lt;h1 id=&#34;构建最小的-risc-v-程序&#34;&gt;构建最小的 RISC-V 程序&lt;/h1&gt;&lt;p&gt;在&lt;a href=&#34;../risc-v-gcc-quick-start/README.zh-Hans.md&#34;&gt;上一篇文章&lt;/a&gt;我们简单地了解了交叉编译工具 RISC-V GCC 的基本使用方法。这篇文章将会以纯汇编构建两个程序：一个最小的裸机程序和一个最小的 Linux 应用程序。一般情况下我们不需要直接使用汇编写程序，但通过这种方式可以排除不相关的内容，以了解一个 RISC-V 程序的最根本的组成和运行的原理。&lt;/p&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&#34;#%E6%9C%80%E5%B0%8F%E7%9A%84%E8%A3%B8%E6%9C%BA%E7%A8%8B%E5%BA%8F&#34;&gt;最小的裸机程序&lt;/a&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&#34;#%E6%BA%90%E4%BB%A3%E7%A0%81&#34;&gt;源代码&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#%E6%B1%87%E7%BC%96&#34;&gt;汇编&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6&#34;&gt;目标文件&lt;/a&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&#34;#%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B&#34;&gt;文件类型&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#%E7%AC%A6%E5%8F%B7%E5%88%97%E8%A1%A8&#34;&gt;符号列表&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#%E6%AE%B5&#34;&gt;段&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#%E6%AE%B5%E7%9A%84%E5%A4%A7%E5%B0%8F&#34;&gt;段的大小&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#%E5%8F%8D%E6%B1%87%E7%BC%96&#34;&gt;反汇编&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#%E9%93%BE%E6%8E%A5&#34;&gt;链接&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6&#34;&gt;可执行文件&lt;/a&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&#34;#%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B-1&#34;&gt;文件类型&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#%E7%AC%A6%E5%8F%B7%E5%88%97%E8%A1%A8-1&#34;&gt;符号列表&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#%E6%AE%B5-1&#34;&gt;段&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#program-headers&#34;&gt;Program Headers&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#%E6%AE%B5%E5%A4%A7%E5%B0%8F&#34;&gt;段大小&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%BF%90%E8%A1%8C&#34;&gt;第一次运行&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#%E9%93%BE%E6%8E%A5%E8%84%9A%E6%9C%AC&#34;&gt;链接脚本&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#%E7%AC%AC%E4%BA%8C%E6%AC%A1%E8%BF%90%E8%A1%8C&#34;&gt;第二次运行&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#%E7%BB%99%E7%A8%8B%E5%BA%8F%E5%87%8F%E8%82%A5&#34;&gt;给程序减肥&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#%E7%AC%AC%E4%B8%89%E6%AC%A1%E8%BF%90%E8%A1%8C&#34;&gt;第三次运行&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#%E6%9C%80%E5%B0%8F%E7%9A%84-linux-%E7%A8%8B%E5%BA%8F&#34;&gt;最小的 Linux 程序&lt;/a&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&#34;#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8&#34;&gt;系统调用&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E5%AE%9E%E7%8E%B0&#34;&gt;系统调用的实现&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%BA%90%E4%BB%A3%E7%A0%81&#34;&gt;程序的源代码&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#%E7%BC%96%E8%AF%91&#34;&gt;编译&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#%E8%BF%90%E8%A1%8C&#34;&gt;运行&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;!-- raw HTML omitted --&gt;&lt;h2 id=&#34;最小的裸机程序&#34;&gt;最小的裸机程序&lt;/h2&gt;&lt;p&gt;本章演示的是一个最终只有大约 30 个字节的 RISC-V 裸机程序，该程序用纯汇编写，功能也非常简单，就是向串口打印一个大写的字母 &amp;ldquo;A&amp;rdquo;，然后进入一个无限循环。&lt;/p&gt;&lt;h3 id=&#34;源代码&#34;&gt;源代码&lt;/h3&gt;&lt;p&gt;源代码位于目录 &lt;a href=&#34;./resources/minimal-bare-metal/&#34;&gt;resouces/minimal-bare-metal&lt;/a&gt; 之下的文件 &lt;code&gt;app.S&lt;/code&gt;（注意扩展名为大写的字母 &lt;code&gt;S&lt;/code&gt;，跟小写 &lt;code&gt;s&lt;/code&gt; 的区别在于大写 &lt;code&gt;S&lt;/code&gt; 表示需要预处理，一般我们手写的汇编源代码文件的扩展名建议使用大写字母 &lt;code&gt;S&lt;/code&gt;），其内容如下：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-s&#34; data-lang=&#34;s&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.equ VIRT_UART0, &lt;span style=&#34;color:#ae81ff&#34;&gt;0x10000000&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.section .text.entry&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.globl _start&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.globl _print_a&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;_start&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    call _print_a&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;_loop&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    nop&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    j _loop&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;_print_a&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    li s1, VIRT_UART0   &lt;span style=&#34;color:#75715e&#34;&gt;# set s1 = 0x1000_0000&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    li s2, &lt;span style=&#34;color:#ae81ff&#34;&gt;0x41&lt;/span&gt;         &lt;span style=&#34;color:#75715e&#34;&gt;# set s2 = 0x41&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    sb s2, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;(s1)        &lt;span style=&#34;color:#75715e&#34;&gt;# store s2 (as byte) to memory[s1+0]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        &lt;span style=&#34;color:#75715e&#34;&gt;# address 0x1000_0000 is mapped to UART0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        &lt;span style=&#34;color:#75715e&#34;&gt;# checkout QEMU source https://github.com/qemu/qemu/blob/master/hw/riscv/virt.c&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ret&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol&gt;&lt;li&gt;程序的第 1 行用于指定接下来的汇编的结果放在目标文件的哪个段。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;汇编代码经过汇编之后会生成一系列平铺的、无结构的二进制数据，具体来说就是类似 &amp;ldquo;101000110010&amp;hellip;&amp;rdquo; 这样长长的一串二进制数字，为了便于阅读，有时也会以十六进制表示，比如 &amp;ldquo;A3 20 65 66 &amp;hellip;&amp;quot;，无论哪种表示形式，本质都是一样的。而汇编代码则大约相当于这些二进制数据的文本格式，很多汇编语句跟机器指令是一对一的关系，汇编器的任务大致上是将 &amp;ldquo;文本格式的指令和数据&amp;rdquo; 翻译成 &amp;ldquo;二进制格式的指令和数据&amp;rdquo;。&lt;/p&gt;&lt;p&gt;&lt;img src=&#34;images/assembler.png&#34; alt=&#34;assembler&#34;&gt;&lt;/p&gt;&lt;p&gt;这些数据中有些是（二进制形式）机器指令，有些是程序中的诸如整数常量、字符串常量等，汇编器根据数据的性质分段储存在汇编器的输出文件（称为 &lt;em&gt;目标文件&lt;/em&gt;）当中。一个典型的目标文件有 &lt;code&gt;.text&lt;/code&gt;, &lt;code&gt;.rodata&lt;/code&gt;, &lt;code&gt;.data&lt;/code&gt;, &lt;code&gt;.bss&lt;/code&gt; 等段，它们分别是指令序列、只读数据（比如数字和字符串常量）、数据（全局变量）、未初始化的全局变量（或者初始值为 0 的全局变量）。&lt;/p&gt;&lt;p&gt;&lt;img src=&#34;images/object-file.png&#34; alt=&#34;object file&#34;&gt;&lt;/p&gt;&lt;p&gt;为了细化管理，每个段又可以细分为多个子段，子段的名字可以随意命名，不过有些是约定俗称的（以后的文章会讲解）。&lt;/p&gt;&lt;p&gt;上面示例程序中的 &lt;code&gt;.text.entry&lt;/code&gt; 表示 &lt;code&gt;.text&lt;/code&gt; 段里面的一个叫做 &lt;code&gt;.entry&lt;/code&gt; 的子段，该名字是我随意起的。&lt;/p&gt;&lt;ol start=&#34;2&#34;&gt;&lt;li&gt;&lt;p&gt;接下来的两句 &lt;code&gt;.globl&lt;/code&gt; 表示导出两个 &lt;em&gt;符号&lt;/em&gt;，&lt;code&gt;.globl&lt;/code&gt; 关键字后面跟着的是标签的名称，下面会讲解。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;_start&lt;/code&gt; 是一个标签，标签实质上是一个地址值。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;正如上面的第 1 段所说，目标文件是一连串二进制数据，虽然人类无法直接阅读，但我们知道其实每个数字都有具体含义的，因此我们以 &lt;em&gt;字节&lt;/em&gt; 为单位，给段里面的数据加上一连串假想的序号，这个序号就是 &lt;em&gt;地址&lt;/em&gt;，这样一来就可以用地址来定位每一个数据了。&lt;/p&gt;&lt;p&gt;但有时直接用数字地址不够直观，所以又有了 &lt;em&gt;标签&lt;/em&gt;。我们给某些特殊的地址加上标签，比如在上面的程序当中，给 &lt;code&gt;0x0008&lt;/code&gt; 加上名为 &lt;code&gt;_loop&lt;/code&gt; 的标签，给 &lt;code&gt;0x0010&lt;/code&gt; 加上名为 &lt;code&gt;_print_a&lt;/code&gt; 标签，这样每当程序需求跳转到这两个位置时，就不用写 &lt;code&gt;0x0008&lt;/code&gt; 和 &lt;code&gt;0x0010&lt;/code&gt;，而是写成 &lt;code&gt;_loop&lt;/code&gt; 和 &lt;code&gt;_print_a&lt;/code&gt;，显然用标签来表示一个地址更直观。&lt;/p&gt;&lt;p&gt;最重要的是，我们在书写汇编文本时，其实还不知道每个指令最后被编译之后的地址，所以需要用标签来代表程序当中的一个位置。&lt;/p&gt;&lt;p&gt;具体来说，有两种情况需要用到标签：&lt;/p&gt;&lt;p&gt;a. 用于构建一个函数，通常一个函数由 &amp;ldquo;一个标签&amp;rdquo; + &amp;ldquo;一系列指令&amp;rdquo; + &amp;ldquo;一个返回指令&amp;rdquo; 组成，此时标签的名称就是函数的名称。b. 用于构建流程控制结构，比如条件语句、循环语句等，其实都是通过 &amp;ldquo;标签&amp;rdquo; + &amp;ldquo;跳转指令&amp;rdquo; 组成。&lt;/p&gt;&lt;ol start=&#34;4&#34;&gt;&lt;li&gt;&lt;code&gt;_loop&lt;/code&gt; 标签以及它后面的两个指令用于形成了一个无限循环。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;为什么需要一个无限循环呢？这需要从机器是如何执行指令序列说起。从处理器的角度来看，机器指令序列是没有函数概念，运行程序的本质是将程序的一条长长的二进制指令序列加载进内存，然后从第一个指令开始执行，执行完一个指令就指向下一个指令，假如程序当中没有跳转指令的话，则会一直执行到最后一个指令。假如最后一个指令后面还有内存空间，则会一直执行到内存的尽头（尽管这些空间里不是有效的指令，只要不出错则处理器仍然会执行）。处理器就像一个蒙着眼睛捂着耳朵的固执司机，只要路和汽油还有，只要没撞上障碍物，他就一直驱使着车前进。&lt;/p&gt;&lt;p&gt;显然从处理器或者指令序列的角度来看，结构之间、函数之间根本没有边界。所以我们需要约定：一个函数以某个地址开始，这个地址需要加上标签（一般标签名就是函数名），然后以一个返回指令（&lt;code&gt;ret&lt;/code&gt; 指令）以此表示函数结束。&lt;/p&gt;&lt;p&gt;然后回过头来看函数 &lt;code&gt;_start&lt;/code&gt;，它的工作是调用另一个函数 &lt;code&gt;_print_a&lt;/code&gt;，调用完毕之后，程序的所有任务就全部完成了。不过 &lt;code&gt;_start&lt;/code&gt; 函数是程序的入口，是一切的开端，显然它没有调用者，所以我们没法在该函数的工作完成之后使用 &lt;code&gt;ret&lt;/code&gt; 指令返回。为了防止处理器在执行完 &lt;code&gt;_start&lt;/code&gt; 函数之后继续往下执行，只好在函数的末尾处设了一个无限循环，让处理器在这里原地打转（虽然这个方法似乎不怎么优雅）。&lt;/p&gt;&lt;ol start=&#34;5&#34;&gt;&lt;li&gt;&lt;code&gt;_print_a&lt;/code&gt; 是一个标签，同时也是一个完整的函数的名称，该函数的作用是把 byte 类型的整数 &lt;code&gt;0x41&lt;/code&gt;（即大写字母 &lt;code&gt;A&lt;/code&gt; 对应的 ASCII 号码）写入内存地址 &lt;code&gt;0x1000_0000&lt;/code&gt;，这个内存地址被映射到 UART 端口（类似串口控制台，即 Serial Console），QEMU 的 UART 被重定向到虚拟终端，所以实际上就是向虚拟终端输出了一个大写字母 &lt;code&gt;A&lt;/code&gt;，&lt;code&gt;_print_a&lt;/code&gt; 函数的最后一句是 &lt;code&gt;ret&lt;/code&gt; 指令，也就是返回到调用函数指令的下一条指令。&lt;/li&gt;&lt;/ol&gt;&lt;blockquote&gt;&lt;p&gt;汇编源代码当中 &lt;code&gt;#&lt;/code&gt; 符号以及它后面的文本表示注释。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 id=&#34;汇编&#34;&gt;汇编&lt;/h3&gt;&lt;p&gt;下面使用 RISC-V GCC 汇编器 &lt;code&gt;riscv64-elf-as&lt;/code&gt; 生成目标文件：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ riscv64-elf-as -g -o app.o app.S&lt;/code&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;参数 &lt;code&gt;-g&lt;/code&gt; 表示同时生成供 GDB 使用的额外调试信息调试信息。&lt;/li&gt;&lt;li&gt;参数 &lt;code&gt;-o app.o&lt;/code&gt; 用于指定输出文件的名称（注意，在阅读和理解这条命令时，需要把这个参数和值的组合视为一个整体，后面的 &lt;code&gt;a.S&lt;/code&gt; 不属于这个参数的一部分）。&lt;/li&gt;&lt;li&gt;参数 &lt;code&gt;a.S&lt;/code&gt; 表示源文件的名称路径。&lt;/li&gt;&lt;/ul&gt;&lt;blockquote&gt;&lt;p&gt;因 Linux 发行版的不同，RISC-V GCC 工具链当中的各个工具的名称前缀可能会有所不同，比如 &lt;code&gt;riscv64-elf-*&lt;/code&gt; 会被命名为 &lt;code&gt;riscv64-unknown-elf-*&lt;/code&gt;。另外注意区分 &lt;code&gt;riscv64-elf-*&lt;/code&gt; 和 &lt;code&gt;riscv64-linux-gnu-*&lt;/code&gt;，前者用于编译 &amp;ldquo;裸机&amp;rdquo; 程序，后者用于编译在 Linux 环境中运行的程序。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;然后将会得到文件 &lt;code&gt;app.o&lt;/code&gt;。&lt;/p&gt;&lt;h3 id=&#34;目标文件&#34;&gt;目标文件&lt;/h3&gt;&lt;p&gt;下面检查目标文件的一些基本信息。&lt;/p&gt;&lt;h4 id=&#34;文件类型&#34;&gt;文件类型&lt;/h4&gt;&lt;p&gt;先检查文件类型：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ file app.o&lt;/code&gt;&lt;/p&gt;&lt;p&gt;输出内容如下：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;app.o: ELF 64-bit LSB relocatable, UCB RISC-V, double-float ABI, version 1 (SYSV), with debug_info, not stripped&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可见汇编器输出的是一个 ELF 格式的 &lt;em&gt;可重定位文件&lt;/em&gt;，也就是平常说的 &lt;em&gt;目标文件&lt;/em&gt;，它还不是可执行文件。有关 ELF 格式的 3 中类型，可以参阅上一篇文章 &lt;a href=&#34;../risc-v-gcc-base/README.zh-Hans.md&#34;&gt;RISC-V GCC 基础&lt;/a&gt;。&lt;/p&gt;&lt;h4 id=&#34;符号列表&#34;&gt;符号列表&lt;/h4&gt;&lt;p&gt;正如前面章节所述，汇编代码里会有表示地址的标签，这些标签经过 &lt;code&gt;.globl&lt;/code&gt; 导出，就形成可以供外部查看的 &lt;code&gt;符号&lt;/code&gt;（不过并非所有符号都是标签），可以粗略地把符号理解为函数名称或者全局变量名称。&lt;/p&gt;&lt;p&gt;使用工具 &lt;code&gt;riscv64-elf-nm&lt;/code&gt; 可以查看目标文件的导出符号列表：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ riscv64-elf-nm app.o&lt;/code&gt;&lt;/p&gt;&lt;p&gt;输出的内容如下：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;0000000000000008 t _loop&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;0000000000000010 T _print_a&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;0000000000000000 T _start&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;左边一列是各个符号的虚拟地址，右边一列是符号的名称，中间一列是符号类型的代号，部分代号的含义如下：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;A: Global absolute symbol.&lt;/li&gt;&lt;li&gt;a: Local absolute symbol.&lt;/li&gt;&lt;li&gt;B: Global bss symbol.&lt;/li&gt;&lt;li&gt;b: Local bss symbol.&lt;/li&gt;&lt;li&gt;D: Global data symbol.&lt;/li&gt;&lt;li&gt;d: Local data symbol.&lt;/li&gt;&lt;li&gt;T: Global text symbol.&lt;/li&gt;&lt;li&gt;t: Local text symbol.&lt;/li&gt;&lt;li&gt;U: Undefined symbol.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;符号类型代号当中，大写的表示是导出的（供外部使用的），小写的表示局部的（供内部使用的）。详细的列表可参阅 &lt;a href=&#34;https://sourceware.org/binutils/docs/binutils/index.html&#34;&gt;GNU Binary Utilities Document&lt;/a&gt; 当中的 &lt;a href=&#34;https://sourceware.org/binutils/docs/binutils/nm.html&#34;&gt;nm&lt;/a&gt; 一章。&lt;/p&gt;&lt;p&gt;类型 &lt;code&gt;U&lt;/code&gt; 比较特殊，表示未定义的符号。比如在一个源代码文件里，调用了一个外部函数，那么这个外部函数的名称就是一个未定义的符号。可见这里的 &amp;ldquo;未定义&amp;rdquo; 是相对当前源代码文件而言的。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;GCC 工具链里很多程序会提供相似的功能，比如列符号表的程序 &lt;code&gt;nm app.o&lt;/code&gt;，其实也可以使用 &lt;code&gt;objdump -t app.o&lt;/code&gt; 列出，还可以使用 &lt;code&gt;readelf --syms app.o&lt;/code&gt; 列出。后面还会看到更多这样的情况，我们根据自己的喜好和习惯选择即可。&lt;/p&gt;&lt;/blockquote&gt;&lt;h4 id=&#34;段&#34;&gt;段&lt;/h4&gt;&lt;p&gt;使用 &lt;code&gt;riscv64-elf-objdump -h&lt;/code&gt; 可以查看目标文件的段信息：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ riscv64-elf-objdump -h app.o&lt;/code&gt;&lt;/p&gt;&lt;p&gt;输出的（部分）内容如下：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Idx Name          Size      VMA               LMA               File off  Algn&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  0 .text         00000020  0000000000000000  0000000000000000  00000040  2**2&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  1 .data         00000000  0000000000000000  0000000000000000  00000060  2**0&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                  CONTENTS, ALLOC, LOAD, DATA&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  2 .bss          00000000  0000000000000000  0000000000000000  00000060  2**0&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                  ALLOC&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;&lt;p&gt;如果使用 &lt;code&gt;-x&lt;/code&gt; 参数，将会看到所有的段，包括调试信息的段，不过一般不需要关心这些段的内容。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;code&gt;.text&lt;/code&gt;, &lt;code&gt;.data&lt;/code&gt; 和 &lt;code&gt;.bss&lt;/code&gt; 是段的名称，&lt;code&gt;VMA&lt;/code&gt; 和 &lt;code&gt;LMA&lt;/code&gt; 分别表示虚拟内存地址和加载地址，&lt;code&gt;ALLOC, LOAD, READONLY, CODE&lt;/code&gt; 等是段的标记，程序加载器会根据该标记来决定处理该段的方式。&lt;/p&gt;&lt;p&gt;比如 &lt;code&gt;ALLOC&lt;/code&gt; 表示程序加载器需要分配空间给该段，&lt;code&gt;LOAD&lt;/code&gt; 表示该段需要从文件加载进内存，&lt;code&gt;READONLY&lt;/code&gt; 表示该段的内容不能被子进程修改，&lt;code&gt;CODE&lt;/code&gt; 表示该段是可执行代码，&lt;code&gt;DATA&lt;/code&gt; 表示该段是数据段。完整的标记列表可以参阅 &lt;a href=&#34;https://sourceware.org/gdb/onlinedocs/gdb/Files.html&#34;&gt;GDB - section-flag&lt;/a&gt;。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;除了 &lt;code&gt;riscv64-elf-objdump -h&lt;/code&gt;，也可以使用 &lt;code&gt;riscv64-elf-readelf -S app.o&lt;/code&gt; 列出目标文件的段信息。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;ELF 的段（section）有两个视图：一个是从汇编器和链接器等工具看到的 section 视图（上面看到的都是这种视图），另一个是从程序加载器看到的 segment 视图（也称为 program 视图）。&lt;/p&gt;&lt;p&gt;section 视图在 &amp;ldquo;section headers&amp;rdquo; 里列出，segment 视图在 &amp;ldquo;program headers&amp;rdquo; 里列出；section 视图跟 section 基本上是一一对应，而 segment 视图则跟 section 存在一对多的映射关系，比如 &lt;code&gt;.text&lt;/code&gt; 和 &lt;code&gt;.data&lt;/code&gt; 段常常对被映射到同一个 segment。&lt;/p&gt;&lt;p&gt;使用命令 &lt;code&gt;riscv64-elf-readelf -l app.o&lt;/code&gt; 即可列出 &amp;ldquo;program headers&amp;rdquo;，不过由于目前的 &lt;code&gt;app.o&lt;/code&gt; 还不是可执行文件，所以它的 &amp;ldquo;program headers&amp;rdquo; 是空的。完整的 ELF 文件的结构信息可以参阅 &lt;a href=&#34;https://en.wikipedia.org/wiki/Executable_and_Linkable_Format&#34;&gt;ELF Format wiki&lt;/a&gt;。&lt;/p&gt;&lt;h4 id=&#34;段的大小&#34;&gt;段的大小&lt;/h4&gt;&lt;p&gt;使用 &lt;code&gt;riscv64-elf-size&lt;/code&gt; 可以查看各个段的大小：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ riscv64-elf-size app.o&lt;/code&gt;&lt;/p&gt;&lt;p&gt;输出的结果如下：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   text    data     bss     dec     hex filename&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;     32       0       0      32      20 app.o&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;反汇编&#34;&gt;反汇编&lt;/h3&gt;&lt;p&gt;你可能会疑问，我们刚刚进行了汇编，为什么还要反汇编？反汇编的结果不就是我们手写的汇编代码吗？&lt;/p&gt;&lt;p&gt;是的，对目标文件进行 &lt;em&gt;反汇编&lt;/em&gt; 将会得到汇编代码，不过经过反汇编得出的汇编代码跟我们手写的不完全一样，那是因为手写的汇编代码有一部分是 &lt;code&gt;伪指令&lt;/code&gt;（即由多个真实指令组成的虚拟指令），通过反汇编能得到真实的指令；另外还有一部分是汇编指令，也就是针对汇编器的指令，这部分指令可能会改变汇编的行为，也可能会产生相当多的数据。&lt;/p&gt;&lt;p&gt;再者反汇编工具一般还会显示各个指令的地址，这有帮助我们分析和调试程序。&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ riscv64-elf-objdump -d app.o&lt;/code&gt;&lt;/p&gt;&lt;p&gt;输出的结果如下：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Disassembly of section .text:&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;0000000000000000 &amp;lt;_start&amp;gt;:&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   0:   00000097                auipc   ra,0x0&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   4:   000080e7                jalr    ra # 0 &amp;lt;_start&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;0000000000000008 &amp;lt;_loop&amp;gt;:&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   8:   00000013                nop&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   c:   ffdff06f                j       8 &amp;lt;_loop&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;0000000000000010 &amp;lt;_print_a&amp;gt;:&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  10:   100004b7                lui     s1,0x10000&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  14:   04100913                li      s2,65&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  18:   01248023                sb      s2,0(s1) # 10000000 &amp;lt;_print_a+0xffffff0&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  1c:   00008067                ret&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;注意参数 &lt;code&gt;-d&lt;/code&gt; 仅反汇编 &lt;code&gt;.text&lt;/code&gt; 段，如果你想查看所有段的内容，可以使用 &lt;code&gt;-D&lt;/code&gt; 参数代替 &lt;code&gt;-d&lt;/code&gt;，不过一般不用关心其它段的内容。&lt;/p&gt;&lt;p&gt;下面分析其中的第 2 个指令 &lt;code&gt;0000_80e7&lt;/code&gt;：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;000000000000  00001 000 00001 1100111&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;____________  _____     _____ _______&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;|offset[11:0] rs=1      rd=1  jalr&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;解码得出：&lt;code&gt;jalr ra, 0(ra)&lt;/code&gt;，结合上一条指令 &lt;code&gt;auipc ra,0x0&lt;/code&gt; 来看，这两条指令并不能实现跳转到 &lt;code&gt;_print_a&lt;/code&gt; 函数，所以这里的 &lt;code&gt;0&lt;/code&gt; 是一个占位符。这时 GCC 编译器，也是目前大部分编译器的原理，即在编译阶段，所有涉及函数地址、全局变量地址的地方，都用 &lt;code&gt;0&lt;/code&gt; 代替，同时会做一张需要重定位的符号列表。仅在链接阶段，才会把真实的地址填上。（具体步骤和原理在后续的文章里会讲解）&lt;/p&gt;&lt;h3 id=&#34;链接&#34;&gt;链接&lt;/h3&gt;&lt;p&gt;由上一节可知，因为目标文件当中的所有符号的地址都是用 &lt;code&gt;0&lt;/code&gt; 顶替的，所以 &lt;em&gt;目标文件&lt;/em&gt; 是没法运行的，还需要把符号的真实地址填上，应用程序才能运行，而这这正是链接器的工作。&lt;/p&gt;&lt;p&gt;链接器还有另外一项工作，就是如果存在多个 &lt;em&gt;目标文件&lt;/em&gt;，那么它还需要把这些文件合并在一起。那么它是怎样合并的呢？&lt;/p&gt;&lt;p&gt;我们知道目标文件里存在多个 “段”，在合并时默认会将相同名称的段合并成一个段。比如假设现有两个目标文件 &lt;code&gt;a.o&lt;/code&gt; 和 &lt;code&gt;b.o&lt;/code&gt;。在链接时，&lt;code&gt;a.o&lt;/code&gt; 的 &lt;code&gt;.text&lt;/code&gt; 段将会和 &lt;code&gt;b.o&lt;/code&gt; 的 &lt;code&gt;.text&lt;/code&gt; 段合并，&lt;code&gt;a.o&lt;/code&gt; 的 &lt;code&gt;.data&lt;/code&gt; 段和 &lt;code&gt;b.o&lt;/code&gt; 的 &lt;code&gt;.data&lt;/code&gt; 段合并，最后再将合并后的各个段连接起来。&lt;/p&gt;&lt;p&gt;具体的合并方案是由一个链接器的脚本控制的，这个默认脚本可以通过命令 &lt;code&gt;$ riscv64-elf-ld --verbose&lt;/code&gt; 查看，脚本的具体含义可以参考 &lt;a href=&#34;https://sourceware.org/binutils/docs/ld/index.html&#34;&gt;LD 的文档&lt;/a&gt; 当中的 &lt;a href=&#34;https://sourceware.org/binutils/docs/ld/Scripts.html&#34;&gt;3 Linker Scripts&lt;/a&gt; 一章，这里有一个 &lt;a href=&#34;https://blog.csdn.net/m0_47799526/article/details/108765403&#34;&gt;中文翻译版&lt;/a&gt; 也可以参考一下。&lt;/p&gt;&lt;p&gt;有时目标文件可能是第三方提供的库，比如 C 的数学库 &lt;code&gt;/usr/lib/libm.so&lt;/code&gt;，所以链接时又有静态链接和动态链接之分，后续的文章会详细讲解。&lt;/p&gt;&lt;p&gt;下面是链接命令：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ riscv64-elf-ld -o app.out app.o&lt;/code&gt;&lt;/p&gt;&lt;p&gt;上面程序运行之后得到文件 &lt;code&gt;app.out&lt;/code&gt;。&lt;/p&gt;&lt;h3 id=&#34;可执行文件&#34;&gt;可执行文件&lt;/h3&gt;&lt;p&gt;链接器的输出结果是一个可执行文件，下面查看可执行文件的信息。&lt;/p&gt;&lt;h4 id=&#34;文件类型-1&#34;&gt;文件类型&lt;/h4&gt;&lt;p&gt;使用 &lt;code&gt;file&lt;/code&gt; 工具查看文件的类型：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ file app.out&lt;/code&gt;&lt;/p&gt;&lt;p&gt;输出如下信息：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;app.out: ELF 64-bit LSB executable, UCB RISC-V, double-float ABI, version 1 (SYSV), statically linked, with debug_info, not stripped&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;对比之前的 &lt;code&gt;app.o&lt;/code&gt; 的会发现文件类型已经由 &lt;code&gt;ELF relocatable&lt;/code&gt; 变成 &lt;code&gt;ELF executable&lt;/code&gt;。使用 &lt;code&gt;riscv64-elf-readelf -h&lt;/code&gt; 同样可以查看 ELF 格式的头信息：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ riscv64-elf-readelf -h app.o&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ riscv64-elf-readelf -h app.out&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;输出的结果如下：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&amp;lt; Type:                              REL (Relocatable file)&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&amp;lt; Entry point address:               0x0&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&amp;lt; Start of program headers:          0 (bytes into file)&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&amp;lt; Number of program headers:         0&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&amp;gt; Type:                              EXEC (Executable file)&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&amp;gt; Entry point address:               0x100b0&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&amp;gt; Start of program headers:          64 (bytes into file)&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&amp;gt; Number of program headers:         2&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;符号列表-1&#34;&gt;符号列表&lt;/h4&gt;&lt;p&gt;然后再看看导出符号表：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ riscv64-elf-nm app.out&lt;/code&gt;&lt;/p&gt;&lt;p&gt;输出的内容如下：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;00000000000110d0 T __BSS_END__&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;00000000000110cc T __bss_start&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;00000000000110cc T __DATA_BEGIN__&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;00000000000110cc T _edata&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;00000000000110d0 T _end&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;00000000000118cc A __global_pointer$&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;00000000000100b4 t _loop&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;00000000000100bc T _print_a&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;00000000000110cc T __SDATA_BEGIN__&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;00000000000100b0 T _start&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;发现多出了几个符号，比如 &lt;code&gt;__DATA_BEGIN&lt;/code&gt;，&lt;code&gt;__bss_start&lt;/code&gt; 等，这些符号来自链接脚本。&lt;/p&gt;&lt;h4 id=&#34;段-1&#34;&gt;段&lt;/h4&gt;&lt;p&gt;然后再看段信息：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ riscv64-elf-objdump -h app.out&lt;/code&gt;&lt;/p&gt;&lt;p&gt;输出的内容如下：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Idx Name          Size      VMA               LMA               File off  Algn&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  0 .text         0000001c  00000000000100b0  00000000000100b0  000000b0  2**2&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                  CONTENTS, ALLOC, LOAD, READONLY, CODE&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;发现 &lt;code&gt;.data&lt;/code&gt; 和 &lt;code&gt;.bss&lt;/code&gt; 段不见了，那是因为它们原本就是无内容的，长度为 0，所以在最后输出文件里被 &amp;ldquo;优化&amp;rdquo;（即被移除）了。&lt;/p&gt;&lt;p&gt;&lt;code&gt;.text&lt;/code&gt; 的长度不变，而 &lt;code&gt;VMA&lt;/code&gt; （虚拟内存地址）和 &lt;code&gt;LMA&lt;/code&gt; （加载内存地址）的值都变为 &lt;code&gt;0x1_00b0&lt;/code&gt;。&lt;/p&gt;&lt;h4 id=&#34;program-headers&#34;&gt;Program Headers&lt;/h4&gt;&lt;p&gt;因为 &lt;code&gt;app.out&lt;/code&gt; 已经是可执行文件，所以现在可以查看 &amp;ldquo;program headers&amp;rdquo; 了：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ riscv64-elf-readelf -l app.out&lt;/code&gt;&lt;/p&gt;&lt;p&gt;输出的结果如下：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Elf file type is EXEC (Executable file)&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Entry point 0x100b0&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;There are 2 program headers, starting at offset 64&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Program Headers:&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  Type           Offset             VirtAddr           PhysAddr&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                 FileSiz            MemSiz              Flags  Align&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  RISCV_ATTRIBUT 0x00000000000000cc 0x0000000000000000 0x0000000000000000&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                 0x0000000000000043 0x0000000000000000  R      0x1&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  LOAD           0x0000000000000000 0x0000000000010000 0x0000000000010000&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                 0x00000000000000cc 0x00000000000000cc  R E    0x1000&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; Section to Segment mapping:&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  Segment Sections...&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   00     .riscv.attributes&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   01     .text&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&amp;ldquo;program headers&amp;rdquo; 主要用于指示程序加载器如何加载程序（到内存），由上面的结果可见程序会被加载到 &lt;code&gt;0x1_0000&lt;/code&gt;，总共加载 &lt;code&gt;0xcc&lt;/code&gt; 个字节。又因为程序的入口位于地址 &lt;code&gt;0x1_00b0&lt;/code&gt;，所以实际指令的大小为 &lt;code&gt;0xcc - 0xb0 = 0x1c&lt;/code&gt;，这个大小跟 &amp;ldquo;section headers&amp;rdquo; 列出的 &lt;code&gt;.text&lt;/code&gt; 段的大小是一致的。&lt;/p&gt;&lt;h4 id=&#34;段大小&#34;&gt;段大小&lt;/h4&gt;&lt;p&gt;然后再次查看各个段的大小：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ riscv64-elf-size app.out&lt;/code&gt;&lt;/p&gt;&lt;p&gt;输出的内容如下：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   text    data     bss     dec     hex filename&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;     28       0       0      28      1c app.out&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;对比链接之前的 &lt;code&gt;app.o&lt;/code&gt;，发现代码段（即 &lt;code&gt;.text&lt;/code&gt;）居然减少了 4 个字节，下面通过反汇编便知道其中的原因：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ riscv64-elf-objdump -d app.out&lt;/code&gt;&lt;/p&gt;&lt;p&gt;输出的结果如下：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Disassembly of section .text:&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;00000000000100b0 &amp;lt;_start&amp;gt;:&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   100b0:       00c000ef                jal     ra,100bc &amp;lt;_print_a&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;00000000000100b4 &amp;lt;_loop&amp;gt;:&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   100b4:       00000013                nop&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   100b8:       ffdff06f                j       100b4 &amp;lt;_loop&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;00000000000100bc &amp;lt;_print_a&amp;gt;:&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   100bc:       100004b7                lui     s1,0x10000&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   100c0:       04100913                li      s2,65&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   100c4:       01248023                sb      s2,0(s1) # 10000000 &amp;lt;__global_pointer$+0xffee734&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   100c8:       00008067                ret&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;从反汇编的结果发现两处不同：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;指令的地址从 0x1_00b0 开始（原先从 0 开始）；&lt;/li&gt;&lt;li&gt;&lt;code&gt;call _print_a&lt;/code&gt; 语句由 2 个指令 &lt;code&gt;auipc&lt;/code&gt; 和 &lt;code&gt;jalr&lt;/code&gt; 转换为 1 个指令 &lt;code&gt;jal&lt;/code&gt;，且目标地址被填上真实的地址，RISC-V 一条指令（不管是 32 位还是 64 位）的长度为 4 个字节，所以少了一条指令刚好就少了 4 个字节。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;现在分析指令 &lt;code&gt;00c000ef&lt;/code&gt;：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;0    0000000110 0    00000000 00001 1101111&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;---- ---------- ---- -------- ----- -------&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;[20] [10:1]     [11] [19:12]  rd=1  jal&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;解码得出：&lt;code&gt;jal ra, 0b1100&lt;/code&gt;，其中 &lt;code&gt;0b1100&lt;/code&gt; 是地址偏移值，下面来算算它表示的绝对地址：当前指令地址为 &lt;code&gt;0x1_00b0&lt;/code&gt;，即在运行的时候，&lt;code&gt;PC&lt;/code&gt; 寄存器的值为 &lt;code&gt;0x1_00b0&lt;/code&gt;，加上偏移值 &lt;code&gt;0b1100&lt;/code&gt; 得出 &lt;code&gt;0x100bc&lt;/code&gt;，这正好是函数 &lt;code&gt;_print_a&lt;/code&gt; 的地址。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;在数字电路里寄存器 &lt;code&gt;PC&lt;/code&gt; 的值主要有 3 个来源：一个是指令被获取（即 fetch）之后，PC 的当前值加上了数值 &lt;code&gt;4&lt;/code&gt; 之后的数值；另一个是当前的 PC 值加上跳转指令当中的立即数；最后一个是（jalr 指令）当前 PC 值加上跳转指令的立即数，再加上目标寄存器的值。PC 的下一个值会根据指令的不同而由 &lt;em&gt;复用器&lt;/em&gt; 采用这 3 个来源当中的一个。对于上面的 &lt;code&gt;jal&lt;/code&gt; 指令，采用的是第 2 种来源。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 id=&#34;第一次运行&#34;&gt;第一次运行&lt;/h3&gt;&lt;p&gt;上一步得到 &lt;code&gt;app.out&lt;/code&gt; 是一个 ELF 格式的可执行文件，不过如果你当前操作的计算机是 x86（现在一般指 AMD64 或者 x86-64）或者 ARM 架构的，是无法直接执行这个文件的，因为这个可执行文件的目标平台是 RISC-V 架构。河马蜀黍当前的计算机是 x86 架构，直接执行之后出现了如下提示信息：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ ./app.out&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Segmentation fault (core dumped)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我不知道在你的计算机上运行之后会出现什么信息，不过很明显 x86 CPU 无法正确理解 RISC-V 的指令，经过一番挣扎之后估计都会以失败告终（比如上面显示的是 &lt;em&gt;段失败&lt;/em&gt; 错误）。&lt;/p&gt;&lt;p&gt;下面使用模拟器 QEMU RISC-V 来运行可执行文件 &lt;code&gt;app.out&lt;/code&gt;，&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ qemu-system-riscv64 &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;    -machine virt &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;    -nographic &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;    -bios none &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;    -kernel app.out&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这次不会显示 &lt;em&gt;段失败&lt;/em&gt; 错误了，但是等了半天都没等到程序结束，也没看到大写字母 “A”，显然应用程序仍然没有被正确执行。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;按 &lt;code&gt;Ctrl+a, x&lt;/code&gt;（即先按下 &lt;code&gt;Ctrl+a&lt;/code&gt;，然后再单独按下 &lt;code&gt;x&lt;/code&gt; 键）可结束 QEMU，这个组合键我会反复提示，免得你跟第一次退出 VIM 一样手忙脚乱。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;通过后续的文章的 GDB 调试可知，QEMU RISC-V virt 会假设内核程序的开始位置在内存的 &lt;code&gt;0x8000_0000&lt;/code&gt;，而我们的程序被加载到 &lt;code&gt;0x0001_00b0&lt;/code&gt;，因此程序根本没有被执行。&lt;/p&gt;&lt;p&gt;这里的 &lt;code&gt;0x8000_0000&lt;/code&gt; 是一个映射地址，并不是说虚拟机真的有这么大的内存（实际上默认 QEMU RISC-V 虚拟机只有 128MB 内存），这个地址被映射到内存 RAM 的开始位置，可以从 &lt;a href=&#34;https://github.com/qemu/qemu/blob/master/hw/riscv/virt.c&#34;&gt;QEMU RISC-V virt 的源代码&lt;/a&gt; 找到映射关系：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; MemMapEntry virt_memmap[] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    [VIRT_MROM] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;         {     &lt;span style=&#34;color:#ae81ff&#34;&gt;0x1000&lt;/span&gt;,        &lt;span style=&#34;color:#ae81ff&#34;&gt;0xf000&lt;/span&gt; },&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ...&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    [VIRT_UART0] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;        { &lt;span style=&#34;color:#ae81ff&#34;&gt;0x10000000&lt;/span&gt;,         &lt;span style=&#34;color:#ae81ff&#34;&gt;0x100&lt;/span&gt; },&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ...&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    [VIRT_FLASH] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;        { &lt;span style=&#34;color:#ae81ff&#34;&gt;0x20000000&lt;/span&gt;,     &lt;span style=&#34;color:#ae81ff&#34;&gt;0x4000000&lt;/span&gt; },&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ...&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    [VIRT_DRAM] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;         { &lt;span style=&#34;color:#ae81ff&#34;&gt;0x80000000&lt;/span&gt;,           &lt;span style=&#34;color:#ae81ff&#34;&gt;0x0&lt;/span&gt; },&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;&lt;p&gt;有关 QEMU RISC-V 的使用及程序调试方法，会在后续的文章中讲解。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 id=&#34;链接脚本&#34;&gt;链接脚本&lt;/h3&gt;&lt;p&gt;那么怎样才能把程序加载到指定的位置呢？这时候就需要定制的 &lt;em&gt;链接脚本&lt;/em&gt; 了。链接脚本可以让链接器按照我们的需求产生输出文件，当然也就可以指定程序的加载到内存后的位置。&lt;/p&gt;&lt;p&gt;目录 &lt;a href=&#34;./resources/&#34;&gt;resources&lt;/a&gt; 里有一个链接器脚本文件 &lt;code&gt;app.lds&lt;/code&gt;，其内容如下：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;OUTPUT_ARCH(riscv)&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ENTRY(_start)&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;BASE_ADDRESS = 0x80000000;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;SECTIONS&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  . = BASE_ADDRESS;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  .text : {&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    *(.text.entry)&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    *(.text .text.*)&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  .rodata : {&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    *(.rodata .rodata.*)&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  .data : {&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    *(.sdata .sdata.*)&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    *(.data .data.*)&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  .bss :{&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    *(.sbss .sbss.*)&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    *(.bss .bss.*)&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后在链接时指定链接脚本：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ riscv64-elf-ld -T app.lds -o app.out app.o&lt;/code&gt;&lt;/p&gt;&lt;p&gt;其中参数 &lt;code&gt;-T app.lds&lt;/code&gt; 用于指定链接脚本。&lt;/p&gt;&lt;p&gt;现在得到了新的文件 &lt;code&gt;app.out&lt;/code&gt;，使用命令 &lt;code&gt;$ riscv64-elf-objdump -h app.out&lt;/code&gt; 查看段信息，输出内容如下：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Idx Name          Size      VMA               LMA               File off  Algn&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  0 .text         0000001c  0000000080000000  0000000080000000  00001000  2**2&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                  CONTENTS, ALLOC, LOAD, READONLY, CODE&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可见代码段 &lt;code&gt;.text&lt;/code&gt; 的加载地址已经变为 &lt;code&gt;0x8000_0000&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;再看看 &amp;ldquo;program headers&amp;rdquo;：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ riscv64-elf-readelf -l app.out&lt;/code&gt;&lt;/p&gt;&lt;p&gt;输出的结果如下：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Elf file type is EXEC (Executable file)&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Entry point 0x80000000&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;There are 2 program headers, starting at offset 64&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Program Headers:&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  Type           Offset             VirtAddr           PhysAddr&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                 FileSiz            MemSiz              Flags  Align&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  RISCV_ATTRIBUT 0x000000000000101c 0x0000000000000000 0x0000000000000000&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                 0x0000000000000043 0x0000000000000000  R      0x1&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  LOAD           0x0000000000001000 0x0000000080000000 0x0000000080000000&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                 0x000000000000001c 0x000000000000001c  R E    0x1000&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; Section to Segment mapping:&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  Segment Sections...&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   00     .riscv.attributes&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   01     .text&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;从上面的信息可见程序的入口以及虚拟内存地址均为 &lt;code&gt;0x80000000&lt;/code&gt;，加载的大小为 &lt;code&gt;0x1c&lt;/code&gt; 字节，刚好就是代码段的大小。&lt;/p&gt;&lt;h3 id=&#34;第二次运行&#34;&gt;第二次运行&lt;/h3&gt;&lt;p&gt;下面执行新生成的可执行文件 &lt;code&gt;app.out&lt;/code&gt;：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ qemu-system-riscv64 &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;    -machine virt &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;    -nographic &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;    -bios none &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;    -kernel app.out&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如无意外，应该可以看到在终端输出大写字母 “A”。再友情提示一下，按 &lt;code&gt;Ctrl+x, a&lt;/code&gt; 终止 QEMU。&lt;/p&gt;&lt;h3 id=&#34;给程序减肥&#34;&gt;给程序减肥&lt;/h3&gt;&lt;p&gt;现在纯汇编写的 RISC-V 程序就已经完成了，先看看程序的大小：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ ls -lh&lt;/code&gt;&lt;/p&gt;&lt;p&gt;输出的结果如下：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-rw-r--r-- 1 yang yang  311 Oct 21 15:27 app.lds&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-rw-r--r-- 1 yang yang 3.2K Oct 21 11:05 app.o&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-rwxr-xr-x 1 yang yang 5.6K Oct 21 15:27 app.out&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-rw-r--r-- 1 yang yang  442 Oct 21 06:57 app.S&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;发现了吗？可执行文件 &lt;code&gt;app.out&lt;/code&gt; 居然有 &lt;code&gt;5.6KB&lt;/code&gt;，它是如此巨大！不是说只有 30 左右字节的吗？下面我们来给程序减减肥吧。&lt;/p&gt;&lt;p&gt;首先需要知道为什么 &lt;code&gt;app.out&lt;/code&gt; 文件会那么大，明明当前的应用程序非常简单，编译之后的指令序列只有 &lt;code&gt;0x1c&lt;/code&gt;（即十进制的 &lt;code&gt;28&lt;/code&gt;） 个字节。那是因为 ELF 文件格式有固定的结构，这些结构会占用一定的空间，另外 ELF 文件里还包含用于程序调试的信息。使用工具 &lt;code&gt;riscv64-elf-objcopy&lt;/code&gt; 可以把这些信息通通去掉，只剩下跟链接脚本描述一致的二进制数据（也就是说 &lt;code&gt;.text&lt;/code&gt;，&lt;code&gt;.rodata&lt;/code&gt; 和 &lt;code&gt;.data&lt;/code&gt; 等段的信息会被保留）：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ riscv64-elf-objcopy -S -O binary app.out app.bin&lt;/code&gt;&lt;/p&gt;&lt;p&gt;参数 &lt;code&gt;-S&lt;/code&gt; 表示移除所有多余的信息（包括调试信息），&lt;code&gt;-O binary&lt;/code&gt; 表示输出文件的格式， &lt;code&gt;app.out&lt;/code&gt; 和 &lt;code&gt;app.bin&lt;/code&gt; 分别表示输入和输出的文件名。&lt;/p&gt;&lt;p&gt;指令执行完毕之后会产生一个名为 &lt;code&gt;app.bin&lt;/code&gt; 的文件，下面检查它的大小：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ ls -l app.bin&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-rwxr-xr-x 1 yang yang 28 Oct 21 15:34 app.bin&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;果然只剩下 &lt;code&gt;28&lt;/code&gt; 个字节，使用 &lt;code&gt;xxd&lt;/code&gt; 工具可以肉眼查看它的内容：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ xxd app.bin&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;00000000: ef00 c000 1300 0000 6ff0 dfff b704 0010  ........o.......&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;00000010: 1309 1004 2380 2401 6780 0000            ....#.$.g...&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果你的记忆好的话，可能会对上面一段数字有一种似曾相识的感觉，它正是上面章节反汇编可执行文件 &lt;code&gt;app.out&lt;/code&gt; 代码段时的内容，比如开头的 4 个字节 &lt;code&gt;ef 00 c0 00&lt;/code&gt;，因为磁盘储存采用 &lt;em&gt;小端序&lt;/em&gt; 的缘故，我们需要将字节的顺序反转，得到 &lt;code&gt;00 c0 00 ef&lt;/code&gt;，这正是第一条指令 &lt;code&gt;jal ra,100bc&lt;/code&gt; 的机器码 &lt;code&gt;0x00c000ef&lt;/code&gt;。&lt;/p&gt;&lt;h3 id=&#34;第三次运行&#34;&gt;第三次运行&lt;/h3&gt;&lt;p&gt;下面尝试用 QEMU 运行它，不过因为 &lt;code&gt;app.bin&lt;/code&gt; 除了机器指令，其余的所有信息都被移除了，所以需要手动指定程序加载到内存的位置，也就是说再也不能直接把 &lt;code&gt;app.bin&lt;/code&gt; 作为 &lt;code&gt;-kernel&lt;/code&gt; 参数传给 QEMU，转而需要使用参数 &lt;code&gt;-device loader,file=FILENAME,addr=ADDRESS&lt;/code&gt;：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ qemu-system-riscv64 &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;    -machine virt &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;    -nographic &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;    -bios none &lt;span style=&#34;color:#ae81ff&#34;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;    -device loader,file&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;app.bin,addr&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;0x80000000&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如无意外，上面的命令也能输出正确的结果，同样按 &lt;code&gt;Ctrl+a, x&lt;/code&gt; 退出 QEMU。&lt;/p&gt;&lt;h2 id=&#34;最小的-linux-程序&#34;&gt;最小的 Linux 程序&lt;/h2&gt;&lt;p&gt;本章要实现一个最小的 Linux 程序，它的功能是向控制台打印一行 &amp;ldquo;Hello world!\n&amp;rdquo; 文本。跟之前的 &amp;ldquo;Hello world&amp;rdquo; 程序不同的是，它不需要标准库的支持，而是直接进行系统调用，其次它用汇编书写&lt;/p&gt;&lt;h3 id=&#34;系统调用&#34;&gt;系统调用&lt;/h3&gt;&lt;p&gt;Linux 程序也就是平常我们所接触到的普通程序，跟上面的裸机程序不同的是，普通程序运行于计算机的 &lt;code&gt;用户模式&lt;/code&gt;，在这种模式下应用程序是无法直接跟硬件打交道的，包括无法访问任意位置的内存，无法访问 CPU 当中部分需要特权的寄存器，也无法执行需要特权的指令（裸机程序通常运行于 &lt;code&gt;机器模式&lt;/code&gt; 或者 &lt;code&gt;监管模式&lt;/code&gt;，它可以直接访问计算机的所有资源）。所以即使是向串口控制台打印一行 &amp;ldquo;Hello World!&amp;rdquo; 字符串也是办不到的。&lt;/p&gt;&lt;p&gt;普通的应用程序只能将自己的需求向操作系统倾诉，操作系统负责具体的工作，然后再把结果返回给应用程序，这个过程称为 &lt;em&gt;系统调用&lt;/em&gt;。如果从应用程序角度来看操作系统的话，它既是应用程序的管理者，同时也是应用程序的打工人（是的，在计算机的世界里就是存在这种奇怪的角色）。&lt;/p&gt;&lt;p&gt;不过平常我们写应用程序很少会直接进行 &lt;em&gt;系统调用&lt;/em&gt;（&lt;em&gt;系统调用&lt;/em&gt; 的具体表现形式也是 &lt;em&gt;函数调用&lt;/em&gt;），因为这些函数比较原始，调用起来不够方便，再者，不同的操作系统的系统调用是不同的。因此标准库（libc）把系统调用进行封装，同时为不同的平台提供不同的实现，最后打包成各种方便的函数以供我们使用。&lt;/p&gt;&lt;h3 id=&#34;系统调用的实现&#34;&gt;系统调用的实现&lt;/h3&gt;&lt;p&gt;RISC-V Linux 的系统调用实现很简单，大概以下几个步骤：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;每个系统调用（你可以粗略理解为 &lt;em&gt;函数&lt;/em&gt;）都有一个编号，比如 &lt;code&gt;write&lt;/code&gt; 函数的编号是 &lt;code&gt;0x40&lt;/code&gt;，&lt;code&gt;exit&lt;/code&gt; 函数的编号是 &lt;code&gt;0x5d&lt;/code&gt;，把这个编号储存在寄存器 &lt;code&gt;a7&lt;/code&gt; 里。&lt;/li&gt;&lt;/ol&gt;&lt;blockquote&gt;&lt;p&gt;系统调用的编号可以查阅 &lt;a href=&#34;https://github.com/riscv-collab/riscv-gnu-toolchain/blob/master/linux-headers/include/asm-generic/unistd.h&#34;&gt;RISC-V GCC Linux headers - unistd.h&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;ol start=&#34;2&#34;&gt;&lt;li&gt;&lt;p&gt;把函数的参数的值分别储存在寄存器 &lt;code&gt;a0&lt;/code&gt;、&lt;code&gt;a1&lt;/code&gt; &amp;hellip; 里。&lt;/p&gt;&lt;p&gt;每个系统调用的参数情况可以查看它的函数签名，比如 &lt;code&gt;write&lt;/code&gt; 函数的签名是：&lt;/p&gt;&lt;p&gt;&lt;code&gt;ssize_t write(int fd, const void *buf, size_t count);&lt;/code&gt;&lt;/p&gt;&lt;p&gt;从签名可知它有 3 个参数，分别是文件描述符（编号）、内容（即缓存）的开始位置、内容的长度（单位为字节），把这三个参数值分别储存在寄存器 &lt;code&gt;a0&lt;/code&gt;, &lt;code&gt;a1&lt;/code&gt; 和 &lt;code&gt;a3&lt;/code&gt; 里。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote&gt;&lt;p&gt;系统调用的签名可以使用命令 &lt;code&gt;$ man 2 SYSCALL_NAME&lt;/code&gt; 查看，注意需要在 &lt;code&gt;man&lt;/code&gt; 后面添加数字 &lt;code&gt;2&lt;/code&gt;，表示查看系统调用的说明。不添加或者添加数字 &lt;code&gt;1&lt;/code&gt; 的话显示的是 &lt;code&gt;write&lt;/code&gt; 命令的说明。顺便一提，数字 &lt;code&gt;3&lt;/code&gt; 表示查看标准库的函数 &lt;code&gt;write&lt;/code&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;ol start=&#34;3&#34;&gt;&lt;li&gt;执行 &lt;code&gt;ecall&lt;/code&gt; 指令。该指令会引起一个中断，计算机的控制权由应用程序转给操作系统，操作系统捕获到这个中断并理解其目的，最后把结果储存到寄存器 &lt;code&gt;a0&lt;/code&gt;，然后把计算机控制权交给应用程序。&lt;/li&gt;&lt;/ol&gt;&lt;h3 id=&#34;程序的源代码&#34;&gt;程序的源代码&lt;/h3&gt;&lt;p&gt;源代码位于目录 &lt;a href=&#34;./resources/minimal-hello-world/&#34;&gt;resouces/minimal-hello-world&lt;/a&gt; 之下的文件 &lt;code&gt;app.S&lt;/code&gt;，其内容如下：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-s&#34; data-lang=&#34;s&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.equ SYSCALL_WRITE, &lt;span style=&#34;color:#ae81ff&#34;&gt;64&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.equ SYSCALL_EXIT, &lt;span style=&#34;color:#ae81ff&#34;&gt;93&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.equ STDOUT_FD, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.section .text&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.globl _start&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;_start&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# ssize_t write(int fd, const void *buf, size_t count);&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    addi a7, zero, SYSCALL_WRITE&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    addi a0, zero, STDOUT_FD&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    la a1, hello_world&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    addi a2, zero, &lt;span style=&#34;color:#ae81ff&#34;&gt;13&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;# the length of &amp;#34;Hello world!\n&amp;#34;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ecall&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# void exit(int status)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    addi a7, zero, SYSCALL_EXIT&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    addi a0, zero, &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ecall&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.section .rodata&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;hello_world&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    .ascii &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Hello world!\n&amp;#34;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上面的汇编代码相当于如下的 C 代码（源代码文件 &lt;code&gt;app.c&lt;/code&gt;）：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(){&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;buf &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Hello world!&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    write(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, buf, &lt;span style=&#34;color:#ae81ff&#34;&gt;13&lt;/span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    exit(&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;编译&#34;&gt;编译&lt;/h3&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ riscv64-linux-gnu-as -o app.o app.S&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ riscv64-linux-gnu-gcc -nostdlib -static -o app.out app.o&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上面的链接命令中的参数 &lt;code&gt;-nostdlib&lt;/code&gt; 表示不需要标准库。作为对比，下面也编译 C 版本的程序：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ riscv64-linux-gnu-gcc -static -o app-std.out app.c&lt;/code&gt;&lt;/p&gt;&lt;p&gt;然后对比文件 &lt;code&gt;app.out&lt;/code&gt; 和 &lt;code&gt;app-std.out&lt;/code&gt; 的大小：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ ls -lh&lt;/code&gt;&lt;/p&gt;&lt;p&gt;输出的结果如下：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-rwxr-xr-x 1 yang yang 1.6K Oct 25 05:30 app.out&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-rwxr-xr-x 1 yang yang 644K Oct 25 05:34 app-std.out&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可见汇编版本的只有 2KB 不到，而标准版本的有 644KB（当然使用静态链接也是导致体积较大的原因之一）&lt;/p&gt;&lt;h3 id=&#34;运行&#34;&gt;运行&lt;/h3&gt;&lt;p&gt;&lt;code&gt;$ qemu-riscv64 app.out&lt;/code&gt;&lt;/p&gt;&lt;p&gt;输入的结果是一行文本 &amp;ldquo;Hello world!&amp;quot;。&lt;/p&gt;&lt;p&gt;下一篇文章 &lt;a href=&#34;../qemu-and-opensbi-and-debug/README.zh-Hans.md&#34;&gt;QEMU、OpenSBI 及裸机程序的调试&lt;/a&gt; 我们将会详细讲解 QEMU 的使用方法，OpenSBI 的作用以及调试裸机程序的方法。&lt;/p&gt;</description>
     </item>
   
     <item>
       <title></title>
       <link>https://hemashushu.github.io/posts/2022-11-08-qemu-and-debug/readme.zh-hans/</link>
       <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
       
       <guid>https://hemashushu.github.io/posts/2022-11-08-qemu-and-debug/readme.zh-hans/</guid>
       <description>&lt;h1 id=&#34;qemu-模拟器及程序的调试&#34;&gt;QEMU 模拟器及程序的调试&lt;/h1&gt;&lt;p&gt;在&lt;a href=&#34;../build-risc-v-program-from-assembly-code/README.zh-Hans.md&#34;&gt;上一篇文章&lt;/a&gt;我们了解了一个 RISC-V 程序的组成和运行原理，其中程序都是在 QEMU 里运行的，这篇文章将会讲解 QEMU 的详细使用方法，OpenSBI 的作用，以及通过 QEMU 调试裸机程序的方法。&lt;/p&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&#34;#qemu-%E5%85%A8%E7%B3%BB%E7%BB%9F%E6%A8%A1%E5%BC%8F&#34;&gt;QEMU 全系统模式&lt;/a&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&#34;#%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8E%9F%E7%90%86&#34;&gt;运行程序的原理&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#%E5%8A%A0%E8%BD%BD%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F&#34;&gt;加载应用程序&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#risc-v-%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%89%B9%E6%9D%83%E7%BA%A7%E5%88%AB&#34;&gt;RISC-V 系统的特权级别&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#qemu-%E5%85%B6%E5%AE%83%E5%B8%B8%E7%94%A8%E5%8F%82%E6%95%B0&#34;&gt;QEMU 其它常用参数&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#%E7%9C%9F%E5%AE%9E-risc-v-%E7%A1%AC%E4%BB%B6&#34;&gt;真实 RISC-V 硬件&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#opensbi&#34;&gt;OpenSBI&lt;/a&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&#34;#%E8%B0%83%E7%94%A8-sbi-%E6%9C%8D%E5%8A%A1&#34;&gt;调用 SBI 服务&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#%E8%A3%B8%E6%9C%BA%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%B0%83%E8%AF%95&#34;&gt;裸机程序的调试&lt;/a&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&#34;#gdb-%E7%9A%84%E8%B0%83%E8%AF%95%E6%96%B9%E5%BC%8F&#34;&gt;GDB 的调试方式&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;#%E8%B0%83%E8%AF%95%E8%A3%B8%E6%9C%BA%E7%A8%8B%E5%BA%8F&#34;&gt;调试裸机程序&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;!-- raw HTML omitted --&gt;&lt;h2 id=&#34;qemu-全系统模式&#34;&gt;QEMU 全系统模式&lt;/h2&gt;&lt;p&gt;前面的文章提到，QEMU 有两种工作模式：一种是 &lt;em&gt;全系统模式&lt;/em&gt;，此时 QEMU 会模拟一整套计算机硬件，包括 CPU、内存、磁盘、网络接口、USB 接口等组件；另外一种是 &lt;em&gt;用户模式&lt;/em&gt;，用于直接运行目标架构为 RISC-V 的可执行文件。&lt;/p&gt;&lt;p&gt;因为 &lt;em&gt;用户模式&lt;/em&gt; 在本项目里使用的场合很少，所以这篇文章主要讲解 &lt;em&gt;全系统模式&lt;/em&gt;，即程序 &lt;code&gt;qemu-system-riscv64&lt;/code&gt;。&lt;/p&gt;&lt;h3 id=&#34;运行程序的原理&#34;&gt;运行程序的原理&lt;/h3&gt;&lt;p&gt;使用 QEMU 的全系统模式运行一个裸机程序（以下叫应用程序）的大概过程如下：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;把应用程序的内容（&lt;code&gt;.text&lt;/code&gt; 和 &lt;code&gt;.data&lt;/code&gt; 等）传给 QEMU；&lt;/li&gt;&lt;li&gt;QEMU 会把程序的内容加载进虚拟机的内存里；&lt;/li&gt;&lt;li&gt;从应用程序的指令序列的第一个（或者指定入口地址的）指令开始执行指令。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;QEMU 有一小段固定的程序（&lt;em&gt;ROM&lt;/em&gt;），程序当中的部分数值是 QEMU 动态生成的，具体生成过程可以参阅 QEMU 源码 &lt;a href=&#34;https://github.com/Xilinx/qemu/blob/master/hw/riscv/boot.c&#34;&gt;/hw/riscv/boot.c&lt;/a&gt;。该 ROM 的地址是 &lt;code&gt;0x1000&lt;/code&gt;，主要内容如下：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;0x1000:     auipc   t0,0x0          # t0 = $pc + sign_extend(immediate) &amp;lt;&amp;lt; 12&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                                    #       t0 == 0x1000&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;0x1004:     addi    a2,t0,40        # a2 = t0 + 0x28&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                                    #       a2 == 0x1028&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                                    # 0x1028 是结构体 fw_dynamic_info 的内容的地址&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                                    #&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;0x1008:     csrr    a0,mhartid      # Hart ID Register (mhartid)&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                                    #       即运行当前代码的硬件线程（即 CPU 核）的 ID，&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                                    #       所有 CPU 核都会运行这段程序，所以 a0 的值会因 CPU 核而不同，&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                                    #       对于第一个 CPU 核，其 id 为 0。&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                                    #&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;0x100c:     ld      a1,32(t0)       # a1 = t0[0x20]&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                                    #       memory[0x1020] == 0x80000000，所以 a1 == 0x87000000&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                                    #&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;0x1010:     ld      t0,24(t0)       # t0 = t0[0x18]&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                                    #       memory[0x1018] == 0x80000000，所以 t0 == 0x80000000&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                                    #&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;0x1014:     jr      t0              # 跳转到 0x80000000&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                                    #&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;0x1018:     .2byte  0x0             # start_addr, 0x80000000&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;0x101a:     .2byte  0x8000          #&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;0x101c:     .2byte  0x0             #&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;0x101e:     .2byte  0x0             #&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                                    #&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;0x1020:     .2byte  0x0             # fdt_laddr, 0x87000000&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;0x1022:     .2byte  0x87e0          #&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;0x1024:     .2byte  0x0             #&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;0x1026:     .2byte  0x0             #&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;...&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;0x1038:     .2byte  0x0             # fw_dyn, 0x86000000&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;0x103a:     .2byte  0x8600          #&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;0x103c:     .2byte  0x0             #&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;0x103e:     .2byte  0x0             #&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;指令后面已加了注释，简单来说，这段程序主要实现了：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;设置寄存器 &lt;code&gt;a0&lt;/code&gt; 的值为 CPU 核的 id；&lt;/li&gt;&lt;li&gt;设置寄存器 &lt;code&gt;a1&lt;/code&gt; 和 &lt;code&gt;a2&lt;/code&gt; 的值，暂时可忽略；&lt;/li&gt;&lt;li&gt;然后跳转到 &lt;code&gt;0x80000000&lt;/code&gt;。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;显然只要应用程序的起始地址为 &lt;code&gt;0x80000000&lt;/code&gt;，QEMU 就能运行应用程序。&lt;/p&gt;&lt;h3 id=&#34;加载应用程序&#34;&gt;加载应用程序&lt;/h3&gt;&lt;p&gt;将应用程序传给 QEMU 程序有 3 个参数都可以实现：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;通过 &lt;code&gt;-bios&lt;/code&gt; 参数传递；&lt;/li&gt;&lt;li&gt;通过 &lt;code&gt;-kernel&lt;/code&gt; 参数传递；&lt;/li&gt;&lt;li&gt;通过 &lt;code&gt;-device loader&lt;/code&gt; 参数传递。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;虽然这 3 个参数的含义不相同，不过对于一个简单的裸机程序来说，却都是可行的加载方法。&lt;/p&gt;&lt;p&gt;在本文的子目录 &lt;a href=&#34;resources/hello-uart/&#34;&gt;resources/hello-uart&lt;/a&gt; 里有一个简单的裸机程序，程序的功能是向串口控制台打印一行 &amp;ldquo;Hello UART!&amp;rdquo; 文本。首先编译该程序：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ riscv64-elf-as -g -o app.o app.S&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ riscv64-elf-ld -T app.lds -o app.out app.o&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;现在得到一个 ELF 格式的可执行文件 &lt;code&gt;app.out&lt;/code&gt;。下面的 3 个命令行都可以正确运行该程序：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;qemu-system-riscv64 -machine virt -nographic -bios app.out&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;qemu-system-riscv64 -machine virt -nographic -bios none -kernel app.out&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;qemu-system-riscv64 -machine virt -nographic -bios none -device loader,file=app.out&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;其中的参数：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;-machine virt&lt;/code&gt; 用于指定板子（board）的类型，跟 x86 的成熟硬件环境不同，RISC-V 的 CPU 通常是跟 PCB 板子固定搭配（也就是说你不能像 x86 那样分别购买 CPU 和主板然后再组装在一起），而各个板子配置的外设也很不相同。还有一部分 RISC-V 系统是以 MCU（或者 SoC）的形式存在。总之各个 RISC-V 系统的硬件相差较大，所以在虚拟一个 RISC-V 系统时，QEMU 需要你指定你所需要的板子类型。一般来说如果想虚拟跟 MCU 类似的系统，可以选择 &lt;code&gt;sifive_e&lt;/code&gt;，如果没有特别的需求，只想虚拟一台普通的 RISC-V，可以选择 &lt;code&gt;virt&lt;/code&gt;。QEMU 支持的板子类型可以使用命令 &lt;code&gt;$ qemu-system-riscv64 -machine help&lt;/code&gt; 列出。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;-nographic&lt;/code&gt; 禁用图形输出，相当于一台没有集成显卡，也没有核显，同时把显卡拔掉之后的桌面电脑，系统产生的文字信息只能通过串口控制台（Serial Console， Serial Monitor）输出，对于 QEMU 来说，串口控制台输出的文字最终会重定向到运行 QEMU 程序的虚拟终端（Terminal）。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote&gt;&lt;p&gt;注意 &lt;code&gt;-display none&lt;/code&gt; 跟 &lt;code&gt;-nographic&lt;/code&gt; 不同，前者在虚拟系统里仍然存在显卡（当然是虚拟的显卡），只是相当于把显示器关掉了。也就是说，系统产生的图像或文字信息仍然会照旧输出到虚拟显卡，但因为你把显示器关掉了，所以什么信息都看不到。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;QEMU 的参数说明，可以通过命令 &lt;code&gt;$ man qemu-system-riscv64&lt;/code&gt; 查看。&lt;/p&gt;&lt;p&gt;注意在上面的 3 个命令的后两个命令中，需要指定 &lt;code&gt;-bios none&lt;/code&gt;，如果不指定该参数，QEMU 会使用默认的参数 &lt;code&gt;-bios default&lt;/code&gt;，它会使用内置的 OpenSBI 作为固件，该固件的起始地址也是 &lt;code&gt;0x8000_0000&lt;/code&gt;，所以会导致无法加载同样地址的应用程序 &lt;code&gt;app.out&lt;/code&gt;。对于 QEMU RISC-V 系统的参数说明，可以参阅 &lt;a href=&#34;https://www.qemu.org/docs/master/system/target-riscv.html&#34;&gt;QEMU RISC-V System emulator&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;QEMU 除了可以加载 ELF 格式的可执行文件，还可以加载不带任何调试信息和元信息的二进制文件（即只保留可执行文件当中的 &lt;code&gt;.text&lt;/code&gt;, &lt;code&gt;.rodata&lt;/code&gt;, &lt;code&gt;.data&lt;/code&gt;, &lt;code&gt;.bss&lt;/code&gt; 等必要 &lt;code&gt;段&lt;/code&gt;），通过命令 &lt;code&gt;$ riscv64-elf-objcopy -S -O binary app.out app.bin&lt;/code&gt; 可以得到的二进制文件 &lt;code&gt;app.bin&lt;/code&gt;。所以上面的 3 个命令还能够这样写：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;qemu-system-riscv64 -machine virt -nographic -bios app.bin&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;qemu-system-riscv64 -machine virt -nographic -bios none -kernel app.bin&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;qemu-system-riscv64 -machine virt -nographic -bios none -device loader,file=app.bin,addr=0x80000000&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;注意第 3 个命令的 &lt;code&gt;-device&lt;/code&gt; 参数值后面比之前的版本新增了 &lt;code&gt;addr=0x80000000&lt;/code&gt;，这个值用于指定二进制内容加载到内存的哪个位置。对于 ELF 格式的可执行文件来说是不需要这个参数值的，但二进制文件不包含物理内存位置和虚拟内存位置信息，因此需要额外指出。&lt;/p&gt;&lt;p&gt;既然 &lt;code&gt;-bios&lt;/code&gt;、&lt;code&gt;-kernel&lt;/code&gt; 和 &lt;code&gt;-device loader&lt;/code&gt; 都用于加载可执行文件，那么为什么还需要分别设置 3 个参数呢？原因需要从 RISC-V 系统的特权级别以及系统的启动过程讲起。&lt;/p&gt;&lt;h3 id=&#34;risc-v-系统的特权级别&#34;&gt;RISC-V 系统的特权级别&lt;/h3&gt;&lt;p&gt;RISC-V 系统的特权级别一般有 3 层，从底层到顶层分别是：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;机器模式（Machine, M-Mode）&lt;/li&gt;&lt;li&gt;监督模式 (Supervisor，S-Mode)&lt;/li&gt;&lt;li&gt;用户/应用模式 (User/Application, U-Mode)&lt;/li&gt;&lt;/ol&gt;&lt;blockquote&gt;&lt;p&gt;层级的配置并不是固定的，对于简单的 RISC-V CPU，比如 MCU，可以只有 M-Mode 一种级别。稍微强大一点的可以只有 M-Mode 和 U-Mode。对于支持虚拟化技术的 CPU，在第 1 和 2 级之间还可以有 &lt;em&gt;虚拟监督模式&lt;/em&gt; (Hypervisor, H-Mode)&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;从底层到顶层，每一层都在管理和小心翼翼地呵护下一层的程序，同时又有求必应，为下一层的程序执行那些枯燥无味的操作。为了实现这种权限结构，低层都会比高层拥有更大的权限（具体表现为：能执行更多的指令，能访问更多的资源），处于高层的程序如果想执行更高权限的操作，只能通过 &lt;code&gt;ecall&lt;/code&gt; 指令向它的低一层请求。每两层之间都有规定的交流接口：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;U-Mode 和 S-Mode 之间的交流接口叫 ABI（Application binary interface），ABI 可以粗略理解为在汇编语言层面的 API。ABI 也可以称为 &lt;em&gt;系统调用&lt;/em&gt;（Syscall）。&lt;/li&gt;&lt;li&gt;S-Mode 和 M-Mode 之间的交流接口在 RISC-V 系统里叫做 SBI（Supervisor Binary Interface），SBI 在表现形式上跟 ABI 是一样的，只不过它处于的层级不同而定了一个新的名称，具体的内容可以参考 &lt;a href=&#34;https://github.com/riscv-non-isa/riscv-sbi-doc/releases&#34;&gt;SBI 规范&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img src=&#34;images/riscv-privileged.png&#34; alt=&#34;riscv privileged&#34;&gt;&lt;/p&gt;&lt;p&gt;我们平常接触的普通应用程序运行在 U-Mode，而操作系统的内核则运行在 S-Mode，通常系统引导程序（Bootloader）也是运行在 S-Mode。而运行于机器模式的程序用于封装一些比较底层的硬件操作，比如暂停或者恢复 CPU 某个核，同时用于捕捉和处理操作系统内核引起的异常，比如内核崩溃（即 &lt;em&gt;kernel panic&lt;/em&gt;，有些教程翻译为 &lt;em&gt;内核恐慌&lt;/em&gt; 实际上是错误的）之后向屏幕显示一些提示信息。运行于 M-Mode 的程序也称为 &lt;em&gt;监督模式执行环境&lt;/em&gt;（Supervisor Execution Environment，SEE），目前有几个运行于 M-Mode 的程序，比如 &lt;a href=&#34;https://github.com/riscv-software-src/opensbi&#34;&gt;OpenSBI&lt;/a&gt; 以及 &lt;a href=&#34;https://github.com/rustsbi/rustsbi&#34;&gt;RustSBI&lt;/a&gt;，这些程序有时也被称为 &lt;em&gt;固件&lt;/em&gt;（Firmware）。&lt;/p&gt;&lt;p&gt;QEMU 的参数 &lt;code&gt;-bios&lt;/code&gt; 一般用于传入诸如 OpenSBI 等固件，而参数 &lt;code&gt;-kernel&lt;/code&gt; 则用于传入 Bootloader 或者操作系统内核，&lt;code&gt;-kernel&lt;/code&gt; 支持传入压缩文件。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;当参数 &lt;code&gt;-kernel&lt;/code&gt; 传入的是 Linux 内核映像时，通常还会搭配 &lt;code&gt;-append&lt;/code&gt; 参数用于指定内核的命令行参数。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 id=&#34;qemu-其它常用参数&#34;&gt;QEMU 其它常用参数&lt;/h3&gt;&lt;p&gt;QEMU 还有几个常用的参数：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;-smp&lt;/code&gt; 指定 CPU 的核数量，默认的核是 1，如果想模拟多核的系统，对于 RISC-V 板子 &lt;code&gt;virt&lt;/code&gt; 最多可以指定 8 个核。&lt;/li&gt;&lt;li&gt;&lt;code&gt;-m&lt;/code&gt; 指定内存的容量，默认是 128 MB，如果要运行一个完整的 Linux 系统，建议取 2 GB 以上，比如 &lt;code&gt;-m 2G&lt;/code&gt;。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;更多参数可以参阅 &lt;a href=&#34;https://www.qemu.org/docs/master/system/riscv/virt.html&#34;&gt;QEMU - Generic Virtual Platform (virt)&lt;/a&gt;，或者查看完整的参数 &lt;a href=&#34;https://www.qemu.org/docs/master/system/qemu-manpage.html&#34;&gt;QEMU User Documentation&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;另外还有几个常用的设备：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;块设备，即虚拟磁盘，使用两个参数完成：&lt;/li&gt;&lt;/ul&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-device virtio-blk-device,drive=ID_NAME&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-drive file=IMAGE_FILE_NAME,format=raw,if=none,id=ID_NAME&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其中 &lt;code&gt;IMAGE_FILE_NAME&lt;/code&gt; 是磁盘映像文件的路径，&lt;code&gt;format&lt;/code&gt; 是映像的格式，一般有 &lt;code&gt;raw&lt;/code&gt; 和 &lt;code&gt;qcow2&lt;/code&gt; 两种。&lt;code&gt;if&lt;/code&gt; 用于指定接口类型，可选的值有 &lt;code&gt;ide&lt;/code&gt;, &lt;code&gt;scsi&lt;/code&gt;, &lt;code&gt;sd&lt;/code&gt;, &lt;code&gt;pflash&lt;/code&gt;, &lt;code&gt;virtio&lt;/code&gt; 和 &lt;code&gt;none&lt;/code&gt; 等。&lt;/p&gt;&lt;p&gt;有时也可以简写为：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-drive file=IMAGE_FILE_NAME,if=virtio&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;有关虚拟磁盘的详细信息可以参阅 &lt;a href=&#34;https://www.qemu.org/docs/master/system/images.html&#34;&gt;QEMU Disk Images&lt;/a&gt; 和 &lt;a href=&#34;https://www.qemu.org/docs/master/system/qemu-manpage.html#hxtool-1&#34;&gt;QEMU Block device options&lt;/a&gt;。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;网络接口，即虚拟网卡，使用两个参数完成：&lt;/li&gt;&lt;/ul&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-device virtio-net-device,netdev=ID_NAME&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-netdev user,id=ID_NAME&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;使用这种方式主机（host）和虚拟机（guest）都不用额外的设置，在虚拟机里直接通过 NAT 可以访问主机及外部网络。不过如果想在虚拟机里监听某个端口，让主机或者外部网络访问，则比较方便的方法是用端口映射，只需在 &lt;code&gt;-netdev&lt;/code&gt; 后面添加映射的端口列表即可，比如：&lt;/p&gt;&lt;p&gt;&lt;code&gt;-netdev user,id=net,hostfwd=tcp::2222-:22,hostfwd=tcp::12345-:1234&lt;/code&gt;&lt;/p&gt;&lt;p&gt;上面会把虚拟机的 SSH server 端口 &lt;code&gt;22&lt;/code&gt; 和 GDB Server 端口 &lt;code&gt;1234&lt;/code&gt; 分别映射到 &lt;code&gt;2222&lt;/code&gt; 和 &lt;code&gt;12345&lt;/code&gt;，这样一来，访问主机的 &lt;code&gt;2222&lt;/code&gt; 端口就会重定向到虚拟机的 &lt;code&gt;22&lt;/code&gt; 端口，因此使用 SSH 登录虚拟机的命令如下：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ ssh -p 2222 USER_NAME@localhost&lt;/code&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;文件映射，即把主机的某个文件或者目录映射进虚拟机里，使用两个参数完成：&lt;/li&gt;&lt;/ul&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-device virtio-9p-pci,fsdev=ID_NAME,mount_tag=sf_tag&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-fsdev local,id=ID_NAME,path=/path/to/your/host/dir,security_model=mapped-file&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在虚拟机里，使用 &lt;code&gt;mount&lt;/code&gt; 命令挂载之后就可以访问主机的目录了，比如：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ sudo mkdir -p /mnt/host&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ sudo mount -t 9p sf_tag /mnt/host&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;&lt;li&gt;随机产生器，使用两个参数完成：&lt;/li&gt;&lt;/ul&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-device virtio-rng-device,rng=ID_NAME&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-object rng-random,filename=/dev/urandom,id=ID_NAME&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;QEMU 还有很多使用技巧，感兴趣的可以参阅 &lt;a href=&#34;https://wiki.archlinux.org/title/QEMU&#34;&gt;QEMU - Arch Linux Wiki&lt;/a&gt; 和 &lt;a href=&#34;https://wiki.gentoo.org/wiki/QEMU/Options&#34;&gt;QEMU Options - Gentoo Wiki&lt;/a&gt;。&lt;/p&gt;&lt;h3 id=&#34;真实-risc-v-硬件&#34;&gt;真实 RISC-V 硬件&lt;/h3&gt;&lt;p&gt;本项目主要使用 QEMU RISC-V 来运行一个 Linux 开发环境，或者用 &lt;em&gt;全系统模式&lt;/em&gt; 来运行裸机程序，而比较少使用真实的 RISC-V 硬件来运行和测试，主要是因为使用虚拟机比较方便。&lt;/p&gt;&lt;p&gt;另一个原因是目前（截至 2022 年秋）RISC-V 的硬件环境还不太成熟稳定。RISC-V 芯片目前主要有目标为高性能的桌面和服务器芯片，以及目标为嵌入式设备的 MCU。高性能芯片价格比较昂贵，同时软件环境还不太完整（主要依赖移植 Linux 系统现有的软件，客观来说这需要一个漫长的过程）。至于 MCU 本应是 RISC-V 较好的应用场景，而现实情况却是一言难尽。大部分芯片以及开发板的开发文档非常不完整，所用的工具五花八门欠缺一致性，工具普遍缺乏广泛性的测试，且维护更新的生命周期很短，对片上调试（&lt;em&gt;On Chip Debug&lt;/em&gt;）功能的支持不足。因此河马蜀黍当前比较推荐使用虚拟机来运行、测试和调试 RISC-V 程序。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;如果想要购买开发板（&lt;code&gt;Dev-Kit&lt;/code&gt;），建议尽量选择芯片厂商自己推出的，同时检查它的文档是否齐全，工具有无持续维护和更新。对于开发者来说，还要查看它是否支持调试功能。至于第三方出品的开发板，除非其硬件原理图已开源而且你很熟悉相关零部件，否则应该尽量避免（尽管有时第三方的价格会便宜很多）。当然如果你已经充分掌握了芯片的特性，其实也可以自己制作开发板。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&#34;opensbi&#34;&gt;OpenSBI&lt;/h2&gt;&lt;p&gt;当使用 QEMU 模拟一个完整的 Linux 系统时，通常使用 OpenSBI 作为 &lt;code&gt;-bios&lt;/code&gt;，使用 &lt;a href=&#34;https://www.denx.de/wiki/U-Boot&#34;&gt;U-Boot&lt;/a&gt; 作为 &lt;code&gt;-kernel&lt;/code&gt;，然后将包含有 Linux 内核、根文件系统、基础软件的磁盘映像作为 &lt;em&gt;块设备&lt;/em&gt; 传给 QEMU。&lt;/p&gt;&lt;p&gt;U-Boot 是一个 Bootloader，其作用是从磁盘加载内核镜像，然后跳转到内核的入口，内核启动后 Bootloader 的任务也就结束了，这里不展开讲述。而 OpenSBI 则不同，它会对上一层的程序（也就是内核）提供部分硬件功能的调用服务，同时也会捕捉上一层程序的异常，在内核运行期间，OpenSBI 将一直驻留在内存中。下图是这几个程序的启动顺序：&lt;/p&gt;&lt;p&gt;&lt;img src=&#34;images/boot-sequence.png&#34; alt=&#34;boot sequence&#34;&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;注意 OpenSBI 和 Bootloader 都是由 ROM/QEMU 加载的，OpenSBI 并没有加载 Bootloader 的功能。内核倒是由 Bootloader 加载的。对于一些比较简单的系统，也可以不需要 Bootloader，而是由 OpenSBI 直接跳转到内核。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;OpenSBI 在跳转到 Bootloader 时，需要知道 Bootloader 的入口（即地址），因此 OpenSBI 有 3 种方式跳转方式，对应编译它之后得到的 3 个不同 Firmware：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;p&gt;fw_jump.binOpenSBI 直接把 Bootloader 的入口地址硬编码到程序里，因此 Bootloader 必须根据 OpenSBI 指定的地址加载进内存。跳转地址的数值会根据具体的平台而有所不同，如果没有特别指定，默认的是 &lt;code&gt;0x80400000&lt;/code&gt;（32-bit 系统）或者 &lt;code&gt;0x80200000&lt;/code&gt;（64-bit 系统），也可以查看 OpenSBI 的源代码 &lt;a href=&#34;https://github.com/riscv-software-src/opensbi/blob/master/platform/generic/objects.mk&#34;&gt;/platform/generic/objects.mk&lt;/a&gt;。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;fw_dynamic.binROM/QEMU 在加载 Bootloader 时，把入口地址写在结构体 &lt;code&gt;fw_dynamic_info&lt;/code&gt; 里，然后把该结构体的地址（即指针）通过寄存器 &lt;code&gt;a2&lt;/code&gt; 传递给 OpenSBI。在本篇文章顶部的那段 ROM 代码里有展示该过程。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;fw_payload.bin把 OpenSBI 和 Bootloader 打包为一个程序，这种跳转方式实现起来很简单。不过无论是 OpenSBI 更新还是 Bootloader 更新，都需要重新打包。一般用于 OpenSBI、Bootloader 和内核都不需要更新的微型设备。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;在启动 &lt;code&gt;qemu-system-riscv64&lt;/code&gt; 程序时，如果忽略 &lt;code&gt;-bios&lt;/code&gt; 参数，则会使用内置的 fw_dynamic.bin。关于 OpenSBI 的更多介绍，可以参阅 &lt;a href=&#34;https://riscv.org/wp-content/uploads/2019/06/13.30-RISCV_OpenSBI_Deep_Dive_v5.pdf&#34;&gt;OpenSBI Deep Dive&lt;/a&gt;。&lt;/p&gt;&lt;h3 id=&#34;调用-sbi-服务&#34;&gt;调用 SBI 服务&lt;/h3&gt;&lt;p&gt;在 Bootloader 或者内核里调用 SBI 的服务，跟在应用程序里向内核发起 &lt;em&gt;系统调用&lt;/em&gt; 的方式非常相似。根据 &lt;a href=&#34;https://github.com/riscv-non-isa/riscv-sbi-doc/releases&#34;&gt;SBI 规范&lt;/a&gt; 的说明：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;SBI 服务被分为 &lt;code&gt;Base&lt;/code&gt;, &lt;code&gt;Timer&lt;/code&gt; 等 7 个类别，在规范里称为 &lt;code&gt;extension&lt;/code&gt;，每个 &lt;code&gt;extension&lt;/code&gt; 都有一个 ID，叫 &lt;code&gt;eid&lt;/code&gt;，比如 &lt;code&gt;Base Extension&lt;/code&gt; 的 &lt;code&gt;eid&lt;/code&gt; 是 &lt;code&gt;0x10&lt;/code&gt;，&lt;code&gt;Timer Extension&lt;/code&gt; 的是 &lt;code&gt;0x54494D45&lt;/code&gt;；&lt;/li&gt;&lt;li&gt;每个 &lt;code&gt;extension&lt;/code&gt; 里有一系列函数，每个函数都有一个 ID，叫 &lt;code&gt;fid&lt;/code&gt;，比如 &lt;code&gt;Base Extension&lt;/code&gt; 里的函数 &lt;code&gt;sbi_get_spec_version&lt;/code&gt; 的 &lt;code&gt;fid&lt;/code&gt; 是 &lt;code&gt;0x0&lt;/code&gt;，&lt;code&gt;sbi_get_impl_id&lt;/code&gt; 的是 &lt;code&gt;0x1&lt;/code&gt;；&lt;/li&gt;&lt;li&gt;调用 SBI 服务时，将 &lt;code&gt;eid&lt;/code&gt; 传入寄存器 &lt;code&gt;a7&lt;/code&gt;，将 &lt;code&gt;fid&lt;/code&gt; 传入寄存器 &lt;code&gt;a6&lt;/code&gt;，将参数传入寄存器 &lt;code&gt;a0&lt;/code&gt; 到 &lt;code&gt;a5&lt;/code&gt;，然后执行 &lt;code&gt;ecall&lt;/code&gt; 指令。&lt;/li&gt;&lt;li&gt;SBI 服务将结果通过寄存器 &lt;code&gt;a0&lt;/code&gt; 和 &lt;code&gt;a1&lt;/code&gt; 返回，其中 &lt;code&gt;a0&lt;/code&gt; 是错误代码，如果函数成功，则错误代码是 &lt;code&gt;0&lt;/code&gt;，而 &lt;code&gt;a1&lt;/code&gt; 则是我们真正需要的返回值。&lt;/li&gt;&lt;/ul&gt;&lt;blockquote&gt;&lt;p&gt;完整的 &lt;code&gt;eid&lt;/code&gt; 和 &lt;code&gt;fid&lt;/code&gt; 也可以从 OpenSBI 源代码 &lt;a href=&#34;https://github.com/riscv-software-src/opensbi/blob/master/include/sbi/sbi_ecall_interface.h&#34;&gt;/include/sbi/sbi_ecall_interface.h&lt;/a&gt; 获得。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;在本文的子目录 [resources/hello-sbi] 里有一个简单的调用 SBI 服务的示例程序，其作用是依次调用 &lt;code&gt;sbi_get_spec_version&lt;/code&gt; 和 &lt;code&gt;sbi_get_impl_id&lt;/code&gt; 函数，即获取当前系统的 SBI 规范版本号以及 SBI 服务程序的实现者代号（比如 0 代表 &lt;em&gt;Berkeley Boot Loader (BBL)&lt;/em&gt;，1 代表 &lt;em&gt;OpenSBI&lt;/em&gt;，4 代表 &lt;em&gt;RustSBI&lt;/em&gt;），然后将结果输出到串口控制台。&lt;/p&gt;&lt;p&gt;程序比较简单，这里仅展示关键的部分 &lt;code&gt;sbi-base.S&lt;/code&gt;：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-s&#34; data-lang=&#34;s&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.equ sbi_base_eid, &lt;span style=&#34;color:#ae81ff&#34;&gt;0x10&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.equ sbi_get_sbi_spec_version_fid, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.equ sbi_get_sbi_impl_id_fid, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;sbi_get_spec_version&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    li      a7, sbi_base_eid&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    li      a6, sbi_get_sbi_spec_version_fid&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ecall&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    mv      a0, a1&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ret&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;sbi_get_impl_id&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    li      a7, sbi_base_eid&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    li      a6, sbi_get_sbi_impl_id_fid&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ecall&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    mv      a0, a1&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ret&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;基本上就是设置寄存器 &lt;code&gt;a7&lt;/code&gt;, &lt;code&gt;a6&lt;/code&gt; 的值，然后执行 &lt;code&gt;ecall&lt;/code&gt; 指令，对于返回值，为了简化程序，这里只获取 &lt;code&gt;a1&lt;/code&gt; 的值，所以使用指令 &lt;code&gt;mv a0, a1&lt;/code&gt; 把寄存器 &lt;code&gt;a0&lt;/code&gt; 原来的值用 &lt;code&gt;a1&lt;/code&gt; 的值覆盖了。这样 C 语言就可以像调用普通函数一样只返回一个 int 类型的值。&lt;/p&gt;&lt;p&gt;子目录里有一个 Bash 脚本 &lt;code&gt;run.sh&lt;/code&gt; 实现所有的编译、链接和运行工作，执行 &lt;code&gt;run.sh&lt;/code&gt;：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ ./run.sh&lt;/code&gt;&lt;/p&gt;&lt;p&gt;输出结果如下：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;OpenSBI v1.0&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   ____                    _____ ____ _____&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  / __ \                  / ____|  _ \_   _|&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; | |  | |_ __   ___ _ __ | (___ | |_) || |&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; | |  | | &amp;#39;_ \ / _ \ &amp;#39;_ \ \___ \|  _ &amp;lt; | |&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; | |__| | |_) |  __/ | | |____) | |_) || |_&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  \____/| .__/ \___|_| |_|_____/|____/_____|&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        | |&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        |_|&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Platform Name             : riscv-virtio,qemu&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Platform Features         : medeleg&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Platform HART Count       : 1&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Platform IPI Device       : aclint-mswi&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Platform Timer Device     : aclint-mtimer @ 10000000Hz&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Platform Console Device   : uart8250&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Platform HSM Device       : ---&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Platform Reboot Device    : sifive_test&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Platform Shutdown Device  : sifive_test&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Firmware Base             : 0x80000000&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Firmware Size             : 252 KB&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Runtime SBI Version       : 0.3&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Domain0 Name              : root&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Domain0 Boot HART         : 0&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Domain0 HARTs             : 0*&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Domain0 Region00          : 0x0000000002000000-0x000000000200ffff (I)&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Domain0 Region01          : 0x0000000080000000-0x000000008003ffff ()&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Domain0 Region02          : 0x0000000000000000-0xffffffffffffffff (R,W,X)&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Domain0 Next Address      : 0x0000000086000000&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Domain0 Next Arg1         : 0x0000000087e00000&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Domain0 Next Mode         : S-mode&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Domain0 SysReset          : yes&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;从中可见当前系统的 SBI 规范版本是 &lt;code&gt;0.3&lt;/code&gt;，实现程序是 &lt;em&gt;OpenSBI&lt;/em&gt;，并且应用程序 &lt;code&gt;app.out&lt;/code&gt; 的入口地址 &lt;code&gt;0x8600_0000&lt;/code&gt; 也正确地取得。&lt;/p&gt;&lt;p&gt;然后下面是程序 &lt;code&gt;app.out&lt;/code&gt; 的输出内容：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Hello SBI!&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;SBI specification version, major: 0, minor: 3.&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;SBI implementation ID: 1.&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;结果是正确的。&lt;/p&gt;&lt;h2 id=&#34;裸机程序的调试&#34;&gt;裸机程序的调试&lt;/h2&gt;&lt;p&gt;使用 QEMU 调试裸机程序非常方便，只需在启动 QEMU 程序时，在命令行参数末尾添加上 &lt;code&gt;-s -S&lt;/code&gt; 参数，QEMU 就会成为一个 GDB Server，然后开发者就可以使用 GDB Client 来进行调试了。其中参数：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;-s&lt;/code&gt; 是 &lt;code&gt;-gdb tc::1234&lt;/code&gt; 的简写，表示 QEMU 将会在 TCP 端口 &lt;code&gt;1234&lt;/code&gt; 开启 GDB Server。&lt;/li&gt;&lt;li&gt;&lt;code&gt;-S&lt;/code&gt; 表示 QEMU 启动后先暂停 CPU，直到 GDB Client 连接进来并执行诸如 &lt;code&gt;c&lt;/code&gt;，&lt;code&gt;si&lt;/code&gt; 等命令，QEMU CPU 才开始执行指令。&lt;/li&gt;&lt;/ul&gt;&lt;h3 id=&#34;gdb-的调试方式&#34;&gt;GDB 的调试方式&lt;/h3&gt;&lt;p&gt;GDB 程序可以分为 &lt;em&gt;服务端&lt;/em&gt; 和 &lt;em&gt;客户端&lt;/em&gt;，其中服务端负责加载和执行目标程序，客户端负责加载目标程序的符号，以及向服务端发送各种调试命令。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;如果准备调试某个程序，通常需要在 GCC 编译生成目标程序时加上 &lt;code&gt;-g&lt;/code&gt; 参数，以便在调试时能显示相应的源代码。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&#34;images/gdb.png&#34; alt=&#34;GDB&#34;&gt;&lt;/p&gt;&lt;p&gt;上图是常见的几种调试方式：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;GDB 调试本地的程序&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;这是最常见的一种方式，GDB 直接加载、运行、调试位于本地的目标程序。此时 GDB 程序可以视为集服务端和客户端于一体。比如假设有一个可执行文件 &lt;code&gt;app.out&lt;/code&gt;，有某个函数未能预期工作，那么可以用命令 &lt;code&gt;$ gdb app.out&lt;/code&gt; 来开始调试。进入 GDB 交互界面后，就可以 &amp;ldquo;开始为函数设置断点、逐行运行、观察局部变量及寄存器状态&amp;rdquo; 等一系列常规操作。&lt;/p&gt;&lt;p&gt;调试本地程序也可以分成服务端和客户端两个程序进行，即用命令 &lt;code&gt;$ gdbserver localhost:1234 app.out&lt;/code&gt; 启动 GDB Server，用命令 &lt;code&gt;$ gdb -ex &amp;quot;target remote localhost:1234&amp;quot;&lt;/code&gt; 启动 GDB Client。不过实在没必要这样做。&lt;/p&gt;&lt;p&gt;使用这种调试方式有一个局限：就是目标程序必须是当前平台可运行的（即架构和平台都符合）。&lt;/p&gt;&lt;ol start=&#34;2&#34;&gt;&lt;li&gt;GDB Server 在另外一台机器上运行&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;开发者在当前机器上运行的 GDB 会作为客户端，通过 GDB &lt;code&gt;target remote HOST:PORT&lt;/code&gt; 命令连接到 GDB Server，然后向 GDB Server 发送调试命令、查看调试的结果等。&lt;/p&gt;&lt;p&gt;这种调试方式意味着目标程序是在另一台机器上运行，也就是说，此时在 GDB Client 里所有的显示信息，包括程序的共享库加载情况、进程的内存映射情况、寄存器的值等，都是 Server 机器上的信息。&lt;/p&gt;&lt;p&gt;让人疑惑的是，使用这种方式启动 GDB Client 时，一般也同时需要在本机上有目标程序、目标程序的源代码，而且也需要加载进 GDB Client 里。这是因为 GDB Server 只负责执行目标程序，虽然目标程序里本来就有调试信息，但 GDB Server 发送给客户端的只有当前指令的位置以及寄存器和内存数据等有限的内容。GDB Client 需要程序的符号信息（比如函数的名称、地址、源代码等）才能将有限的数据还原为现场信息（比如将当前执行位置转换为源代码的当前行）。&lt;/p&gt;&lt;ol start=&#34;3&#34;&gt;&lt;li&gt;GDB Server 为 QEMU。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;这种方式其实跟第 2 种情况类似，只不过 GDB Server 在背后同时启动了一台虚拟机，并且完全控制这台虚拟机的硬件。&lt;/p&gt;&lt;ol start=&#34;4&#34;&gt;&lt;li&gt;GDB Server 为 OpenOCD&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;img src=&#34;images/openocd.png&#34; alt=&#34;OpenOCD&#34;&gt;&lt;/p&gt;&lt;p&gt;这种方式常见于调试 MCU 或者 FPGA 的情况，之所以需要 OpenOCD 作为中间媒介，是因为目标机器根本无法运行 GDB Server，它只提供原始的或者有限的调试能力。OpenOCD 起到一个 &lt;em&gt;适配器&lt;/em&gt; 的作用，把原始的信号或者有限的调试能力转换为大家熟悉的 GDB 界面（技术来说，OpenOCD 提供了 GDB Server Protocol）。QEMU 的调试功能其工作原理跟 OpenOCD 类似。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;注意图中的 &lt;a href=&#34;https://www.fpga4fun.com/JTAG1.html&#34;&gt;JTAG&lt;/a&gt; 和 &lt;a href=&#34;https://wiki.segger.com/SWD&#34;&gt;SWD&lt;/a&gt; 是下载器跟 MCU 之间的通信协议（也可以理解为下载器跟 MCU 之间的电线连接方式），而常见的 &lt;code&gt;ST-Link&lt;/code&gt;，&lt;code&gt;J-Link&lt;/code&gt; 等一般是指下载器（也叫调试器、仿真器、烧录器、探针 &lt;code&gt;probe&lt;/code&gt; 等等古灵精怪的名称）硬件的名称。&lt;code&gt;CMSIS-DAP&lt;/code&gt; 和 &lt;code&gt;DAPLink&lt;/code&gt; 是 ARM 的开发的用于连接电脑（USB）和下载器之间的固件（&lt;code&gt;固件&lt;/code&gt; 可以简单理解为 &lt;code&gt;程序&lt;/code&gt;）。简单来说，如果你需要一个下载器硬件，除了购买现成的，还可以使用开源的 &lt;code&gt;DAPLink&lt;/code&gt; 固件和一个 STM32F103 MCU 自己动手制作，详细可参阅 &lt;a href=&#34;https://daplink.io/&#34;&gt;DAPLink.io&lt;/a&gt;。OpenOCD 支持的下载器列表可以参阅 &lt;a href=&#34;https://openocd.org/doc/html/Debug-Adapter-Hardware.html&#34;&gt;OpenOCD - Debug Adapter Hardware&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;有些 MCU 开发板自带了下载器，比如 &lt;em&gt;micro:bit&lt;/em&gt;，通过 USB 连接到电脑之后会出现一个 U 盘，然后把 &lt;em&gt;HEX/BIN&lt;/em&gt; 文件往里面拖放就可以完成烧录，其实这是 &lt;code&gt;DAPLink&lt;/code&gt; 的功能，具体可以参阅&lt;a href=&#34;https://tech.microbit.org/software/daplink-interface/&#34;&gt;这里&lt;/a&gt;。至于 &lt;em&gt;STM32 Nucleo&lt;/em&gt; 系列开发板因为集成了 &lt;code&gt;ST-Link&lt;/code&gt; 所以连接电脑之后也会出现一个 U 盘。当然还有一些比如 &lt;em&gt;Raspberry Pi Pico&lt;/em&gt; 开发板，按住板上的 &lt;code&gt;BOOTSEL&lt;/code&gt; 按钮再连接 USB 接线也会在电脑上出现一个 U 盘，这是 一个名字叫 &lt;a href=&#34;https://github.com/microsoft/uf2&#34;&gt;UF2 Bootloader&lt;/a&gt; 用于简化下载固件工作的工具，它不具有调试功能，不过官方倒是提供了一个 &lt;a href=&#34;https://www.raspberrypi.com/documentation/microcontrollers/raspberry-pi-pico.html#debugging-using-another-raspberry-pi-pico&#34;&gt;Pico 版 DAPLink 固件&lt;/a&gt;，它可以让 Pico 变成一个下载器。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;使用 OpenOCD 连接 MCU 开发板时，需要指定 &lt;code&gt;interface/*.cfg&lt;/code&gt; 文件，该文件主要内容就是用于指定下载器（驱动）的名称，详细可参阅 &lt;a href=&#34;https://openocd.org/doc/html/Debug-Adapter-Configuration.html&#34;&gt;OpenOCD - Debug Adapter Configuration&lt;/a&gt;。需要注意的是，虽然大部分开发板都带有 USB 接口，但这个接口一般只用于供电、烧录（也叫下载）、和串口通信（UART），不一定支持调试功能。至于 STM32 系列的芯片，它内置了 USB 通信功能，有些核心板（也就是除了 MCU 芯片之外没有任何其它芯片的开发板）把 USB 接口直接连接到芯片的 USB 端口，但因为默认情况下没有相应的程序，所以它只能用于供电，除此没有任何功能。&lt;/p&gt;&lt;h3 id=&#34;调试裸机程序&#34;&gt;调试裸机程序&lt;/h3&gt;&lt;p&gt;下面演示如何通过 QEMU 调试裸机程序，所使用的程序是本文开头演示的 &lt;code&gt;hello-uart&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;首先编译：&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ riscv64-elf-as -g -o app.o app.S&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ riscv64-elf-ld -T app.lds -o app.out app.o&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;注意要添加 &lt;code&gt;-g&lt;/code&gt; 参数，这样在调试时能显示等多信息。&lt;/p&gt;&lt;p&gt;然后启动 QEMU 的调试服务：&lt;/p&gt;&lt;p&gt;&lt;code&gt;$ qemu-system-riscv64 -machine virt -nographic -bios none -kernel app.out -s -S&lt;/code&gt;&lt;/p&gt;&lt;p&gt;现在 QEMU 应该是处于静止的状态，正等待 GDB Client 连接。&lt;/p&gt;&lt;p&gt;&lt;img src=&#34;images/gdb-bare-metal.webp&#34; alt=&#34;gdb bare-metal&#34;&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;set disassemble-next-line on&lt;/code&gt;&lt;/p&gt;</description>
     </item>
   
 </channel>
</rss>
